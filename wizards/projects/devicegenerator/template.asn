%{Model}-DATAVIEW DEFINITIONS ::= BEGIN

    PlatformSpecificPointer ::= INTEGER (0 .. 18446744073709551615) -- 64bit max

    SystemBus ::= INTEGER (0 .. 255)

    SystemDevice ::= INTEGER (0 .. 255)

    RemoteInterface ::= INTEGER (0 .. 255)

    InputDataPtr ::= PlatformSpecificPointer

    OutputDataPtr ::= PlatformSpecificPointer

    DataLength ::= INTEGER (0 .. 4294967295) --(Broker/Packetizer)const size_t dataSize/Length

    PacketType ::= INTEGER (0 .. 255) --(Broker/Packetizer)const Packetizer_PacketType packetType

    PacketSource ::= INTEGER (0 .. 65535) --(Packetizer)const uint16_t source

    PacketDestination ::= INTEGER (0 .. 65535) --(Packetizer)const uint16_t destination

    PacketPointer ::= PlatformSpecificPointer --(Packetizer)uint8_t* const packetPointer

    PacketDataOffset ::= INTEGER (0 .. 4294967295) --(Packetizer)const size_t dataOffset

    RequestErrorCodePtr ::= PlatformSpecificPointer --(Depacketizer)int32_t* const errorCode

    SystemBusArray ::= SEQUENCE (SIZE (255)) OF SystemBus --(Broker)enum SystemBus valid_buses[SYSTEM_BUSES_NUMBER]

    InitRequestData ::= SEQUENCE{
        private-data InputDataPtr, --(Broker)void* private_data
        bus-id SystemBus, --(Broker)const enum SystemBus bus_id
        device-id SystemDevice, --(Broker)const enum SystemDevice device_id
        device-configuration InputDataPtr, --(Broker)void* device_configuration,
        remote-device-configuration InputDataPtr --(Broker)void* remote_device_configuration
    }

    DeliveredRequestData ::= SEQUENCE{
        private-data InputDataPtr, --(Broker)void* private_data
        data InputDataPtr, --(Broker)const uint8_t* const
        length DataLength --(Broker)const size_t
    }

    ReceivedRequestData ::= SEQUENCE{
        private-data OutputDataPtr --(Broker)void* private_data
    }

    -- ASN.1 Type definitions must start with an uppercase
    -- Field names in records (SEQUENCE) must start with a lowercase
    -- Underscores are not allowed: use dash (hyphen) 
    -- For integers do not assume that small ranges will be translated to small
    -- types in C or Ada (expect unsigned or signed 64 bits types with subtypes
    -- for the range in Ada)

    -- Simple types:

    -- TASTE-Boolean ::= BOOLEAN
    -- MyInteger   ::= INTEGER (0..255)
    -- MyReal      ::= REAL (0.0 .. 1000.0)
    -- MyBool      ::= BOOLEAN
    -- MyEnum      ::= ENUMERATED { hello, world, how-are-you }

    -- Complex types:

    --  MySeq       ::= SEQUENCE {
    --      input-data  MyInteger,
    --      output-data MyInteger,
    --      validity    ENUMERATED { valid, invalid }
    --  }
    --
    --  MyChoice    ::= CHOICE {
    --      a BOOLEAN,
    --      b MySeq
    --  }
    --
    --  MySeqOf     ::= SEQUENCE (SIZE (2)) OF MyEnum
    --
    --  MyOctStr    ::= OCTET STRING (SIZE (3))
    --
    --  -- You can also declare constants
    --  myVar       MySeqOf     ::= { hello, world }
END
