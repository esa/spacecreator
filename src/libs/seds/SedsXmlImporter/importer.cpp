/** @file
 * This file is part of the SpaceCreator.
 *
 * @copyright (C) 2021 N7 Space Sp. z o.o.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/lgpl-2.1.html>.
 */

#include "importer.h"

#include <QDebug>
#include <QFileInfo>
#include <QString>
#include <QXmlStreamReader>
#include <algorithm>
#include <conversion/common/exceptions.h>
#include <conversion/common/import/exceptions.h>
#include <conversion/seds/SedsOptions/options.h>
#include <seds/SedsXmlParser/parser.h>
#include <seds/XmlPreprocessor/preprocessor.h>
#include <seds/XmlValidator/validator.h>

using conversion::FileNotFoundException;
using conversion::Options;
using conversion::importer::ImportException;

namespace seds::importer {

using conversion::seds::SedsOptions;
using parser::Parser;
using preprocessor::XmlPreprocessor;
using symbolreader::SymbolDefinitionReader;
using validator::XmlValidator;

const QString SedsXmlImporter::preprocessedFilenameTemplate = "preprocessed_%1";

std::unique_ptr<conversion::Model> SedsXmlImporter::importModel(const Options &options) const
{
    const auto externalReferences = readExternalReferences(options);
    const auto preprocessedFilename = preprocess(externalReferences, options);

    // Validation can be disabled by the user
    if (!options.isSet(SedsOptions::skipValidation)) {
        validate(preprocessedFilename, options);
    }

    auto model = Parser::parse(preprocessedFilename);

    // Cleanup working directory after importing
    if (!options.isSet(SedsOptions::keepIntermediateFiles)) {
        QFile preprocessedFile(preprocessedFilename);
        preprocessedFile.remove();
    }

    return model;
}

SymbolDefinitionReader::ExternalReferencesMap SedsXmlImporter::readExternalReferences(const Options &options) const
{
    SymbolDefinitionReader::ExternalReferencesMap externalReferences;

    // First check if external references should be read from a file
    if (const auto externalRefFile = options.value(SedsOptions::externalRefFile); externalRefFile) {
        externalReferences = SymbolDefinitionReader::readSymbols(*externalRefFile);
    }

    // External references can be also be declared via options
    for (const auto &externalReferenceDeclaration : options.values(SedsOptions::externalRef)) {
        const auto externalReference = externalReferenceDeclaration.split(':', QString::SkipEmptyParts);
        externalReferences.insert({ externalReference[0], externalReference[1] });
    }

    return externalReferences;
}

QString SedsXmlImporter::preprocess(
        const SymbolDefinitionReader::ExternalReferencesMap &externalReferences, const Options &options) const
{
    const auto inputFilename = options.value(SedsOptions::inputFile);
    if (!inputFilename) {
        throw ImportException("File to import wasn't specified");
    }

    const QFileInfo inputFileInfo(*inputFilename);
    if (!inputFileInfo.exists()) {
        throw FileNotFoundException(*inputFilename, "while importing");
    }

    // Intermediate preprocessed file is generated by preprocessor
    // Either use name provided in the options or use default `preprocessed_%input%`
    const auto preprocessedFilename = [&]() {
        const auto value = options.value(SedsOptions::preprocessedFile);
        if (value) {
            return *value;
        } else {
            return preprocessedFilenameTemplate.arg(*inputFilename);
        }
    }();

    XmlPreprocessor::preprocess(*inputFilename, preprocessedFilename, externalReferences);

    return preprocessedFilename;
}

void SedsXmlImporter::validate(const QString &preprocessedFilename, const Options &options) const
{
    const auto schemaFilename = [&]() {
        const auto value = options.value(SedsOptions::schemaFile);
        if (value) {
            return *value;
        } else {
            return getSchemaFilename(preprocessedFilename);
        }
    }();

    XmlValidator::validate(preprocessedFilename, schemaFilename);
}

QString SedsXmlImporter::getSchemaFilename(const QString &filename) const
{
    QFile file(filename);
    if (!file.open(QIODevice::ReadWrite)) {
        throw ImportException(file.errorString());
    }

    // Schema filename should be present in PackageFile/DataSheet
    auto xmlReader = QXmlStreamReader(&file);
    xmlReader.readNextStartElement();

    const auto attributes = xmlReader.attributes();
    const auto found = std::find_if(std::begin(attributes), std::end(attributes),
            [](auto &&attribute) { return attribute.name() == QStringLiteral("schemaLocation"); });

    if (found != std::end(attributes)) {
        // xmi:schemaLocation contains url and schema filename separated by space
        const auto schemaLocation = found->value().split(" ", QString::SkipEmptyParts);

        if (schemaLocation.size() != 2) {
            throw ImportException("xmi:schemaLocation in the validated file is incorrect");
        }

        return schemaLocation.at(1).toString();
    } else {
        throw ImportException("Schema filename wasn't specified nor found in the validated file");
    }
}

} // namespace seds::importer
