/** @file
  * This file is part of the SpaceCreator.
  *
  * @copyright (C) 2021 N7 Space Sp. z o.o.
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
  * License as published by the Free Software Foundation; either
  * version 2 of the License, or (at your option) any later version.
  *
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Library General Public License for more details.
  *
  * You should have received a copy of the GNU Library General Public License
  * along with this program. If not, see <https://www.gnu.org/licenses/lgpl-2.1.html>.
  */

#include "importer.h"

#include <algorithm>

#include <QDebug>
#include <QFileInfo>
#include <QString>
#include <QXmlStreamReader>

#include <converter/import/exceptions.h>
#include <seds/SedsXmlParser/parser.h>
#include <seds/XmlPreprocessor/preprocessor.h>
#include <seds/XmlValidator/validator.h>

using converter::import::FileNotFound;
using converter::import::ImportException;
using converter::import::Options;

namespace seds::importer {

using parser::Parser;
using preprocessor::XmlPreprocessor;
using symbolreader::SymbolDefinitionReader;
using validator::XmlValidator;

const QString SedsXmlImporter::preprocessedFilenameTemplate = "preprocessed_%1";

std::unique_ptr<converter::Model>
SedsXmlImporter::import(const Options& options)
{
    const auto externalReferences = readExternalReferences(options);
    const auto preprocessedFilename = preprocess(externalReferences, options);

    // Validation can be disabled by the user
    if(!options.isSet(Options::Key::SkipSedsValidation)) {
        validate(preprocessedFilename, options);
    }

    auto model = Parser::parse(preprocessedFilename);

    // Cleanup working directory after importing
    if(!options.isSet(Options::Key::KeepIntermediateFiles)) {
        QFile preprocessedFile(preprocessedFilename);
        preprocessedFile.remove();
    }

    return model;
}

SymbolDefinitionReader::ExternalReferencesMap
SedsXmlImporter::readExternalReferences(const Options& options)
{
    SymbolDefinitionReader::ExternalReferencesMap externalReferences;

    // First check if external references should be read from a file
    if(const auto externalRefFile = options.value(Options::Key::ExternalRefFile); externalRefFile) {
        externalReferences = SymbolDefinitionReader::readSymbols(*externalRefFile);
    }

    // External references can be also be declared via options
    for(const auto& externalReferenceDeclaration : options.values(Options::Key::ExternalRef)) {
        const auto externalReference = externalReferenceDeclaration.split(':', QString::SkipEmptyParts);
        externalReferences.insert({ externalReference[0], externalReference[1] });
    }

    return externalReferences;
}

QString
SedsXmlImporter::preprocess(const SymbolDefinitionReader::ExternalReferencesMap& externalReferences,
                            const Options& options)
{
    const auto inputFilename = options.value(Options::Key::InputFile);
    if(!inputFilename) {
        throw ImportException("File to import wasn't specified");
    }

    const QFileInfo inputFileInfo(*inputFilename);
    if(!inputFileInfo.exists()) {
        throw FileNotFound(*inputFilename, "while importing");
    }

    // Intermediate preprocessed file is generated by preprocessor
    // Either use name provided in the options or use default `preprocessed_%input%`
    const auto preprocessedFilename = [&]() {
        const auto value = options.value(Options::Key::PreprocessedFile);
        if(value) {
            return *value;
        } else {
            return preprocessedFilenameTemplate.arg(*inputFilename);
        }
    }();

    XmlPreprocessor::preprocess(*inputFilename, preprocessedFilename, externalReferences);

    return preprocessedFilename;
}

void
SedsXmlImporter::validate(const QString& preprocessedFilename, const Options& options)
{
    const auto schemaFilename = [&]() {
        const auto value = options.value(Options::Key::SchemaFile);
        if(value) {
            return *value;
        } else {
            return getSchemaFilename(preprocessedFilename);
        }
    }();

    XmlValidator::validate(preprocessedFilename, schemaFilename);
}

QString
SedsXmlImporter::getSchemaFilename(const QString& filename)
{
    QFile file(filename);
    if(!file.open(QIODevice::ReadWrite)) {
        throw ImportException(file.errorString());
    }

    // Schema filename should be present in PackageFile/DataSheet
    auto xmlReader = QXmlStreamReader(&file);
    xmlReader.readNextStartElement();

    const auto attributes = xmlReader.attributes();
    const auto found = std::find_if(std::begin(attributes), std::end(attributes), [](auto&& attribute) {
        return attribute.name() == QStringLiteral("schemaLocation");
    });

    if(found != std::end(attributes)) {
        // xmi:schemaLocation contains url and schema filename separated by space
        const auto schemaLocation = found->value().split(" ", QString::SkipEmptyParts);

        if(schemaLocation.size() != 2) {
            throw ImportException("xmi:schemaLocation in the validated file is incorrect");
        }

        return schemaLocation.at(1).toString();
    } else {
        throw ImportException("Schema filename wasn't specified nor found in the validated file");
    }
}

} // namespace seds::importer
