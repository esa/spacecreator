/** @file
 * This file is part of the SpaceCreator.
 *
 * @copyright (C) 2024 N7 Space Sp. z o.o.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/lgpl-2.1.html>.
 */

#include "asn1typehelper.h"

#include "sequencecomponentvisitor.h"

#include <QDebug>
#include <asn1library/asn1/types/choice.h>
#include <asn1library/asn1/types/ia5string.h>
#include <asn1library/asn1/types/octetstring.h>
#include <asn1library/asn1/types/sequence.h>
#include <asn1library/asn1/types/sequenceof.h>
#include <asn1library/asn1/types/type.h>
#include <asn1library/asn1/types/userdefinedtype.h>
#include <conversion/common/escaper/escaper.h>
#include <conversion/common/translation/exceptions.h>
#include <promela/Asn1ToPromelaTranslator/visitors/sizeconstraintvisitor.h>
#include <promela/PromelaCommon/constants.h>
#include <promela/PromelaCommon/namehelper.h>
#include <promela/PromelaModel/constant.h>

using Asn1Acn::IntegerValue;
using Asn1Acn::OctetStringValue;
using Asn1Acn::StringValue;
using conversion::Escaper;
using conversion::translator::TranslationException;
using promela::common::PromelaConstants;
using promela::common::PromelaNameHelper;
using promela::model::Constant;
using promela::model::Expression;
using promela::model::VariableRef;

namespace promela::translator {

// This helper generates c code for assignment of promela type to c type (generated by asn1scc) and vice
// This helper can generate a flat list of references to atomic promela types, what can be
// used to printf value of complex types.
// The code is generated recursively for components of complex types.
Asn1TypeHelper::Asn1TypeHelper(const Asn1Acn::Asn1Model *asn1Model, QString target, QString source)
    : m_asn1Model(asn1Model)
    , m_target(std::move(target))
    , m_source(std::move(source))
{
}

QString Asn1TypeHelper::createAssignmentTemplateFromPromelaToC(const QString &typeName)
{
    const Asn1Acn::TypeAssignment *type = findType(typeName);
    if (type == nullptr) {
        QString message = QString("Cannot find type %1").arg(typeName);
        throw TranslationException(std::move(message));
    }

    return createAssignmentTemplateFromPromelaToC(Escaper::escapeCName(typeName), type->type());
}

QString Asn1TypeHelper::createAssignmentTemplateFromCToPromela(const QString &typeName)
{
    const Asn1Acn::TypeAssignment *type = findType(typeName);
    if (type == nullptr) {
        QString message = QString("Cannot find type %1").arg(typeName);
        throw TranslationException(std::move(message));
    }

    return createAssignmentTemplateFromCToPromela(Escaper::escapeCName(typeName), type->type());
}

QList<Asn1TypeHelper::PrintfTemplate> Asn1TypeHelper::generatePrintfTemplate(const QString &typeName)
{
    const Asn1Acn::TypeAssignment *type = findType(typeName);
    if (type == nullptr) {
        QString message = QString("Cannot find type %1").arg(typeName);
        throw TranslationException(std::move(message));
    }

    QList<VariableRef> fields = generateListOfFields(type->type());

    QList<PrintfTemplate> result;
    while (!fields.empty()) {
        const qsizetype maxGroupLength = 10;
        qsizetype groupLength = std::min(fields.size(), maxGroupLength);

        QList<VariableRef> group = fields.sliced(0, groupLength);
        fields.remove(0, groupLength);

        QString fmt = QString("%d, ").repeated(groupLength - 1);
        if (fields.empty()) {
            // for last field, do not append separator
            fmt.append("%d");
        } else {
            fmt.append("%d, ");
        }

        result.append(PrintfTemplate {
                fmt,
                group,
        });
    }

    return result;
}

QString Asn1TypeHelper::createAssignmentTemplateFromPromelaToC(
        const QString &cTypeName, const Asn1Acn::Types::Type *type)
{
    switch (type->typeEnum()) {
    case Asn1Acn::Types::Type::ASN1Type::INTEGER:
    case Asn1Acn::Types::Type::ASN1Type::REAL:
    case Asn1Acn::Types::Type::ASN1Type::BOOLEAN:
    case Asn1Acn::Types::Type::ASN1Type::ENUMERATED:
        // ordinary assignment
        return m_target + " = " + m_source + ";\n";

    case Asn1Acn::Types::Type::ASN1Type::SEQUENCE:
        return sequenceAssignmentFromPromelaToC(cTypeName, dynamic_cast<const Asn1Acn::Types::Sequence *>(type));

    case Asn1Acn::Types::Type::ASN1Type::SEQUENCEOF:
        return sequenceOfAssignmentFromPromelaToC(cTypeName, dynamic_cast<const Asn1Acn::Types::SequenceOf *>(type));

    case Asn1Acn::Types::Type::ASN1Type::CHOICE:
        return choiceAssignmentFromPromelaToC(cTypeName, dynamic_cast<const Asn1Acn::Types::Choice *>(type));

    case Asn1Acn::Types::Type::ASN1Type::OCTETSTRING:
        return octetStringAssignmentFromPromelaToC(dynamic_cast<const Asn1Acn::Types::OctetString *>(type));

    case Asn1Acn::Types::Type::ASN1Type::IA5STRING:
        return ia5StringAssignmentFromPromelaToC(dynamic_cast<const Asn1Acn::Types::IA5String *>(type));

    case Asn1Acn::Types::Type::ASN1Type::USERDEFINED: {
        const Asn1Acn::Types::UserdefinedType *t = dynamic_cast<const Asn1Acn::Types::UserdefinedType *>(type);
        return createAssignmentTemplateFromPromelaToC(t->typeName(), t->type());
    }

    default:
        QString message = QString("Not implemented %1").arg(type->typeEnum());
        throw TranslationException(std::move(message));
        // not implemented yet
        break;
    }
}

QString Asn1TypeHelper::createAssignmentTemplateFromCToPromela(
        const QString &cTypeName, const Asn1Acn::Types::Type *type)
{
    switch (type->typeEnum()) {
    case Asn1Acn::Types::Type::ASN1Type::INTEGER:
    case Asn1Acn::Types::Type::ASN1Type::REAL:
    case Asn1Acn::Types::Type::ASN1Type::BOOLEAN:
    case Asn1Acn::Types::Type::ASN1Type::ENUMERATED:
        // ordinary assignment
        return m_target + " = " + m_source + ";\n";

    case Asn1Acn::Types::Type::ASN1Type::SEQUENCE:
        return sequenceAssignmentFromCToPromela(cTypeName, dynamic_cast<const Asn1Acn::Types::Sequence *>(type));

    case Asn1Acn::Types::Type::ASN1Type::SEQUENCEOF:
        return sequenceOfAssignmentFromCToPromela(cTypeName, dynamic_cast<const Asn1Acn::Types::SequenceOf *>(type));

    case Asn1Acn::Types::Type::ASN1Type::CHOICE:
        return choiceAssignmentFromCToPromela(cTypeName, dynamic_cast<const Asn1Acn::Types::Choice *>(type));

    case Asn1Acn::Types::Type::ASN1Type::OCTETSTRING:
        return octetStringAssignmentFromCToPromela(dynamic_cast<const Asn1Acn::Types::OctetString *>(type));

    case Asn1Acn::Types::Type::ASN1Type::IA5STRING:
        return ia5StringAssignmentFromCToPromela(dynamic_cast<const Asn1Acn::Types::IA5String *>(type));

    case Asn1Acn::Types::Type::ASN1Type::USERDEFINED: {
        const Asn1Acn::Types::UserdefinedType *t = dynamic_cast<const Asn1Acn::Types::UserdefinedType *>(type);
        return createAssignmentTemplateFromCToPromela(t->typeName(), t->type());
    }

    default:
        QString message = QString("Not implemented %1").arg(type->typeEnum());
        throw TranslationException(std::move(message));
        // not implemented yet
        break;
    }
}

QList<VariableRef> Asn1TypeHelper::generateListOfFields(const Asn1Acn::Types::Type *type)
{
    switch (type->typeEnum()) {
    case Asn1Acn::Types::Type::ASN1Type::INTEGER:
    case Asn1Acn::Types::Type::ASN1Type::REAL:
    case Asn1Acn::Types::Type::ASN1Type::BOOLEAN:
    case Asn1Acn::Types::Type::ASN1Type::ENUMERATED:
        return QList<VariableRef>() << VariableRef(m_target);

    case Asn1Acn::Types::Type::ASN1Type::SEQUENCE:
        return sequenceListOfFields(dynamic_cast<const Asn1Acn::Types::Sequence *>(type));

    case Asn1Acn::Types::Type::ASN1Type::SEQUENCEOF:
        return sequenceOfListOfFields(dynamic_cast<const Asn1Acn::Types::SequenceOf *>(type));

    case Asn1Acn::Types::Type::ASN1Type::CHOICE:
        return choiceListOfFields(dynamic_cast<const Asn1Acn::Types::Choice *>(type));

    case Asn1Acn::Types::Type::ASN1Type::OCTETSTRING:
        return octetStringListOfFields(dynamic_cast<const Asn1Acn::Types::OctetString *>(type));

    case Asn1Acn::Types::Type::ASN1Type::IA5STRING:
        return ia5StringListOfFields(dynamic_cast<const Asn1Acn::Types::IA5String *>(type));

    case Asn1Acn::Types::Type::ASN1Type::USERDEFINED: {
        const Asn1Acn::Types::UserdefinedType *t = dynamic_cast<const Asn1Acn::Types::UserdefinedType *>(type);
        return generateListOfFields(t->type());
    }

    default:
        QString message = QString("Not implemented %1").arg(type->typeEnum());
        throw TranslationException(std::move(message));
        // not implemented yet
        break;
    }
}

const Asn1Acn::TypeAssignment *Asn1TypeHelper::findType(const QString &name)
{
    for (const std::unique_ptr<Asn1Acn::File> &file : m_asn1Model->data()) {
        const Asn1Acn::File::DefinitionsList &definitionList = file->definitionsList();
        for (const std::unique_ptr<Asn1Acn::Definitions> &definitions : definitionList) {
            const Asn1Acn::TypeAssignment *assignment = definitions->type(name);
            if (assignment != nullptr) {
                return assignment;
            }
        }
    }
    return nullptr;
}

QString Asn1TypeHelper::sequenceAssignmentFromPromelaToC(const QString &cTypeName, const Asn1Acn::Types::Sequence *type)
{
    QString result;
    QList<QString> optionalFields;
    for (const std::unique_ptr<Asn1Acn::SequenceComponent> &component : type->components()) {
        SequenceComponentVisitor visitor(
                SequenceComponentVisitor::Operation::FROM_PROMELA_TO_C, m_asn1Model, m_target, m_source, cTypeName);
        component->accept(visitor);
        if (visitor.hasComponent()) {
            result.append(visitor.getContent());
            if (visitor.isOptional()) {
                optionalFields.append(visitor.getComponentName());
            }
        }
    }
    for (const QString &field : optionalFields) {
        result.append(QString("%1.exist.%3 = %2.exist.%3;\n").arg(m_target, m_source, field));
    }

    return result;
}

QString Asn1TypeHelper::sequenceOfAssignmentFromPromelaToC(
        const QString &cTypeName, const Asn1Acn::Types::SequenceOf *type)
{
    SizeConstraintVisitor<IntegerValue> constraintVisitor;
    type->constraints().accept(constraintVisitor);

    QString elementType = PromelaNameHelper::createChildTypeNameForCCode(
            cTypeName, PromelaConstants::sequenceOfElementTypeNameSuffix);
    Asn1TypeHelper helper(m_asn1Model, m_target + ".arr[i]", m_source + ".data[i]");
    QString itemAssignment = addIndent(helper.createAssignmentTemplateFromPromelaToC(elementType, type->itemsType()));

    // generate a for loop to copy values of all elements of array
    // use the itemAssignment, which is a code generated for element type
    QString result = QString("int i = 0;\n"
                             "for(i = 0; i < %1; ++i)\n"
                             "{\n"
                             "%2"
                             "}\n")
                             .arg(constraintVisitor.getMaxSize())
                             .arg(itemAssignment);

    if (constraintVisitor.getMinSize() != constraintVisitor.getMaxSize()) {
        result.append(QString("%1.nCount = %2.length;\n").arg(m_target, m_source));
    }

    return result;
}

QString Asn1TypeHelper::choiceAssignmentFromPromelaToC(const QString &cTypeName, const Asn1Acn::Types::Choice *type)
{
    QString result;
    int32_t index = 1;

    // generate an if..else to detect current alternative
    // inject code how to convert the type of alternative
    for (const std::unique_ptr<Asn1Acn::Types::ChoiceAlternative> &component : type->components()) {
        QString componentName = Escaper::escapeCName(component->name());
        QString elementType = PromelaNameHelper::createChildTypeNameForCCode(cTypeName, componentName);
        Asn1TypeHelper helper(m_asn1Model, m_target + ".u." + componentName, m_source + ".data." + componentName);
        QString assignment = addIndent(helper.createAssignmentTemplateFromPromelaToC(elementType, component->type()));
        QString prefix = index == 1 ? "" : "else ";
        result += QString("%1if(%3.selection == %4_%5_PRESENT)\n"
                          "{\n"
                          "%6"
                          "    %2.kind = %4_%5_PRESENT;\n"
                          "}\n")
                          .arg(prefix, m_target, m_source, cTypeName, componentName, assignment);
        ++index;
    }

    return result;
}

QString Asn1TypeHelper::octetStringAssignmentFromPromelaToC(const Asn1Acn::Types::OctetString *type)
{
    SizeConstraintVisitor<OctetStringValue> constraintVisitor;
    type->constraints().accept(constraintVisitor);

    QString result = QString("int i = 0;\n"
                             "for(i = 0; i < %1; ++i)\n"
                             "{\n"
                             "%2.arr[i] = %3.data[i];\n"
                             "}\n")
                             .arg(constraintVisitor.getMaxSize())
                             .arg(m_target)
                             .arg(m_source);

    if (constraintVisitor.getMinSize() != constraintVisitor.getMaxSize()) {
        result.append(QString("%1.nCount = %2.length;\n").arg(m_target, m_source));
    }

    return result;
}

QString Asn1TypeHelper::ia5StringAssignmentFromPromelaToC(const Asn1Acn::Types::IA5String *type)
{
    SizeConstraintVisitor<StringValue> constraintVisitor;
    type->constraints().accept(constraintVisitor);

    QString result = QString("int i = 0;\n"
                             "for(i = 0; i < %1; ++i)\n"
                             "{\n"
                             "%2[i] = %3.data[i];\n"
                             "}\n")
                             .arg(constraintVisitor.getMaxSize())
                             .arg(m_target)
                             .arg(m_source);

    if (constraintVisitor.getMinSize() == constraintVisitor.getMaxSize()) {
        result.append(QString("%1[%2] = '\\0';\n").arg(m_target).arg(constraintVisitor.getMaxSize()));
    } else {
        result.append(QString("%1[%2.length] = '\\0';\n").arg(m_target, m_source));
    }

    return result;
}

QString Asn1TypeHelper::sequenceAssignmentFromCToPromela(const QString &typeName, const Asn1Acn::Types::Sequence *type)
{
    QString result;
    QList<QString> optionalFields;
    for (const std::unique_ptr<Asn1Acn::SequenceComponent> &component : type->components()) {
        SequenceComponentVisitor visitor(
                SequenceComponentVisitor::Operation::FROM_C_TO_PROMELA, m_asn1Model, m_target, m_source, typeName);
        component->accept(visitor);
        if (visitor.hasComponent()) {
            result.append(visitor.getContent());
            if (visitor.isOptional()) {
                optionalFields.append(visitor.getComponentName());
            }
        }
    }
    for (const QString &field : optionalFields) {
        result.append(QString("%1.exist.%3 = %2.exist.%3;\n").arg(m_target, m_source, field));
    }

    return result;
}

QString Asn1TypeHelper::sequenceOfAssignmentFromCToPromela(
        const QString &typeName, const Asn1Acn::Types::SequenceOf *type)
{
    SizeConstraintVisitor<IntegerValue> constraintVisitor;
    type->constraints().accept(constraintVisitor);

    QString elementType =
            PromelaNameHelper::createChildTypeNameForCCode(typeName, PromelaConstants::sequenceOfElementTypeNameSuffix);

    Asn1TypeHelper helper(m_asn1Model, m_target + ".data[i]", m_source + ".arr[i]");
    QString itemAssignment = addIndent(helper.createAssignmentTemplateFromCToPromela(elementType, type->itemsType()));

    // generate a for loop to copy values of all elements of array
    // use the itemAssignment, which is a code generated for element type
    QString result = QString("int i = 0;\n"
                             "for(i = 0; i < %1; ++i)\n"
                             "{\n"
                             "%2"
                             "}\n")
                             .arg(constraintVisitor.getMaxSize())
                             .arg(itemAssignment);

    if (constraintVisitor.getMinSize() != constraintVisitor.getMaxSize()) {
        result.append(QString("%1.length = %2.nCount;\n").arg(m_target, m_source));
    }

    return result;
}

QString Asn1TypeHelper::choiceAssignmentFromCToPromela(const QString &cTypeName, const Asn1Acn::Types::Choice *type)
{
    QString result;
    int32_t index = 1;

    // generate an if..else to detect current alternative
    // inject code how to convert the type of alternative
    for (const std::unique_ptr<Asn1Acn::Types::ChoiceAlternative> &component : type->components()) {
        QString componentName = Escaper::escapeCName(component->name());
        QString elementType = PromelaNameHelper::createChildTypeNameForCCode(cTypeName, componentName);
        Asn1TypeHelper helper(m_asn1Model, m_target + ".data." + componentName, m_source + ".u." + componentName);
        QString assignment = addIndent(helper.createAssignmentTemplateFromCToPromela(elementType, component->type()));
        QString prefix = index == 1 ? "" : " else ";
        result += QString("%1if(%3.kind == %4_%5_PRESENT)\n"
                          "{\n"
                          "%6"
                          "    %2.selection = %4_%5_PRESENT;\n"
                          "}\n")
                          .arg(prefix, m_target, m_source, cTypeName, componentName, assignment);
        ++index;
    }

    return result;
}

QString Asn1TypeHelper::octetStringAssignmentFromCToPromela(const Asn1Acn::Types::OctetString *type)
{
    SizeConstraintVisitor<OctetStringValue> constraintVisitor;
    type->constraints().accept(constraintVisitor);
    QString result = QString("int i = 0;\n"
                             "for(i = 0; i < %1; ++i)\n"
                             "{\n"
                             "%2.data[i] = %3.arr[i];\n"
                             "}\n")
                             .arg(constraintVisitor.getMaxSize())
                             .arg(m_target)
                             .arg(m_source);

    if (constraintVisitor.getMinSize() != constraintVisitor.getMaxSize()) {
        result.append(QString("%1.length = %2.nCount;\n").arg(m_target, m_source));
    }

    return result;
}

QString Asn1TypeHelper::ia5StringAssignmentFromCToPromela(const Asn1Acn::Types::IA5String *type)
{
    SizeConstraintVisitor<StringValue> constraintVisitor;
    type->constraints().accept(constraintVisitor);

    QString result = QString("int i = 0;\n"
                             "for(i = 0; i < %1; ++i)\n"
                             "{\n"
                             "%2.data[i] = %3[i];\n"
                             "}\n")
                             .arg(constraintVisitor.getMaxSize())
                             .arg(m_target)
                             .arg(m_source);

    if (constraintVisitor.getMinSize() != constraintVisitor.getMaxSize()) {
        result.append(QString("%1.length = strlen(%2);\n").arg(m_target, m_source));
    }

    return result;
}

QList<VariableRef> Asn1TypeHelper::sequenceListOfFields(const Asn1Acn::Types::Sequence *type)
{
    QList<VariableRef> result;
    QList<QString> optionalFields;
    for (const std::unique_ptr<Asn1Acn::SequenceComponent> &component : type->components()) {
        QString componentName = Escaper::escapePromelaName(component->name());
        SequenceComponentVisitor visitor(
                SequenceComponentVisitor::Operation::LIST_PROMELA_FIELDS, m_asn1Model, componentName, "", "");
        component->accept(visitor);
        if (visitor.hasComponent()) {
            QList<VariableRef> fieldsOfElement = visitor.takeListOfFields();

            while (!fieldsOfElement.empty()) {
                VariableRef field = fieldsOfElement.takeFirst();
                field.prependElement(m_target);
                result.append(std::move(field));
            }

            if (visitor.isOptional()) {
                optionalFields.append(visitor.getComponentName());
            }
        }
    }

    for (const QString &field : optionalFields) {
        VariableRef fieldRef = VariableRef(m_target);
        fieldRef.appendElement("exist");
        fieldRef.appendElement(field);
        result.append(std::move(fieldRef));
    }

    return result;
}

QList<VariableRef> Asn1TypeHelper::sequenceOfListOfFields(const Asn1Acn::Types::SequenceOf *type)
{
    SizeConstraintVisitor<IntegerValue> constraintVisitor;
    type->constraints().accept(constraintVisitor);

    Asn1TypeHelper helper(m_asn1Model, "data", "");
    QList<VariableRef> fieldsOfItem = helper.generateListOfFields(type->itemsType());

    QList<VariableRef> result;
    size_t itemCount = constraintVisitor.getMaxSize();

    if (constraintVisitor.getMinSize() != constraintVisitor.getMaxSize()) {
        VariableRef ref(m_target);
        ref.appendElement("length");
        result.append(std::move(ref));
    }

    for (size_t index = 0; index < itemCount; ++index) {
        for (const VariableRef &field : fieldsOfItem) {
            VariableRef ref = field;
            ref.addIndexExpression(std::make_unique<Expression>(Constant(index)));
            ref.prependElement(m_target);
            result.append(std::move(ref));
        }
    }

    return result;
}

QList<VariableRef> Asn1TypeHelper::choiceListOfFields(const Asn1Acn::Types::Choice *type)
{
    QList<VariableRef> result;
    for (const std::unique_ptr<Asn1Acn::Types::ChoiceAlternative> &component : type->components()) {
        QString componentName = Escaper::escapePromelaName(component->name());
        Asn1TypeHelper helper(m_asn1Model, componentName, "");
        QList<VariableRef> fieldsOfElement = helper.generateListOfFields(component->type());

        while (!fieldsOfElement.empty()) {
            VariableRef ref = fieldsOfElement.takeFirst();
            ref.prependElement("data");
            ref.prependElement(m_target);
            result.append(std::move(ref));
        }
    }

    VariableRef selectionRef(m_target);
    selectionRef.appendElement("selection");
    result.append(std::move(selectionRef));

    return result;
}

QList<promela::model::VariableRef> Asn1TypeHelper::octetStringListOfFields(const Asn1Acn::Types::OctetString *type)
{
    SizeConstraintVisitor<OctetStringValue> constraintVisitor;
    type->constraints().accept(constraintVisitor);

    QList<VariableRef> result;

    size_t itemCount = constraintVisitor.getMaxSize();

    if (constraintVisitor.getMinSize() != constraintVisitor.getMaxSize()) {
        VariableRef ref(m_target);
        ref.appendElement("length");
        result.append(std::move(ref));
    }

    for (size_t index = 0; index < itemCount; ++index) {
        VariableRef ref = VariableRef(m_target);
        ref.appendElement("data", std::make_unique<Expression>(Constant(index)));
        result.append(std::move(ref));
    }

    return result;
}

QList<promela::model::VariableRef> Asn1TypeHelper::ia5StringListOfFields(const Asn1Acn::Types::IA5String *type)
{
    SizeConstraintVisitor<StringValue> constraintVisitor;
    type->constraints().accept(constraintVisitor);

    QList<VariableRef> result;

    size_t itemCount = constraintVisitor.getMaxSize();

    if (constraintVisitor.getMinSize() != constraintVisitor.getMaxSize()) {
        VariableRef ref(m_target);
        ref.appendElement("length");
        result.append(std::move(ref));
    }

    for (size_t index = 0; index < itemCount; ++index) {
        VariableRef ref = VariableRef(m_target);
        ref.appendElement("data", std::make_unique<Expression>(Constant(index)));
        result.append(std::move(ref));
    }

    return result;
}

QString Asn1TypeHelper::addIndent(const QString &text)
{
    QStringList lines = text.split('\n');
    QStringList indentedLines;
    std::transform(lines.begin(), lines.end(), std::back_inserter(indentedLines),
            [](const QString &l) { return PromelaConstants::baseIndent + l + "\n"; });

    return std::accumulate(indentedLines.begin(), indentedLines.end(), QString(""));
}
}
