/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>

#include "asn1crt_encoding.h"
#include "asn1crt_encoding_uper.h"
#include "asn1crt_encoding_acn.h"

#include "dataview-uniq.h"




flag asn1SccDummy_Equal(const asn1SccDummy* pVal1, const asn1SccDummy* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccDummy_IsConstraintValid(const asn1SccDummy* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 0UL);
    *pErrCode = ret ? 0 :  ERR_DUMMY; 

	return ret;
}

void asn1SccDummy_Initialize(asn1SccDummy* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccDummy_Encode(const asn1SccDummy* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccDummy_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /* No need to encode value since it will always be 0 */
	    (void)pBitStrm;
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccDummy_Decode(asn1SccDummy* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;
	(void)pVal;
	(void)pBitStrm;


	(*(pVal))=0; 
	(void)pBitStrm;
	ret = TRUE; 
	*pErrCode = 0;

	return ret  && asn1SccDummy_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccDummy_ACN_Encode(const asn1SccDummy* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccDummy_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /* No need to encode value since it will always be 0 */
	    (void)pBitStrm;
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccDummy_ACN_Decode(asn1SccDummy* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
	(void)pBitStrm;
	*pErrCode = 0;


	(*(pVal))=0; 
	(void)pBitStrm;
	ret = TRUE; 
	*pErrCode = 0;

    return ret && asn1SccDummy_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccDataItem_Equal(const asn1SccDataItem* pVal1, const asn1SccDataItem* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccDataItem_IsConstraintValid(const asn1SccDataItem* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_DATAITEM; 

	return ret;
}

void asn1SccDataItem_Initialize(asn1SccDataItem* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccDataItem_Encode(const asn1SccDataItem* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccDataItem_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccDataItem_Decode(asn1SccDataItem* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_DATAITEM;

	return ret  && asn1SccDataItem_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccDataItem_ACN_Encode(const asn1SccDataItem* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccDataItem_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccDataItem_ACN_Decode(asn1SccDataItem* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_DATAITEM;

    return ret && asn1SccDataItem_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccActuatorConfiguration_Equal(const asn1SccActuatorConfiguration* pVal1, const asn1SccActuatorConfiguration* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->threshold1 == pVal2->threshold1);

    if (ret) {
        ret = (pVal1->threshold2 == pVal2->threshold2);

    }

	return ret;

}

flag asn1SccActuatorConfiguration_IsConstraintValid(const asn1SccActuatorConfiguration* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccDataItem_IsConstraintValid((&(pVal->threshold1)), pErrCode);
    if (ret) {
        ret = asn1SccDataItem_IsConstraintValid((&(pVal->threshold2)), pErrCode);
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void asn1SccActuatorConfiguration_Initialize(asn1SccActuatorConfiguration* pVal)
{
	(void)pVal;



	/*set threshold1 */
	asn1SccDataItem_Initialize((&(pVal->threshold1)));
	/*set threshold2 */
	asn1SccDataItem_Initialize((&(pVal->threshold2)));
}

flag asn1SccActuatorConfiguration_Encode(const asn1SccActuatorConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccActuatorConfiguration_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode threshold1 */
	    ret = asn1SccDataItem_Encode((&(pVal->threshold1)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode threshold2 */
	        ret = asn1SccDataItem_Encode((&(pVal->threshold2)), pBitStrm, pErrCode, FALSE);
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccActuatorConfiguration_Decode(asn1SccActuatorConfiguration* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode threshold1 */
	ret = asn1SccDataItem_Decode((&(pVal->threshold1)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode threshold2 */
	    ret = asn1SccDataItem_Decode((&(pVal->threshold2)), pBitStrm, pErrCode);
	}   /*COVERAGE_IGNORE*/

	return ret  && asn1SccActuatorConfiguration_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccActuatorConfiguration_ACN_Encode(const asn1SccActuatorConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccActuatorConfiguration_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode threshold1 */
	    ret = asn1SccDataItem_ACN_Encode((&(pVal->threshold1)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode threshold2 */
	        ret = asn1SccDataItem_ACN_Encode((&(pVal->threshold2)), pBitStrm, pErrCode, FALSE);
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccActuatorConfiguration_ACN_Decode(asn1SccActuatorConfiguration* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode threshold1 */
	ret = asn1SccDataItem_ACN_Decode((&(pVal->threshold1)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode threshold2 */
	    ret = asn1SccDataItem_ACN_Decode((&(pVal->threshold2)), pBitStrm, pErrCode);
	}   /*COVERAGE_IGNORE*/

    return ret && asn1SccActuatorConfiguration_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccSystemCommand_Equal(const asn1SccSystemCommand* pVal1, const asn1SccSystemCommand* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->kind == pVal2->kind);
    if (ret) {
    	switch(pVal1->kind) 
    	{
    	case SystemCommand_goToIdle_PRESENT:
    		ret = (pVal1->u.goToIdle == pVal2->u.goToIdle);
    		break;
    	case SystemCommand_goToOperational_PRESENT:
    		ret = asn1SccActuatorConfiguration_Equal((&(pVal1->u.goToOperational)), (&(pVal2->u.goToOperational)));
    		break;
    	case SystemCommand_doReport_PRESENT:
    		ret = (pVal1->u.doReport == pVal2->u.doReport);
    		break;
    	default: /*COVERAGE_IGNORE*/
    		ret = FALSE;    /*COVERAGE_IGNORE*/
    	}
    } /*COVERAGE_IGNORE*/
	return ret;

}

flag asn1SccSystemCommand_IsConstraintValid(const asn1SccSystemCommand* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->kind == SystemCommand_goToIdle_PRESENT) {
    	ret = asn1SccDummy_IsConstraintValid((&(pVal->u.goToIdle)), pErrCode);
    }
    if (ret) {
        if (pVal->kind == SystemCommand_goToOperational_PRESENT) {
        	ret = asn1SccActuatorConfiguration_IsConstraintValid((&(pVal->u.goToOperational)), pErrCode);
        }
        if (ret) {
            if (pVal->kind == SystemCommand_doReport_PRESENT) {
            	ret = asn1SccDummy_IsConstraintValid((&(pVal->u.doReport)), pErrCode);
            }
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void asn1SccSystemCommand_Initialize(asn1SccSystemCommand* pVal)
{
	(void)pVal;


	/*set goToIdle*/
	pVal->kind = SystemCommand_goToIdle_PRESENT;
	pVal->u.goToIdle = 0;
}

flag asn1SccSystemCommand_Encode(const asn1SccSystemCommand* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccSystemCommand_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch(pVal->kind) 
	    {
	    case SystemCommand_goToIdle_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	    	ret = asn1SccDummy_Encode((&(pVal->u.goToIdle)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case SystemCommand_goToOperational_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	    	ret = asn1SccActuatorConfiguration_Encode((&(pVal->u.goToOperational)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case SystemCommand_doReport_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	    	ret = asn1SccDummy_Encode((&(pVal->u.doReport)), pBitStrm, pErrCode, FALSE);
	    	break;
	    default:                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_ENCODE_SYSTEMCOMMAND;         /*COVERAGE_IGNORE*/
	        ret = FALSE;                    /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccSystemCommand_Decode(asn1SccSystemCommand* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint asn1SccSystemCommand_index_tmp;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &asn1SccSystemCommand_index_tmp, 0, 2);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_SYSTEMCOMMAND;
	if (ret) {
	    switch(asn1SccSystemCommand_index_tmp) 
	    {
	    case 0:
	    	pVal->kind = SystemCommand_goToIdle_PRESENT;
	    	ret = asn1SccDummy_Decode((&(pVal->u.goToIdle)), pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = SystemCommand_goToOperational_PRESENT;
	    	ret = asn1SccActuatorConfiguration_Decode((&(pVal->u.goToOperational)), pBitStrm, pErrCode);
	    	break;
	    case 2:
	    	pVal->kind = SystemCommand_doReport_PRESENT;
	    	ret = asn1SccDummy_Decode((&(pVal->u.doReport)), pBitStrm, pErrCode);
	    	break;
	    default:                        /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_DECODE_SYSTEMCOMMAND;     /*COVERAGE_IGNORE*/
	        ret = FALSE;                /*COVERAGE_IGNORE*/
	    }
	}  /*COVERAGE_IGNORE*/

	return ret  && asn1SccSystemCommand_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccSystemCommand_ACN_Encode(const asn1SccSystemCommand* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccSystemCommand_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch(pVal->kind) 
	    {
	    case SystemCommand_goToIdle_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	    	ret = asn1SccDummy_ACN_Encode((&(pVal->u.goToIdle)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case SystemCommand_goToOperational_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	    	ret = asn1SccActuatorConfiguration_ACN_Encode((&(pVal->u.goToOperational)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case SystemCommand_doReport_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	    	ret = asn1SccDummy_ACN_Encode((&(pVal->u.doReport)), pBitStrm, pErrCode, FALSE);
	    	break;
	    default: /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_ENCODE_SYSTEMCOMMAND;         /*COVERAGE_IGNORE*/
	        ret = FALSE;                    /*COVERAGE_IGNORE*/
	    } /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccSystemCommand_ACN_Decode(asn1SccSystemCommand* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint CDRDEMO_DATAVIEW_SystemCommand_index_tmp;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &CDRDEMO_DATAVIEW_SystemCommand_index_tmp, 0, 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_SYSTEMCOMMAND;
	if (ret) {
	    switch(CDRDEMO_DATAVIEW_SystemCommand_index_tmp) 
	    {
	    case 0:
	    	pVal->kind = SystemCommand_goToIdle_PRESENT;
	    	ret = asn1SccDummy_ACN_Decode((&(pVal->u.goToIdle)), pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = SystemCommand_goToOperational_PRESENT;
	    	ret = asn1SccActuatorConfiguration_ACN_Decode((&(pVal->u.goToOperational)), pBitStrm, pErrCode);
	    	break;
	    case 2:
	    	pVal->kind = SystemCommand_doReport_PRESENT;
	    	ret = asn1SccDummy_ACN_Decode((&(pVal->u.doReport)), pBitStrm, pErrCode);
	    	break;
	    default: /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_SYSTEMCOMMAND;     /*COVERAGE_IGNORE*/
	        ret = FALSE;                /*COVERAGE_IGNORE*/
	    } 
	} /*COVERAGE_IGNORE*/

    return ret && asn1SccSystemCommand_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccActuatorIndex_Equal(const asn1SccActuatorIndex* pVal1, const asn1SccActuatorIndex* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccActuatorIndex_IsConstraintValid(const asn1SccActuatorIndex* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == ActuatorIndex_actuator1)) || (((*(pVal)) == ActuatorIndex_actuator2)));
    *pErrCode = ret ? 0 :  ERR_ACTUATORINDEX; 

	return ret;
}

void asn1SccActuatorIndex_Initialize(asn1SccActuatorIndex* pVal)
{
	(void)pVal;


	(*(pVal)) = ActuatorIndex_actuator1;
}

flag asn1SccActuatorIndex_Encode(const asn1SccActuatorIndex* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccActuatorIndex_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case ActuatorIndex_actuator1:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case ActuatorIndex_actuator2:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_ACTUATORINDEX; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccActuatorIndex_Decode(asn1SccActuatorIndex* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_ACTUATORINDEX;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = ActuatorIndex_actuator1;
	                break;
	            case 1: 
	                (*(pVal)) = ActuatorIndex_actuator2;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_ACTUATORINDEX;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = ActuatorIndex_actuator1;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccActuatorIndex_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccActuatorIndex_ACN_Encode(const asn1SccActuatorIndex* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccActuatorIndex_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case ActuatorIndex_actuator1:
	            intVal = 0;
	            break;
	        case ActuatorIndex_actuator2:
	            intVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_ACTUATORINDEX;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccActuatorIndex_ACN_Decode(asn1SccActuatorIndex* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_ACTUATORINDEX;
	if (ret) {
	    switch (intVal) {
	        case 0:
	            (*(pVal)) = ActuatorIndex_actuator1;
	            break;
	        case 1:
	            (*(pVal)) = ActuatorIndex_actuator2;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_ACTUATORINDEX;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && asn1SccActuatorIndex_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccActuatorCommand_Equal(const asn1SccActuatorCommand* pVal1, const asn1SccActuatorCommand* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccActuatorCommand_IsConstraintValid(const asn1SccActuatorCommand* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((*(pVal)) == ActuatorCommand_actuatorArm)) || (((*(pVal)) == ActuatorCommand_actuatorExecute)))) || (((*(pVal)) == ActuatorCommand_actuatorStandby)));
    *pErrCode = ret ? 0 :  ERR_ACTUATORCOMMAND; 

	return ret;
}

void asn1SccActuatorCommand_Initialize(asn1SccActuatorCommand* pVal)
{
	(void)pVal;


	(*(pVal)) = ActuatorCommand_actuatorArm;
}

flag asn1SccActuatorCommand_Encode(const asn1SccActuatorCommand* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccActuatorCommand_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case ActuatorCommand_actuatorArm:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case ActuatorCommand_actuatorExecute:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case ActuatorCommand_actuatorStandby:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_ACTUATORCOMMAND; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccActuatorCommand_Decode(asn1SccActuatorCommand* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_ACTUATORCOMMAND;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = ActuatorCommand_actuatorArm;
	                break;
	            case 1: 
	                (*(pVal)) = ActuatorCommand_actuatorExecute;
	                break;
	            case 2: 
	                (*(pVal)) = ActuatorCommand_actuatorStandby;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_ACTUATORCOMMAND;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = ActuatorCommand_actuatorArm;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccActuatorCommand_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccActuatorCommand_ACN_Encode(const asn1SccActuatorCommand* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccActuatorCommand_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case ActuatorCommand_actuatorArm:
	            intVal = 0;
	            break;
	        case ActuatorCommand_actuatorExecute:
	            intVal = 1;
	            break;
	        case ActuatorCommand_actuatorStandby:
	            intVal = 2;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_ACTUATORCOMMAND;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 2);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccActuatorCommand_ACN_Decode(asn1SccActuatorCommand* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_ACTUATORCOMMAND;
	if (ret) {
	    switch (intVal) {
	        case 0:
	            (*(pVal)) = ActuatorCommand_actuatorArm;
	            break;
	        case 1:
	            (*(pVal)) = ActuatorCommand_actuatorExecute;
	            break;
	        case 2:
	            (*(pVal)) = ActuatorCommand_actuatorStandby;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_ACTUATORCOMMAND;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && asn1SccActuatorCommand_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccActuatorStatus_Equal(const asn1SccActuatorStatus* pVal1, const asn1SccActuatorStatus* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccActuatorStatus_IsConstraintValid(const asn1SccActuatorStatus* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((*(pVal)) == ActuatorStatus_actuatorArmed)) || (((*(pVal)) == ActuatorStatus_actuatorExecuting)))) || (((*(pVal)) == ActuatorStatus_actuatorStandingBy)));
    *pErrCode = ret ? 0 :  ERR_ACTUATORSTATUS; 

	return ret;
}

void asn1SccActuatorStatus_Initialize(asn1SccActuatorStatus* pVal)
{
	(void)pVal;


	(*(pVal)) = ActuatorStatus_actuatorArmed;
}

flag asn1SccActuatorStatus_Encode(const asn1SccActuatorStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccActuatorStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case ActuatorStatus_actuatorArmed:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case ActuatorStatus_actuatorExecuting:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case ActuatorStatus_actuatorStandingBy:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_ACTUATORSTATUS; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccActuatorStatus_Decode(asn1SccActuatorStatus* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_ACTUATORSTATUS;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = ActuatorStatus_actuatorArmed;
	                break;
	            case 1: 
	                (*(pVal)) = ActuatorStatus_actuatorExecuting;
	                break;
	            case 2: 
	                (*(pVal)) = ActuatorStatus_actuatorStandingBy;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_ACTUATORSTATUS;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = ActuatorStatus_actuatorArmed;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccActuatorStatus_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccActuatorStatus_ACN_Encode(const asn1SccActuatorStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccActuatorStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case ActuatorStatus_actuatorArmed:
	            intVal = 0;
	            break;
	        case ActuatorStatus_actuatorExecuting:
	            intVal = 1;
	            break;
	        case ActuatorStatus_actuatorStandingBy:
	            intVal = 2;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_ACTUATORSTATUS;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 2);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccActuatorStatus_ACN_Decode(asn1SccActuatorStatus* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_ACTUATORSTATUS;
	if (ret) {
	    switch (intVal) {
	        case 0:
	            (*(pVal)) = ActuatorStatus_actuatorArmed;
	            break;
	        case 1:
	            (*(pVal)) = ActuatorStatus_actuatorExecuting;
	            break;
	        case 2:
	            (*(pVal)) = ActuatorStatus_actuatorStandingBy;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_ACTUATORSTATUS;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && asn1SccActuatorStatus_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccSystemTelemetry_Equal(const asn1SccSystemTelemetry* pVal1, const asn1SccSystemTelemetry* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->reading == pVal2->reading);

    if (ret) {
        ret = (pVal1->status1 == pVal2->status1);

        if (ret) {
            ret = (pVal1->status2 == pVal2->status2);

        }

    }

	return ret;

}

flag asn1SccSystemTelemetry_IsConstraintValid(const asn1SccSystemTelemetry* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccDataItem_IsConstraintValid((&(pVal->reading)), pErrCode);
    if (ret) {
        ret = asn1SccActuatorStatus_IsConstraintValid((&(pVal->status1)), pErrCode);
        if (ret) {
            ret = asn1SccActuatorStatus_IsConstraintValid((&(pVal->status2)), pErrCode);
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void asn1SccSystemTelemetry_Initialize(asn1SccSystemTelemetry* pVal)
{
	(void)pVal;



	/*set reading */
	asn1SccDataItem_Initialize((&(pVal->reading)));
	/*set status1 */
	asn1SccActuatorStatus_Initialize((&(pVal->status1)));
	/*set status2 */
	asn1SccActuatorStatus_Initialize((&(pVal->status2)));
}

flag asn1SccSystemTelemetry_Encode(const asn1SccSystemTelemetry* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccSystemTelemetry_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode reading */
	    ret = asn1SccDataItem_Encode((&(pVal->reading)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode status1 */
	        ret = asn1SccActuatorStatus_Encode((&(pVal->status1)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode status2 */
	            ret = asn1SccActuatorStatus_Encode((&(pVal->status2)), pBitStrm, pErrCode, FALSE);
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccSystemTelemetry_Decode(asn1SccSystemTelemetry* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode reading */
	ret = asn1SccDataItem_Decode((&(pVal->reading)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode status1 */
	    ret = asn1SccActuatorStatus_Decode((&(pVal->status1)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode status2 */
	        ret = asn1SccActuatorStatus_Decode((&(pVal->status2)), pBitStrm, pErrCode);
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

	return ret  && asn1SccSystemTelemetry_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccSystemTelemetry_ACN_Encode(const asn1SccSystemTelemetry* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccSystemTelemetry_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode reading */
	    ret = asn1SccDataItem_ACN_Encode((&(pVal->reading)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode status1 */
	        ret = asn1SccActuatorStatus_ACN_Encode((&(pVal->status1)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode status2 */
	            ret = asn1SccActuatorStatus_ACN_Encode((&(pVal->status2)), pBitStrm, pErrCode, FALSE);
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccSystemTelemetry_ACN_Decode(asn1SccSystemTelemetry* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode reading */
	ret = asn1SccDataItem_ACN_Decode((&(pVal->reading)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode status1 */
	    ret = asn1SccActuatorStatus_ACN_Decode((&(pVal->status1)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode status2 */
	        ret = asn1SccActuatorStatus_ACN_Decode((&(pVal->status2)), pBitStrm, pErrCode);
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

    return ret && asn1SccSystemTelemetry_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Int32_Equal(const asn1SccT_Int32* pVal1, const asn1SccT_Int32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccT_Int32_IsConstraintValid(const asn1SccT_Int32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-2147483648L <= (*(pVal))) && ((*(pVal)) <= 2147483647L));
    *pErrCode = ret ? 0 :  ERR_T_INT32; 

	return ret;
}

void asn1SccT_Int32_Initialize(asn1SccT_Int32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_Int32_Encode(const asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int32_Decode(asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT32;

	return ret  && asn1SccT_Int32_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Int32_ACN_Encode(const asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int32_ACN_Decode(asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT32;

    return ret && asn1SccT_Int32_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_UInt32_Equal(const asn1SccT_UInt32* pVal1, const asn1SccT_UInt32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccT_UInt32_IsConstraintValid(const asn1SccT_UInt32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT32; 

	return ret;
}

void asn1SccT_UInt32_Initialize(asn1SccT_UInt32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_UInt32_Encode(const asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt32_Decode(asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT32;

	return ret  && asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_UInt32_ACN_Encode(const asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt32_ACN_Decode(asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT32;

    return ret && asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Int8_Equal(const asn1SccT_Int8* pVal1, const asn1SccT_Int8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccT_Int8_IsConstraintValid(const asn1SccT_Int8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-128L <= (*(pVal))) && ((*(pVal)) <= 127L));
    *pErrCode = ret ? 0 :  ERR_T_INT8; 

	return ret;
}

void asn1SccT_Int8_Initialize(asn1SccT_Int8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_Int8_Encode(const asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int8_Decode(asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT8;

	return ret  && asn1SccT_Int8_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Int8_ACN_Encode(const asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int8_ACN_Decode(asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT8;

    return ret && asn1SccT_Int8_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_UInt8_Equal(const asn1SccT_UInt8* pVal1, const asn1SccT_UInt8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccT_UInt8_IsConstraintValid(const asn1SccT_UInt8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT8; 

	return ret;
}

void asn1SccT_UInt8_Initialize(asn1SccT_UInt8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_UInt8_Encode(const asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt8_Decode(asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT8;

	return ret  && asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_UInt8_ACN_Encode(const asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt8_ACN_Decode(asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT8;

    return ret && asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Boolean_Equal(const asn1SccT_Boolean* pVal1, const asn1SccT_Boolean* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccT_Boolean_IsConstraintValid(const asn1SccT_Boolean* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

void asn1SccT_Boolean_Initialize(asn1SccT_Boolean* pVal)
{
	(void)pVal;


	(*(pVal)) = FALSE;
}

flag asn1SccT_Boolean_Encode(const asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Boolean_Decode(asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_BOOLEAN;

	return ret  && asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Boolean_ACN_Encode(const asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Boolean_ACN_Decode(asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_BOOLEAN;

    return ret && asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Null_Record_Equal(const asn1SccT_Null_Record* pVal1, const asn1SccT_Null_Record* pVal2)
{
	(void)pVal1;
	(void)pVal2;
	return TRUE;

}

flag asn1SccT_Null_Record_IsConstraintValid(const asn1SccT_Null_Record* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

void asn1SccT_Null_Record_Initialize(asn1SccT_Null_Record* pVal)
{
	(void)pVal;


}

flag asn1SccT_Null_Record_Encode(const asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Null_Record_Decode(asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;
	(void)pBitStrm;



	return ret  && asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Null_Record_ACN_Encode(const asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Null_Record_ACN_Decode(asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	(void)pBitStrm;
	*pErrCode = 0;



    return ret && asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccPID_Range_Equal(const asn1SccPID_Range* pVal1, const asn1SccPID_Range* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPID_Range_IsConstraintValid(const asn1SccPID_Range* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 6UL);
    *pErrCode = ret ? 0 :  ERR_PID_RANGE; 

	return ret;
}

void asn1SccPID_Range_Initialize(asn1SccPID_Range* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccPID_Range_Encode(const asn1SccPID_Range* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccPID_Range_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 6);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPID_Range_Decode(asn1SccPID_Range* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 6);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_PID_RANGE;

	return ret  && asn1SccPID_Range_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccPID_Range_ACN_Encode(const asn1SccPID_Range* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccPID_Range_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 6);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPID_Range_ACN_Decode(asn1SccPID_Range* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 6);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PID_RANGE;

    return ret && asn1SccPID_Range_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccPID_Equal(const asn1SccPID* pVal1, const asn1SccPID* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPID_IsConstraintValid(const asn1SccPID* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((((*(pVal)) == PID_actuator)) || (((*(pVal)) == PID_actuator1)))) || (((*(pVal)) == PID_actuator2)))) || (((*(pVal)) == PID_egse)))) || (((*(pVal)) == PID_modemanager)))) || (((*(pVal)) == PID_sensor)))) || (((*(pVal)) == PID_env)));
    *pErrCode = ret ? 0 :  ERR_PID; 

	return ret;
}

void asn1SccPID_Initialize(asn1SccPID* pVal)
{
	(void)pVal;


	(*(pVal)) = PID_actuator;
}

flag asn1SccPID_Encode(const asn1SccPID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccPID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case PID_actuator:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 6);
	        	break;
	        case PID_actuator1:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 6);
	        	break;
	        case PID_actuator2:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 6);
	        	break;
	        case PID_egse:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 6);
	        	break;
	        case PID_modemanager:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 6);
	        	break;
	        case PID_sensor:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 6);
	        	break;
	        case PID_env:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 6);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_PID; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPID_Decode(asn1SccPID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 6);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_PID;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = PID_actuator;
	                break;
	            case 1: 
	                (*(pVal)) = PID_actuator1;
	                break;
	            case 2: 
	                (*(pVal)) = PID_actuator2;
	                break;
	            case 3: 
	                (*(pVal)) = PID_egse;
	                break;
	            case 4: 
	                (*(pVal)) = PID_modemanager;
	                break;
	            case 5: 
	                (*(pVal)) = PID_sensor;
	                break;
	            case 6: 
	                (*(pVal)) = PID_env;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_PID;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = PID_actuator;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccPID_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccPID_ACN_Encode(const asn1SccPID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccPID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case PID_actuator:
	            intVal = 0;
	            break;
	        case PID_actuator1:
	            intVal = 1;
	            break;
	        case PID_actuator2:
	            intVal = 2;
	            break;
	        case PID_egse:
	            intVal = 3;
	            break;
	        case PID_modemanager:
	            intVal = 4;
	            break;
	        case PID_sensor:
	            intVal = 5;
	            break;
	        case PID_env:
	            intVal = 6;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_PID;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 6);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPID_ACN_Decode(asn1SccPID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 6);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PID;
	if (ret) {
	    switch (intVal) {
	        case 0:
	            (*(pVal)) = PID_actuator;
	            break;
	        case 1:
	            (*(pVal)) = PID_actuator1;
	            break;
	        case 2:
	            (*(pVal)) = PID_actuator2;
	            break;
	        case 3:
	            (*(pVal)) = PID_egse;
	            break;
	        case 4:
	            (*(pVal)) = PID_modemanager;
	            break;
	        case 5:
	            (*(pVal)) = PID_sensor;
	            break;
	        case 6:
	            (*(pVal)) = PID_env;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_PID;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && asn1SccPID_IsConstraintValid(pVal, pErrCode);
}

