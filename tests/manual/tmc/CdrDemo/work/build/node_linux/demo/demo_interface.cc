/* File generated by kazoo for TASTE - do not edit */
#include "demo_interface.h"
#include <cstring>

#include <Request.h>
#include <Lock.h>
#include <Queue.h>

#include "transport.h"
#include "routing.h"

extern "C"
{

#include "actuator1_vm_if.h"

void call_actuator1_actuatortc (const char* buf, size_t len)
{
    actuator1_actuatorTc (buf, len);
}

static bool thread_actuator1_actuatortc_check_queue()
{
	extern taste::Queue<ACTUATOR1_ACTUATORTC_REQUEST_SIZE> actuator1_actuatorTc_Global_Queue;
	return !actuator1_actuatorTc_Global_Queue.is_empty();
}
#include "actuator2_vm_if.h"

void call_actuator2_actuatortc (const char* buf, size_t len)
{
    actuator2_actuatorTc (buf, len);
}

static bool thread_actuator2_actuatortc_check_queue()
{
	extern taste::Queue<ACTUATOR2_ACTUATORTC_REQUEST_SIZE> actuator2_actuatorTc_Global_Queue;
	return !actuator2_actuatorTc_Global_Queue.is_empty();
}
#include "egse_vm_if.h"

void call_egse_poll (const char* buf, size_t len)
{
    extern taste::Lock egse_Mutex;

    egse_Mutex.lock();

    egse_Poll();
	egse_Mutex.unlock();
}

static bool thread_egse_poll_check_queue()
{
	extern taste::Queue<EGSE_POLL_REQUEST_SIZE> egse_Poll_Global_Queue;
	return !egse_Poll_Global_Queue.is_empty();
}
#include "egse_vm_if.h"

void call_egse_systemtm (const char* buf, size_t len)
{
    extern taste::Lock egse_Mutex;

    egse_Mutex.lock();

    egse_systemTm (buf, len);
	egse_Mutex.unlock();
}

static bool thread_egse_systemtm_check_queue()
{
	extern taste::Queue<EGSE_SYSTEMTM_REQUEST_SIZE> egse_systemTm_Global_Queue;
	return !egse_systemTm_Global_Queue.is_empty();
}
#include "modemanager_vm_if.h"

void call_modemanager_actuatortm1 (const char* buf, size_t len)
{
    extern taste::Lock modemanager_Mutex;

    modemanager_Mutex.lock();

    modemanager_actuatorTm1 (buf, len);
	modemanager_Mutex.unlock();
}

static bool thread_modemanager_actuatortm1_check_queue()
{
	extern taste::Queue<MODEMANAGER_ACTUATORTM1_REQUEST_SIZE> modemanager_actuatorTm1_Global_Queue;
	return !modemanager_actuatorTm1_Global_Queue.is_empty();
}
#include "modemanager_vm_if.h"

void call_modemanager_actuatortm2 (const char* buf, size_t len)
{
    extern taste::Lock modemanager_Mutex;

    modemanager_Mutex.lock();

    modemanager_actuatorTm2 (buf, len);
	modemanager_Mutex.unlock();
}

static bool thread_modemanager_actuatortm2_check_queue()
{
	extern taste::Queue<MODEMANAGER_ACTUATORTM2_REQUEST_SIZE> modemanager_actuatorTm2_Global_Queue;
	return !modemanager_actuatorTm2_Global_Queue.is_empty();
}
#include "modemanager_vm_if.h"

void call_modemanager_reading (const char* buf, size_t len)
{
    extern taste::Lock modemanager_Mutex;

    modemanager_Mutex.lock();

    modemanager_reading (buf, len);
	modemanager_Mutex.unlock();
}

static bool thread_modemanager_reading_check_queue()
{
	extern taste::Queue<MODEMANAGER_READING_REQUEST_SIZE> modemanager_reading_Global_Queue;
	return !modemanager_reading_Global_Queue.is_empty();
}
#include "modemanager_vm_if.h"

void call_modemanager_systemtc (const char* buf, size_t len)
{
    extern taste::Lock modemanager_Mutex;

    modemanager_Mutex.lock();

    modemanager_systemTc (buf, len);
	modemanager_Mutex.unlock();
}

static bool thread_modemanager_systemtc_check_queue()
{
	extern taste::Queue<MODEMANAGER_SYSTEMTC_REQUEST_SIZE> modemanager_systemTc_Global_Queue;
	return !modemanager_systemTc_Global_Queue.is_empty();
}
#include "sensor_vm_if.h"

void call_sensor_trigger (const char* buf, size_t len)
{
    sensor_trigger();
}

static bool thread_sensor_trigger_check_queue()
{
	extern taste::Queue<SENSOR_TRIGGER_REQUEST_SIZE> sensor_trigger_Global_Queue;
	return !sensor_trigger_Global_Queue.is_empty();
}


// Required interfaces of function Actuator1

// Required interface actuatorTm in function Actuator1
void vm_actuator1_actuatortm
        (asn1SccPID dest_pid,
         const char *IN_buf_tm, size_t size_IN_buf_tm)

{
    if (PID_env == dest_pid || PID_modemanager == dest_pid)
        deliver_to_modemanager_actuatortm1(PID_actuator1, reinterpret_cast<const uint8_t*>(IN_buf_tm), size_IN_buf_tm);
}
#include "actuator1_vm_if.h"


void call_protected_Actuator1_actuatorTc
      (const char *IN_buf_tc, size_t size_IN_buf_tc)

{
    extern taste::Lock actuator1_Mutex;

    actuator1_Mutex.lock();

    actuator1_actuatorTc
      (IN_buf_tc, size_IN_buf_tc);


    actuator1_Mutex.unlock();
}

void actuator1_check_queue(bool* has_pending_msg)
{
    *has_pending_msg = false;
    if(thread_actuator1_actuatortc_check_queue())
    {
        *has_pending_msg = true;
        return;
    }
}
// Required interfaces of function Actuator2

// Required interface actuatorTm in function Actuator2
void vm_actuator2_actuatortm
        (asn1SccPID dest_pid,
         const char *IN_buf_tm, size_t size_IN_buf_tm)

{
    if (PID_env == dest_pid || PID_modemanager == dest_pid)
        deliver_to_modemanager_actuatortm2(PID_actuator2, reinterpret_cast<const uint8_t*>(IN_buf_tm), size_IN_buf_tm);
}
#include "actuator2_vm_if.h"


void call_protected_Actuator2_actuatorTc
      (const char *IN_buf_tc, size_t size_IN_buf_tc)

{
    extern taste::Lock actuator2_Mutex;

    actuator2_Mutex.lock();

    actuator2_actuatorTc
      (IN_buf_tc, size_IN_buf_tc);


    actuator2_Mutex.unlock();
}

void actuator2_check_queue(bool* has_pending_msg)
{
    *has_pending_msg = false;
    if(thread_actuator2_actuatortc_check_queue())
    {
        *has_pending_msg = true;
        return;
    }
}
// Required interfaces of function EGSE

// Required interface systemTc in function EGSE
void vm_egse_systemtc
        (asn1SccPID dest_pid,
         const char *IN_buf_tc, size_t size_IN_buf_tc)

{
    if (PID_env == dest_pid || PID_modemanager == dest_pid)
        deliver_to_modemanager_systemtc(PID_egse, reinterpret_cast<const uint8_t*>(IN_buf_tc), size_IN_buf_tc);
}
#include "egse_vm_if.h"


void call_protected_EGSE_Poll(void)
{
    extern taste::Lock egse_Mutex;

    egse_Mutex.lock();

    egse_Poll();

    egse_Mutex.unlock();
}
void call_protected_EGSE_systemTm
      (const char *IN_buf_tm, size_t size_IN_buf_tm)

{
    extern taste::Lock egse_Mutex;

    egse_Mutex.lock();

    egse_systemTm
      (IN_buf_tm, size_IN_buf_tm);


    egse_Mutex.unlock();
}

void egse_check_queue(bool* has_pending_msg)
{
    *has_pending_msg = false;
    if(thread_egse_poll_check_queue())
    {
        *has_pending_msg = true;
        return;
    }
    if(thread_egse_systemtm_check_queue())
    {
        *has_pending_msg = true;
        return;
    }
}
// Required interfaces of function ModeManager

// Required interface actuatorTc1 in function ModeManager
void vm_modemanager_actuatortc1
        (asn1SccPID dest_pid,
         const char *IN_buf_tc, size_t size_IN_buf_tc)

{
    if (PID_env == dest_pid || PID_actuator1 == dest_pid)
        deliver_to_actuator1_actuatortc(PID_modemanager, reinterpret_cast<const uint8_t*>(IN_buf_tc), size_IN_buf_tc);
}
// Required interface actuatorTc2 in function ModeManager
void vm_modemanager_actuatortc2
        (asn1SccPID dest_pid,
         const char *IN_buf_tc, size_t size_IN_buf_tc)

{
    if (PID_env == dest_pid || PID_actuator2 == dest_pid)
        deliver_to_actuator2_actuatortc(PID_modemanager, reinterpret_cast<const uint8_t*>(IN_buf_tc), size_IN_buf_tc);
}
// Required interface systemTm in function ModeManager
void vm_modemanager_systemtm
        (asn1SccPID dest_pid,
         const char *IN_buf_tm, size_t size_IN_buf_tm)

{
    if (PID_env == dest_pid || PID_egse == dest_pid)
        deliver_to_egse_systemtm(PID_modemanager, reinterpret_cast<const uint8_t*>(IN_buf_tm), size_IN_buf_tm);
}
#include "modemanager_vm_if.h"


void call_protected_ModeManager_actuatorTm1
      (const char *IN_buf_tm, size_t size_IN_buf_tm)

{
    extern taste::Lock modemanager_Mutex;

    modemanager_Mutex.lock();

    modemanager_actuatorTm1
      (IN_buf_tm, size_IN_buf_tm);


    modemanager_Mutex.unlock();
}
void call_protected_ModeManager_actuatorTm2
      (const char *IN_buf_tm, size_t size_IN_buf_tm)

{
    extern taste::Lock modemanager_Mutex;

    modemanager_Mutex.lock();

    modemanager_actuatorTm2
      (IN_buf_tm, size_IN_buf_tm);


    modemanager_Mutex.unlock();
}
void call_protected_ModeManager_reading
      (const char *IN_buf_x, size_t size_IN_buf_x)

{
    extern taste::Lock modemanager_Mutex;

    modemanager_Mutex.lock();

    modemanager_reading
      (IN_buf_x, size_IN_buf_x);


    modemanager_Mutex.unlock();
}
void call_protected_ModeManager_systemTc
      (const char *IN_buf_tc, size_t size_IN_buf_tc)

{
    extern taste::Lock modemanager_Mutex;

    modemanager_Mutex.lock();

    modemanager_systemTc
      (IN_buf_tc, size_IN_buf_tc);


    modemanager_Mutex.unlock();
}

void modemanager_check_queue(bool* has_pending_msg)
{
    *has_pending_msg = false;
    if(thread_modemanager_actuatortm1_check_queue())
    {
        *has_pending_msg = true;
        return;
    }
    if(thread_modemanager_actuatortm2_check_queue())
    {
        *has_pending_msg = true;
        return;
    }
    if(thread_modemanager_reading_check_queue())
    {
        *has_pending_msg = true;
        return;
    }
    if(thread_modemanager_systemtc_check_queue())
    {
        *has_pending_msg = true;
        return;
    }
}
// Required interfaces of function Sensor

// Required interface reading in function Sensor
void vm_sensor_reading
        (asn1SccPID dest_pid,
         const char *IN_buf_x, size_t size_IN_buf_x)

{
    if (PID_env == dest_pid || PID_modemanager == dest_pid)
        deliver_to_modemanager_reading(PID_sensor, reinterpret_cast<const uint8_t*>(IN_buf_x), size_IN_buf_x);
}
#include "sensor_vm_if.h"


void call_protected_Sensor_trigger(void)
{
    extern taste::Lock sensor_Mutex;

    sensor_Mutex.lock();

    sensor_trigger();

    sensor_Mutex.unlock();
}

void sensor_check_queue(bool* has_pending_msg)
{
    *has_pending_msg = false;
    if(thread_sensor_trigger_check_queue())
    {
        *has_pending_msg = true;
        return;
    }
}
}
