pragma Style_Checks (Off);
--  Code automatically generated by asn1scc tool
pragma Warnings (Off, "redundant with clause in body");
pragma Warnings (On, "redundant with clause in body");

package body BASICFLOATDEMO_DATAVIEW with SPARK_Mode is



pragma Warnings (Off, "condition can only be False if invalid values present");
pragma Warnings (Off, "condition can only be True if invalid values present");


function asn1SccT_Int_Equal (val1, val2 :  asn1SccT_Int) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_Int_Equal;

function asn1SccT_Int_IsConstraintValid(val : asn1SccT_Int) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ""ret"" has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ""ret"" has no effect");        
begin
    ret.Success := ((-10000 <= val) AND (val <= 10000));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_INT);
    return ret;
end asn1SccT_Int_IsConstraintValid;





function asn1SccT_Float_Equal (val1, val2 :  asn1SccT_Float) return Boolean
is

begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end asn1SccT_Float_Equal;

function asn1SccT_Float_IsConstraintValid(val : asn1SccT_Float) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ""ret"" has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ""ret"" has no effect");        
begin
    ret.Success := ((-1.0000000000000000000E+004 <= val) AND (val <= 1.0000000000000000000E+004));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_FLOAT);
    return ret;
end asn1SccT_Float_IsConstraintValid;




pragma Warnings (On, "condition can only be False if invalid values present");
pragma Warnings (On, "condition can only be True if invalid values present");

 
end BASICFLOATDEMO_DATAVIEW;