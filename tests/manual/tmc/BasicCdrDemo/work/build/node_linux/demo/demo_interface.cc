/* File generated by kazoo for TASTE - do not edit */
#include "demo_interface.h"
#include <cstring>

#include <Request.h>
#include <Lock.h>
#include <Queue.h>

#include "transport.h"
#include "routing.h"

extern "C"
{

#include "actuator_vm_if.h"

void call_actuator_ctrl (const char* buf, size_t len)
{
    actuator_ctrl (buf, len);
}

static bool thread_actuator_ctrl_check_queue()
{
	extern taste::Queue<ACTUATOR_CTRL_REQUEST_SIZE> actuator_ctrl_Global_Queue;
	return !actuator_ctrl_Global_Queue.is_empty();
}
#include "egse_vm_if.h"

void call_egse_poll (const char* buf, size_t len)
{
    extern taste::Lock egse_Mutex;

    egse_Mutex.lock();

    egse_Poll();
	egse_Mutex.unlock();
}

static bool thread_egse_poll_check_queue()
{
	extern taste::Queue<EGSE_POLL_REQUEST_SIZE> egse_Poll_Global_Queue;
	return !egse_Poll_Global_Queue.is_empty();
}
#include "egse_vm_if.h"

void call_egse_tm (const char* buf, size_t len)
{
    extern taste::Lock egse_Mutex;

    egse_Mutex.lock();

    egse_tm (buf, len);
	egse_Mutex.unlock();
}

static bool thread_egse_tm_check_queue()
{
	extern taste::Queue<EGSE_TM_REQUEST_SIZE> egse_tm_Global_Queue;
	return !egse_tm_Global_Queue.is_empty();
}
#include "modemanager_vm_if.h"

void call_modemanager_feedback (const char* buf, size_t len)
{
    extern taste::Lock modemanager_Mutex;

    modemanager_Mutex.lock();

    modemanager_feedback (buf, len);
	modemanager_Mutex.unlock();
}

static bool thread_modemanager_feedback_check_queue()
{
	extern taste::Queue<MODEMANAGER_FEEDBACK_REQUEST_SIZE> modemanager_feedback_Global_Queue;
	return !modemanager_feedback_Global_Queue.is_empty();
}
#include "modemanager_vm_if.h"

void call_modemanager_reading (const char* buf, size_t len)
{
    extern taste::Lock modemanager_Mutex;

    modemanager_Mutex.lock();

    modemanager_reading (buf, len);
	modemanager_Mutex.unlock();
}

static bool thread_modemanager_reading_check_queue()
{
	extern taste::Queue<MODEMANAGER_READING_REQUEST_SIZE> modemanager_reading_Global_Queue;
	return !modemanager_reading_Global_Queue.is_empty();
}
#include "modemanager_vm_if.h"

void call_modemanager_tc (const char* buf, size_t len)
{
    extern taste::Lock modemanager_Mutex;

    modemanager_Mutex.lock();

    modemanager_tc (buf, len);
	modemanager_Mutex.unlock();
}

static bool thread_modemanager_tc_check_queue()
{
	extern taste::Queue<MODEMANAGER_TC_REQUEST_SIZE> modemanager_tc_Global_Queue;
	return !modemanager_tc_Global_Queue.is_empty();
}
#include "sensor_vm_if.h"

void call_sensor_poll (const char* buf, size_t len)
{
    sensor_Poll();
}

static bool thread_sensor_poll_check_queue()
{
	extern taste::Queue<SENSOR_POLL_REQUEST_SIZE> sensor_Poll_Global_Queue;
	return !sensor_Poll_Global_Queue.is_empty();
}


// Required interfaces of function Actuator

// Required interface feedback in function Actuator
void vm_actuator_feedback
        (asn1SccPID dest_pid,
         const char *IN_buf_x, size_t size_IN_buf_x)

{
    if (PID_env == dest_pid || PID_modemanager == dest_pid)
        deliver_to_modemanager_feedback(PID_actuator, reinterpret_cast<const uint8_t*>(IN_buf_x), size_IN_buf_x);
}
#include "actuator_vm_if.h"


void call_protected_Actuator_ctrl
      (const char *IN_buf_x, size_t size_IN_buf_x)

{
    extern taste::Lock actuator_Mutex;

    actuator_Mutex.lock();

    actuator_ctrl
      (IN_buf_x, size_IN_buf_x);


    actuator_Mutex.unlock();
}

void actuator_check_queue(bool* has_pending_msg)
{
    *has_pending_msg = false;
    if(thread_actuator_ctrl_check_queue())
    {
        *has_pending_msg = true;
        return;
    }
}
// Required interfaces of function EGSE

// Required interface tc in function EGSE
void vm_egse_tc
        (asn1SccPID dest_pid,
         const char *IN_buf_cfg, size_t size_IN_buf_cfg)

{
    if (PID_env == dest_pid || PID_modemanager == dest_pid)
        deliver_to_modemanager_tc(PID_egse, reinterpret_cast<const uint8_t*>(IN_buf_cfg), size_IN_buf_cfg);
}
#include "egse_vm_if.h"


void call_protected_EGSE_Poll(void)
{
    extern taste::Lock egse_Mutex;

    egse_Mutex.lock();

    egse_Poll();

    egse_Mutex.unlock();
}
void call_protected_EGSE_tm
      (const char *IN_buf_reprt, size_t size_IN_buf_reprt)

{
    extern taste::Lock egse_Mutex;

    egse_Mutex.lock();

    egse_tm
      (IN_buf_reprt, size_IN_buf_reprt);


    egse_Mutex.unlock();
}

void egse_check_queue(bool* has_pending_msg)
{
    *has_pending_msg = false;
    if(thread_egse_poll_check_queue())
    {
        *has_pending_msg = true;
        return;
    }
    if(thread_egse_tm_check_queue())
    {
        *has_pending_msg = true;
        return;
    }
}
// Required interfaces of function ModeManager

// Required interface ctrl in function ModeManager
void vm_modemanager_ctrl
        (asn1SccPID dest_pid,
         const char *IN_buf_x, size_t size_IN_buf_x)

{
    if (PID_env == dest_pid || PID_actuator == dest_pid)
        deliver_to_actuator_ctrl(PID_modemanager, reinterpret_cast<const uint8_t*>(IN_buf_x), size_IN_buf_x);
}
// Required interface tm in function ModeManager
void vm_modemanager_tm
        (asn1SccPID dest_pid,
         const char *IN_buf_reprt, size_t size_IN_buf_reprt)

{
    if (PID_env == dest_pid || PID_egse == dest_pid)
        deliver_to_egse_tm(PID_modemanager, reinterpret_cast<const uint8_t*>(IN_buf_reprt), size_IN_buf_reprt);
}
#include "modemanager_vm_if.h"


void call_protected_ModeManager_feedback
      (const char *IN_buf_x, size_t size_IN_buf_x)

{
    extern taste::Lock modemanager_Mutex;

    modemanager_Mutex.lock();

    modemanager_feedback
      (IN_buf_x, size_IN_buf_x);


    modemanager_Mutex.unlock();
}
void call_protected_ModeManager_reading
      (const char *IN_buf_x, size_t size_IN_buf_x)

{
    extern taste::Lock modemanager_Mutex;

    modemanager_Mutex.lock();

    modemanager_reading
      (IN_buf_x, size_IN_buf_x);


    modemanager_Mutex.unlock();
}
void call_protected_ModeManager_tc
      (const char *IN_buf_cfg, size_t size_IN_buf_cfg)

{
    extern taste::Lock modemanager_Mutex;

    modemanager_Mutex.lock();

    modemanager_tc
      (IN_buf_cfg, size_IN_buf_cfg);


    modemanager_Mutex.unlock();
}

void modemanager_check_queue(bool* has_pending_msg)
{
    *has_pending_msg = false;
    if(thread_modemanager_feedback_check_queue())
    {
        *has_pending_msg = true;
        return;
    }
    if(thread_modemanager_reading_check_queue())
    {
        *has_pending_msg = true;
        return;
    }
    if(thread_modemanager_tc_check_queue())
    {
        *has_pending_msg = true;
        return;
    }
}
// Required interfaces of function Sensor

// Required interface reading in function Sensor
void vm_sensor_reading
        (asn1SccPID dest_pid,
         const char *IN_buf_x, size_t size_IN_buf_x)

{
    if (PID_env == dest_pid || PID_modemanager == dest_pid)
        deliver_to_modemanager_reading(PID_sensor, reinterpret_cast<const uint8_t*>(IN_buf_x), size_IN_buf_x);
}
#include "sensor_vm_if.h"


void call_protected_Sensor_Poll(void)
{
    extern taste::Lock sensor_Mutex;

    sensor_Mutex.lock();

    sensor_Poll();

    sensor_Mutex.unlock();
}

void sensor_check_queue(bool* has_pending_msg)
{
    *has_pending_msg = false;
    if(thread_sensor_poll_check_queue())
    {
        *has_pending_msg = true;
        return;
    }
}
}
