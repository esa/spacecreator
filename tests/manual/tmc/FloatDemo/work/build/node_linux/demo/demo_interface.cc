/* File generated by kazoo for TASTE - do not edit */
#include "demo_interface.h"
#include <cstring>

#include <Request.h>
#include <Lock.h>
#include <Queue.h>

#include "transport.h"
#include "routing.h"

extern "C"
{

#include "actuator_vm_if.h"

void call_actuator_controlsignal (const char* buf, size_t len)
{
    actuator_controlSignal (buf, len);
}

static bool thread_actuator_controlsignal_check_queue()
{
	extern taste::Queue<ACTUATOR_CONTROLSIGNAL_REQUEST_SIZE> actuator_controlSignal_Global_Queue;
	return !actuator_controlSignal_Global_Queue.is_empty();
}
#include "controlsystem_vm_if.h"

void call_controlsystem_configuration (const char* buf, size_t len)
{
    extern taste::Lock controlsystem_Mutex;

    controlsystem_Mutex.lock();

    controlsystem_configuration (buf, len);
	controlsystem_Mutex.unlock();
}

static bool thread_controlsystem_configuration_check_queue()
{
	extern taste::Queue<CONTROLSYSTEM_CONFIGURATION_REQUEST_SIZE> controlsystem_configuration_Global_Queue;
	return !controlsystem_configuration_Global_Queue.is_empty();
}
#include "controlsystem_vm_if.h"

void call_controlsystem_reading (const char* buf, size_t len)
{
    extern taste::Lock controlsystem_Mutex;

    controlsystem_Mutex.lock();

    controlsystem_reading (buf, len);
	controlsystem_Mutex.unlock();
}

static bool thread_controlsystem_reading_check_queue()
{
	extern taste::Queue<CONTROLSYSTEM_READING_REQUEST_SIZE> controlsystem_reading_Global_Queue;
	return !controlsystem_reading_Global_Queue.is_empty();
}
#include "demo_timer_manager_vm_if.h"

void call_demo_timer_manager_tick (const char* buf, size_t len)
{
    extern taste::Lock demo_timer_manager_Mutex;

    demo_timer_manager_Mutex.lock();

    demo_timer_manager_Tick();
	demo_timer_manager_Mutex.unlock();
}

static bool thread_demo_timer_manager_tick_check_queue()
{
	extern taste::Queue<DEMO_TIMER_MANAGER_TICK_REQUEST_SIZE> demo_timer_manager_Tick_Global_Queue;
	return !demo_timer_manager_Tick_Global_Queue.is_empty();
}
#include "host_vm_if.h"

void call_host_tm (const char* buf, size_t len)
{
    host_tm();
}

static bool thread_host_tm_check_queue()
{
	extern taste::Queue<HOST_TM_REQUEST_SIZE> host_tm_Global_Queue;
	return !host_tm_Global_Queue.is_empty();
}
#include "sensor_vm_if.h"

void call_sensor_tc (const char* buf, size_t len)
{
    extern taste::Lock sensor_Mutex;

    sensor_Mutex.lock();

    sensor_tc();
	sensor_Mutex.unlock();
}

static bool thread_sensor_tc_check_queue()
{
	extern taste::Queue<SENSOR_TC_REQUEST_SIZE> sensor_tc_Global_Queue;
	return !sensor_tc_Global_Queue.is_empty();
}
#include "sensor_vm_if.h"

void call_sensor_trigger (const char* buf, size_t len)
{
    extern taste::Lock sensor_Mutex;

    sensor_Mutex.lock();

    sensor_trigger();
	sensor_Mutex.unlock();
}

static bool thread_sensor_trigger_check_queue()
{
	extern taste::Queue<SENSOR_TRIGGER_REQUEST_SIZE> sensor_trigger_Global_Queue;
	return !sensor_trigger_Global_Queue.is_empty();
}


#include "actuator_vm_if.h"


void call_protected_Actuator_controlSignal
      (const char *IN_buf_controlvalue, size_t size_IN_buf_controlvalue)

{
    extern taste::Lock actuator_Mutex;

    actuator_Mutex.lock();

    actuator_controlSignal
      (IN_buf_controlvalue, size_IN_buf_controlvalue);


    actuator_Mutex.unlock();
}

void actuator_check_queue(bool* has_pending_msg)
{
    *has_pending_msg = false;
    if(thread_actuator_controlsignal_check_queue())
    {
        *has_pending_msg = true;
        return;
    }
}
// Required interfaces of function ControlSystem

// Required interface controlSignal in function ControlSystem
void vm_controlsystem_controlsignal
        (asn1SccPID dest_pid,
         const char *IN_buf_controlvalue, size_t size_IN_buf_controlvalue)

{
    if (PID_env == dest_pid || PID_actuator == dest_pid)
        deliver_to_actuator_controlsignal(PID_controlsystem, reinterpret_cast<const uint8_t*>(IN_buf_controlvalue), size_IN_buf_controlvalue);
}
// Required interface tm in function ControlSystem
void vm_controlsystem_tm(asn1SccPID dest_pid)
{
    static uint8_t buffer_placeholder[1];
    if (PID_env == dest_pid || PID_host == dest_pid)
        deliver_to_host_tm(PID_controlsystem, buffer_placeholder, 0);
}
#include "controlsystem_vm_if.h"


void call_protected_ControlSystem_configuration
      (const char *IN_buf_cfg, size_t size_IN_buf_cfg)

{
    extern taste::Lock controlsystem_Mutex;

    controlsystem_Mutex.lock();

    controlsystem_configuration
      (IN_buf_cfg, size_IN_buf_cfg);


    controlsystem_Mutex.unlock();
}
void call_protected_ControlSystem_reading
      (const char *IN_buf_signalvalue, size_t size_IN_buf_signalvalue)

{
    extern taste::Lock controlsystem_Mutex;

    controlsystem_Mutex.lock();

    controlsystem_reading
      (IN_buf_signalvalue, size_IN_buf_signalvalue);


    controlsystem_Mutex.unlock();
}

void controlsystem_check_queue(bool* has_pending_msg)
{
    *has_pending_msg = false;
    if(thread_controlsystem_configuration_check_queue())
    {
        *has_pending_msg = true;
        return;
    }
    if(thread_controlsystem_reading_check_queue())
    {
        *has_pending_msg = true;
        return;
    }
}
// Required interfaces of function demo_Timer_Manager

// Required interface sensor_trigger in function demo_Timer_Manager
void vm_demo_timer_manager_sensor_trigger(asn1SccPID dest_pid)
{
    static uint8_t buffer_placeholder[1];
    if (PID_env == dest_pid || PID_sensor == dest_pid)
        deliver_to_sensor_trigger(PID_env, buffer_placeholder, 0);
}
#include "demo_timer_manager_vm_if.h"


void call_protected_demo_Timer_Manager_RESET_sensor_trigger(void)
{
    extern taste::Lock demo_timer_manager_Mutex;

    demo_timer_manager_Mutex.lock();

    demo_timer_manager_RESET_sensor_trigger();

    demo_timer_manager_Mutex.unlock();
}
void call_protected_demo_Timer_Manager_SET_sensor_trigger
      (const char *IN_buf_val, size_t size_IN_buf_val)

{
    extern taste::Lock demo_timer_manager_Mutex;

    demo_timer_manager_Mutex.lock();

    demo_timer_manager_SET_sensor_trigger
      (IN_buf_val, size_IN_buf_val);


    demo_timer_manager_Mutex.unlock();
}
void call_protected_demo_Timer_Manager_Tick(void)
{
    extern taste::Lock demo_timer_manager_Mutex;

    demo_timer_manager_Mutex.lock();

    demo_timer_manager_Tick();

    demo_timer_manager_Mutex.unlock();
}

void demo_timer_manager_check_queue(bool* has_pending_msg)
{
    *has_pending_msg = false;
    if(thread_demo_timer_manager_tick_check_queue())
    {
        *has_pending_msg = true;
        return;
    }
}
// Required interfaces of function Host

// Required interface configuration in function Host
void vm_host_configuration
        (asn1SccPID dest_pid,
         const char *IN_buf_cfg, size_t size_IN_buf_cfg)

{
    if (PID_env == dest_pid || PID_controlsystem == dest_pid)
        deliver_to_controlsystem_configuration(PID_host, reinterpret_cast<const uint8_t*>(IN_buf_cfg), size_IN_buf_cfg);
}
// Required interface tc in function Host
void vm_host_tc(asn1SccPID dest_pid)
{
    static uint8_t buffer_placeholder[1];
    if (PID_env == dest_pid || PID_sensor == dest_pid)
        deliver_to_sensor_tc(PID_host, buffer_placeholder, 0);
}
#include "host_vm_if.h"


void call_protected_Host_tm(void)
{
    extern taste::Lock host_Mutex;

    host_Mutex.lock();

    host_tm();

    host_Mutex.unlock();
}

void host_check_queue(bool* has_pending_msg)
{
    *has_pending_msg = false;
    if(thread_host_tm_check_queue())
    {
        *has_pending_msg = true;
        return;
    }
}
// Required interfaces of function Sensor

// Required interface RESET_trigger in function sensor
#include "demo_timer_manager_vm_if.h"  // Remote language: Timer_Manager
void vm_sensor_reset_trigger(asn1SccPID dest_pid)
{
   // puts("[TASTE] Protected call of RESET_trigger");
        demo_timer_manager_reset_sensor_trigger_sender_pid = PID_sensor;
         call_protected_demo_Timer_Manager_RESET_sensor_trigger();
}
// Required interface SET_trigger in function sensor
#include "demo_timer_manager_vm_if.h"  // Remote language: Timer_Manager
void vm_sensor_set_trigger
        (asn1SccPID dest_pid,
         const char *IN_buf_val, size_t size_IN_buf_val)

{
   // puts("[TASTE] Protected call of SET_trigger");
        demo_timer_manager_set_sensor_trigger_sender_pid = PID_sensor;
         call_protected_demo_Timer_Manager_SET_sensor_trigger
        (IN_buf_val, size_IN_buf_val);

}
// Required interface reading in function Sensor
void vm_sensor_reading
        (asn1SccPID dest_pid,
         const char *IN_buf_signalvalue, size_t size_IN_buf_signalvalue)

{
    if (PID_env == dest_pid || PID_controlsystem == dest_pid)
        deliver_to_controlsystem_reading(PID_sensor, reinterpret_cast<const uint8_t*>(IN_buf_signalvalue), size_IN_buf_signalvalue);
}
#include "sensor_vm_if.h"


void call_protected_Sensor_tc(void)
{
    extern taste::Lock sensor_Mutex;

    sensor_Mutex.lock();

    sensor_tc();

    sensor_Mutex.unlock();
}
void call_protected_sensor_trigger(void)
{
    extern taste::Lock sensor_Mutex;

    sensor_Mutex.lock();

    sensor_trigger();

    sensor_Mutex.unlock();
}

void sensor_check_queue(bool* has_pending_msg)
{
    *has_pending_msg = false;
    if(thread_sensor_tc_check_queue())
    {
        *has_pending_msg = true;
        return;
    }
    if(thread_sensor_trigger_check_queue())
    {
        *has_pending_msg = true;
        return;
    }
}
}
