process Calibration;
    dcl Iterator RealType;
    dcl Calibratedvalue RealType;
    dcl RawSplinePoints1 SplinePointsArray;
    dcl CalibratedSplinePoints1 SplinePointsArray;

    procedure FindInterval;
        dcl result SplinePointsArrayIndex;
        fpar
            in value SplinePointValue,
            in rawPoints SplinePointsArray;
        returns SplinePointsArrayIndex;
        START;
            task result := 0;
            find_interval_start:
            decision result < length(rawPoints);
                (True):
                    decision rawPoints(result) >= value;
                        (True):
                            return result;
                        (False):
                            task result := result + 1;
                            join find_interval_start;
                    enddecision;
                (False):
                    join find_interval_end;
            enddecision;
            find_interval_end:
            task result := result + 1;
        return result;
    endprocedure;

    procedure LinearCalibration;
        dcl x0 SplinePointValue;
        dcl x1 SplinePointValue;
        dcl y0 SplinePointValue;
        dcl y1 SplinePointValue;
        dcl l0 SplinePointValue;
        dcl l1 SplinePointValue;
        dcl result SplinePointValue;
        fpar
            in intervalIndex SplinePointsArrayIndex,
            in value SplinePointValue,
            in rawPoints SplinePointsArray,
            in calibratedPoints SplinePointsArray;
        returns SplinePointValue;
        START;
            decision value = rawPoints(intervalIndex);
                (True):
                    return calibratedPoints(intervalIndex);
                (False):
            enddecision;

            task x0 := rawPoints(intervalIndex-1);
            task x1 := rawPoints(intervalIndex);
            task y0 := calibratedPoints(intervalIndex-1);
            task y1 := calibratedPoints(intervalIndex);
            task l0 := (value - x1) / (x0 - x1);
            task l1 := (value - x0) / (x1 - x0);

            task result := l0 * y0 + l1 * y1;
        return result;
    endprocedure;

    procedure SquareCalibration;
        dcl x0 SplinePointValue;
        dcl x1 SplinePointValue;
        dcl x2 SplinePointValue;
        dcl y0 SplinePointValue;
        dcl y1 SplinePointValue;
        dcl y2 SplinePointValue;
        dcl l0 SplinePointValue;
        dcl l1 SplinePointValue;
        dcl l2 SplinePointValue;
        dcl result SplinePointValue;
        fpar
            in intervalIndex SplinePointsArrayIndex,
            in value SplinePointValue,
            in rawPoints SplinePointsArray,
            in calibratedPoints SplinePointsArray;
        returns SplinePointValue;
        START;
            decision value = rawPoints(intervalIndex);
                (True):
                    return calibratedPoints(intervalIndex);
                (False):
            enddecision;

            task x0 := rawPoints(intervalIndex-1);
            task x1 := rawPoints(intervalIndex);
            task x2 := rawPoints(intervalIndex+1);
            task y0 := calibratedPoints(intervalIndex-1);
            task y1 := calibratedPoints(intervalIndex);
            task y2 := calibratedPoints(intervalIndex+1);
            task l0 := ((value - x1) * (value - x2)) / ((x0 - x1) * (x0 - x2));
            task l1 := ((value - x0) * (value - x2)) / ((x1 - x0) * (x1 - x2));
            task l2 := ((value - x0) * (value - x1)) / ((x2 - x0) * (x2 - x1));
            task result := l0 * y0 + l1 * y1 + l2 * y2;
        return result;
    endprocedure;

    procedure CubicCalibration;
        dcl x0 SplinePointValue;
        dcl x1 SplinePointValue;
        dcl x2 SplinePointValue;
        dcl x3 SplinePointValue;
        dcl y0 SplinePointValue;
        dcl y1 SplinePointValue;
        dcl y2 SplinePointValue;
        dcl y3 SplinePointValue;
        dcl l0 SplinePointValue;
        dcl l1 SplinePointValue;
        dcl l2 SplinePointValue;
        dcl l3 SplinePointValue;
        dcl result SplinePointValue;
        fpar
            in intervalIndex SplinePointsArrayIndex,
            in value SplinePointValue,
            in rawPoints SplinePointsArray,
            in calibratedPoints SplinePointsArray;
        returns SplinePointValue;
        START;
            decision value = rawPoints(intervalIndex);
                (True):
                    return calibratedPoints(intervalIndex);
                (False):
            enddecision;

            task x0 := rawPoints(intervalIndex-2);
            task x1 := rawPoints(intervalIndex-1);
            task x2 := rawPoints(intervalIndex);
            task x3 := rawPoints(intervalIndex+1);
            task y0 := calibratedPoints(intervalIndex-2);
            task y1 := calibratedPoints(intervalIndex-1);
            task y2 := calibratedPoints(intervalIndex);
            task y3 := calibratedPoints(intervalIndex+1);
            task l0 := ((value - x1) * (value - x2) * (value - x3)) / ((x0 - x1) * (x0 - x2) * (x0 - x3));
            task l1 := ((value - x0) * (value - x2) * (value - x3)) / ((x1 - x0) * (x1 - x2) * (x1 - x3));
            task l2 := ((value - x0) * (value - x1) * (value - x3)) / ((x2 - x0) * (x2 - x1) * (x2 - x3));
            task l3 := ((value - x0) * (value - x1) * (value - x2)) / ((x3 - x0) * (x3 - x1) * (x3 - x2));
            task result := l0 * y0 + l1 * y1 + l2 * y2 + l3 * y3;
        return result;
    endprocedure;

    procedure LinearExtrapolation;
        dcl x0 SplinePointValue;
        dcl x1 SplinePointValue;
        dcl y0 SplinePointValue;
        dcl y1 SplinePointValue;
        dcl result SplinePointValue;
        fpar
            in intervalIndex SplinePointsArrayIndex,
            in value SplinePointValue,
            in rawPoints SplinePointsArray,
            in calibratedPoints SplinePointsArray;
        returns SplinePointValue;
        START;
            decision intervalIndex = -1;
                (True):
                    task x0 := rawPoints(0);
                    task x1 := rawPoints(1);
                    task y0 := calibratedPoints(0);
                    task y1 := calibratedPoints(1);
                (False):
                    task x0 := rawPoints(intervalIndex-1);
                    task x1 := rawPoints(intervalIndex-2);
                    task y0 := calibratedPoints(intervalIndex-1);
                    task y1 := calibratedPoints(intervalIndex-2);
            enddecision;
            task result := y1 + ((value - x1) / (x0 - x1)) * (y0 - y1);
        return result;
    endprocedure;

    procedure InitRawSplinePoints1;
        START;
            task RawSplinePoints1 := { 1.000000, 5.000000, 10.000000, 20.000000 };
        return ;
    endprocedure;

    procedure InitCalibratedSplinePoints1;
        START;
            task CalibratedSplinePoints1 := { 2.000000, 10.000000, -20.000000, 40.000000 };
        return ;
    endprocedure;

    procedure CalibrateActivity;
        dcl intervalIndex SplinePointsArrayIndex;
        START;

            task Iterator := -5.0;

            loop_start_1:
            decision Iterator <= 25.0;
                (False):
                    join loop_end_2;
                (True):
                    task intervalIndex := call FindInterval(Iterator, RawSplinePoints1);

                    decision intervalIndex = -1 or intervalIndex = length(rawPoints);
                        (True):
                            task Calibratedvalue := call LinearExtrapolation(intervalIndex, Iterator, RawSplinePoints1, CalibratedSplinePoints1);
                        (False):
                            task Calibratedvalue := call LinearCalibration(intervalIndex, Iterator, RawSplinePoints1, CalibratedSplinePoints1);
                    enddecision;

                    task Iterator := Iterator + 1.0;
                    join loop_start_1;
            enddecision;
            loop_end_2:
        return ;
    endprocedure;

    START;
        call InitRawSplinePoints1;
        call InitCalibratedSplinePoints1;
        NEXTSTATE Idle;

    state DoCalibration;
    endstate;

    state Idle;
        input ComponentInterface_Tick_Pi;
            call CalibrateActivity;
            NEXTSTATE DoCalibration;
    endstate;

endprocess Calibration;
