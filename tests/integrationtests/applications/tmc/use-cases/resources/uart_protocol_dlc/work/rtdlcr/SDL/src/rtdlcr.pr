/* CIF PROCESS (248, 148), (150, 75) */
process rtdlcr;
    /* CIF TEXT (1781, 593), (373, 344) */
    -- Text area for declarations and comments
    
    timer FrameTimer;
    
    DCL rxChar UINT8;
    DCL rxCount UINT8;
    DCL rxFrameBuffer T_UART_DLC_FrameBuffer;
    DCL rxPDU T_UART_DLC_PDU;
    
    DCL headerValid T_ValidInvalidState;
    DCL crcResult T_SuccessFailState;
    
    DCL FRAME_TIMEOUT UINT16 := 1000;
    
    --procedure ComputeCRC;
    --fpar
        --in rxFrame T_UART_DLC_SDU,
        --out result T_UART_DLC_FrameCRC;
    --EXTERNAL;
    /* CIF ENDTEXT */
    /* CIF procedure (1791, 446), (137, 35) */
    procedure IsValidUartHeader
    /* CIF comment (1946, 444), (237, 40) */
    comment 'Returns true if a character is a valid
UART frame header';
        /* CIF TEXT (381, 131), (273, 140) */
        -- Text area for declarations and comments
        
        fpar
          in inChar UINT8,
          out result T_ValidInvalidState;
        /* CIF ENDTEXT */
        /* CIF START (178, 143), (70, 35) */
        START;
            /* CIF decision (178, 198), (70, 50) */
            decision inChar;
                /* CIF ANSWER (0, 268), (184, 32) */
                (C_UART_DLC_SYNC_VALUE):
                    /* CIF task (39, 320), (105, 35) */
                    task result := valid;
                    /* CIF return (74, 370), (35, 35) */
                    return ;
                /* CIF ANSWER (279, 274), (70, 24) */
                else:
                    /* CIF task (256, 318), (115, 35) */
                    task result := invalid;
                    /* CIF return (296, 368), (35, 35) */
                    return ;
            enddecision;
    endprocedure;
    /* CIF procedure (1788, 384), (126, 35) */
    procedure CheckFrameCRC
    /* CIF comment (1934, 373), (245, 56) */
    comment 'Checks the CRC of a complete
DLC frame.  Returns SUCCESS or FAIL.';
        /* CIF TEXT (663, 123), (285, 216) */
        -- Text area for declarations and comments
        
        fpar
            in rxFrame T_UART_DLC_PDU,
            out result T_SuccessFailState;
        
        DCL computedCRC T_UART_DLC_FrameCRC;
        /* CIF ENDTEXT */
        /* CIF START (732, 412), (70, 35) */
        START;
            /* CIF PROCEDURECALL (606, 467), (321, 35) */
            call ComputeCRC(rxFrame.dlc_payload, computedCRC);
            /* CIF decision (705, 517), (124, 50) */
            decision computedCRC =
rxFrame.crc;
                /* CIF ANSWER (651, 587), (70, 24) */
                (true):
                    /* CIF PROCEDURECALL (609, 631), (153, 35) */
                    call writeln('Rx CRC pass');
                    /* CIF task (623, 681), (126, 35) */
                    task result := success;
                /* CIF ANSWER (812, 587), (70, 24) */
                else:
                    /* CIF PROCEDURECALL (774, 631), (145, 35) */
                    call writeln('Rx CRC fail');
                    /* CIF task (797, 681), (99, 35) */
                    task result := fail;
            enddecision;
            /* CIF return (749, 732), (35, 35) */
            return ;
    endprocedure;
    /* CIF procedure (1785, 310), (71, 35) */
    procedure Decode
    /* CIF comment (1886, 308), (214, 40) */
    comment 'Takes a byte array and decodes
it into an ASN.1 structure';
        /* CIF TEXT (897, 311), (319, 140) */
        -- Text area for declarations and comments
        
        fpar
          in byteBuffer T_UART_DLC_FrameBuffer,
          out frame T_UART_DLC_PDU;
        /* CIF ENDTEXT */
        /* CIF START (313, 137), (70, 35) */
        START
        /* CIF comment (557, 118), (250, 72) */
        comment 'It would be nice to have access to ACN 
encoder/decoder functions from SDL.
In the meantime we use this bespoke
decoding procedure.';
            /* CIF task (195, 242), (304, 35) */
            task frame.dlc_header := C_UART_DLC_SYNC_VALUE
            /* CIF comment (520, 239), (242, 40) */
            comment 'This ought not to give an OpenGeode
warning.';
            /* CIF task (189, 297), (317, 56) */
            task for  index in RANGE (0,c_UART_DLC_SDU_SIZE) :
  frame.dlc_payload(index) := byteBuffer(1+index)
endfor;
            /* CIF task (187, 384), (320, 35) */
            task frame.crc := byteBuffer(c_UART_DLC_SDU_SIZE+1);
            /* CIF return (330, 434), (35, 35) */
            return ;
    endprocedure;
    /* CIF procedure (1790, 512), (92, 35) */
    procedure ResetDLCR;
        /* CIF START (226, 92), (70, 35) */
        START;
            /* CIF task (213, 147), (94, 40) */
            task rxCount := 0;
            /* CIF task (113, 207), (294, 56) */
            task for index in range(0, C_UART_DLC_PDU_SIZE):
  rxFrameBuffer(index) := 0
endfor;
            /* CIF return (243, 294), (35, 35) */
            return ;
    endprocedure;
    /* CIF procedure (1564, 446), (101, 40) */
    procedure ComputeCRC;
        /* CIF TEXT (690, 284), (267, 200) */
        -- Text area for declarations and comments
        
        fpar
            in rxFrame T_UART_DLC_SDU,
            out result T_UART_DLC_FrameCRC;
        
        
        DCL dataIndex UINT16;
        DCL crc UINT8;
        DCL inputByte UINT8;
        /* CIF ENDTEXT */
        /* CIF START (390, 306), (70, 35) */
        START;
            /* CIF task (371, 361), (108, 40) */
            task crc := 0,
dataIndex := 0;
            /* CIF label (390, 421), (70, 35) */
            L1:
            /* CIF decision (325, 471), (200, 50) */
            decision dataIndex = length(rxFrame);
                /* CIF ANSWER (270, 541), (70, 24) */
                (true):
                    /* CIF task (259, 585), (90, 35) */
                    task result := crc;
                    /* CIF return (287, 640), (35, 35) */
                    return ;
                /* CIF ANSWER (521, 541), (70, 24) */
                (false):
                    /* CIF task (448, 585), (216, 35) */
                    task inputByte := rxFrame(dataIndex);
                    /* CIF task (420, 640), (270, 40) */
                    task crc := c_RMAPCRCTable(crc xor inputByte);
                    /* CIF task (466, 700), (178, 35) */
                    task dataIndex := dataIndex + 1;
                    /* CIF join (538, 750), (35, 35) */
                    join L1;
            enddecision;
    endprocedure;
    /* CIF START (670, 25), (70, 35) */
    START;
        /* CIF PROCEDURECALL (659, 80), (92, 35) */
        call ResetDLCR;
        /* CIF NEXTSTATE (670, 130), (70, 35) */
        NEXTSTATE IDLE;
    /* CIF state (1072, 715), (117, 40) */
    state RECEIVING;
        /* CIF input (1058, 776), (149, 40) */
        input PHYRxChar(rxChar);
            /* CIF PROCEDURECALL (1028, 836), (208, 35) */
            call writeln('received char ', rxChar);
            /* CIF task (1007, 886), (251, 35) */
            task rxFrameBuffer(rxCount) := rxChar;
            /* CIF task (1022, 941), (220, 35) */
            task rxCount := (rxCount + 1) mod 256;
            /* CIF decision (1096, 991), (72, 50) */
            decision rxCount;
                /* CIF ANSWER (814, 1073), (164, 24) */
                (C_UART_DLC_PDU_SIZE):
                    /* CIF PROCEDURECALL (806, 1117), (181, 35) */
                    call reset_timer(FrameTimer);
                    /* CIF PROCEDURECALL (786, 1171), (222, 35) */
                    call Decode(rxFrameBuffer, rxPDU);
                    /* CIF PROCEDURECALL (771, 1226), (252, 35) */
                    call CheckFrameCRC(rxPDU, crcResult);
                    /* CIF decision (854, 1276), (85, 50) */
                    decision crcResult;
                        /* CIF ANSWER (751, 1346), (101, 24) */
                        (success):
                            /* CIF output (698, 1390), (205, 35) */
                            output DLCRxSDU(rxPDU.dlc_payload);
                        /* CIF ANSWER (953, 1346), (96, 24) */
                        (fail):
                            /* CIF output (914, 1390), (173, 35) */
                            output DLCRxError (CRC_FAIL);
                    enddecision;
                    /* CIF PROCEDURECALL (851, 1441), (92, 35) */
                    call ResetDLCR;
                    /* CIF NEXTSTATE (862, 1491), (70, 35) */
                    NEXTSTATE IDLE;
                /* CIF ANSWER (1281, 1070), (70, 24) */
                else:
                    /* CIF NEXTSTATE (1272, 1114), (87, 35) */
                    NEXTSTATE RECEIVING;
            enddecision;
    endstate;
    /* CIF state (972, 18), (87, 40) */
    state IDLE;
        /* CIF input (943, 79), (149, 40) */
        input PHYRxChar(rxChar);
            /* CIF PROCEDURECALL (913, 139), (208, 35) */
            call writeln('received char ', rxChar);
            /* CIF PROCEDURECALL (885, 189), (264, 35) */
            call IsValidUartHeader(rxChar, headerValid);
            /* CIF decision (967, 244), (101, 75) */
            decision headerValid;
                /* CIF ANSWER (775, 347), (79, 25) */
                (valid):
                    /* CIF task (722, 392), (185, 35) */
                    task rxFrameBuffer(0) := rxChar;
                    /* CIF task (750, 447), (129, 35) */
                    task rxCount := 1;
                    /* CIF PROCEDURECALL (674, 497), (281, 35) */
                    call set_timer(FRAME_TIMEOUT, FrameTimer);
                    /* CIF NEXTSTATE (770, 552), (87, 35) */
                    NEXTSTATE RECEIVING;
                /* CIF ANSWER (1089, 357), (70, 24) */
                (invalid):
                    /* CIF output (1018, 401), (210, 35) */
                    output DLCRxError(BAD_START_CHAR);
                    /* CIF PROCEDURECALL (1078, 456), (92, 35) */
                    call ResetDLCR;
                    /* CIF NEXTSTATE (1089, 506), (70, 35) */
                    NEXTSTATE IDLE;
            enddecision;
    endstate;
    /* CIF state (1771, 35), (70, 35) */
    state *;
        /* CIF input (1570, 90), (96, 35) */
        input FrameTimer;
            /* CIF PROCEDURECALL (1572, 145), (92, 35) */
            call ResetDLCR;
            /* CIF output (1500, 195), (236, 35) */
            output DLCRxError(FRAME_TIMEOUT);
            /* CIF NEXTSTATE (1583, 256), (70, 35) */
            NEXTSTATE IDLE;
        /* CIF input (1860, 90), (98, 38) */
        input DLCRxReset;
            /* CIF PROCEDURECALL (1863, 145), (92, 35) */
            call ResetDLCR;
            /* CIF NEXTSTATE (1874, 195), (70, 35) */
            NEXTSTATE IDLE;
    endstate;
endprocess rtdlcr;