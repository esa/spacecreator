pragma Style_Checks (Off);
--  Code automatically generated by asn1scc tool
pragma Warnings (Off, "redundant with clause in body");
pragma Warnings (On, "redundant with clause in body");

package body Bilevel_Types with SPARK_Mode is



pragma Warnings (Off, "condition can only be False if invalid values present");
pragma Warnings (Off, "condition can only be True if invalid values present");


function asn1SccT_OnOffState_Equal (val1, val2 :  asn1SccT_OnOffState) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_OnOffState_Equal;

function asn1SccT_OnOffState_IsConstraintValid(val : asn1SccT_OnOffState) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccoff)) OR ((val = asn1Sccon)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_ONOFFSTATE);
    return ret;
end asn1SccT_OnOffState_IsConstraintValid;

function asn1SccT_OnOffState_Init return asn1SccT_OnOffState
is
    val: asn1SccT_OnOffState;
begin
    val := asn1Sccoff;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_OnOffState_Init;



function asn1SccT_NominalRedundantState_Equal (val1, val2 :  asn1SccT_NominalRedundantState) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_NominalRedundantState_Equal;

function asn1SccT_NominalRedundantState_IsConstraintValid(val : asn1SccT_NominalRedundantState) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccredundant)) OR ((val = asn1Sccnominal)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_NOMINALREDUNDANTSTATE);
    return ret;
end asn1SccT_NominalRedundantState_IsConstraintValid;

function asn1SccT_NominalRedundantState_Init return asn1SccT_NominalRedundantState
is
    val: asn1SccT_NominalRedundantState;
begin
    val := asn1Sccredundant;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_NominalRedundantState_Init;



function asn1SccT_ConnectionState_Equal (val1, val2 :  asn1SccT_ConnectionState) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_ConnectionState_Equal;

function asn1SccT_ConnectionState_IsConstraintValid(val : asn1SccT_ConnectionState) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccdisconnected)) OR ((val = asn1Sccconnected)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_CONNECTIONSTATE);
    return ret;
end asn1SccT_ConnectionState_IsConstraintValid;

function asn1SccT_ConnectionState_Init return asn1SccT_ConnectionState
is
    val: asn1SccT_ConnectionState;
begin
    val := asn1Sccdisconnected;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_ConnectionState_Init;



function asn1SccT_SwitchState_Equal (val1, val2 :  asn1SccT_SwitchState) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_SwitchState_Equal;

function asn1SccT_SwitchState_IsConstraintValid(val : asn1SccT_SwitchState) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccswitch_open)) OR ((val = asn1Sccswitch_closed)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_SWITCHSTATE);
    return ret;
end asn1SccT_SwitchState_IsConstraintValid;

function asn1SccT_SwitchState_Init return asn1SccT_SwitchState
is
    val: asn1SccT_SwitchState;
begin
    val := asn1Sccswitch_open;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_SwitchState_Init;



function asn1SccT_FaultState_Equal (val1, val2 :  asn1SccT_FaultState) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_FaultState_Equal;

function asn1SccT_FaultState_IsConstraintValid(val : asn1SccT_FaultState) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccfault)) OR ((val = asn1Sccok)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_FAULTSTATE);
    return ret;
end asn1SccT_FaultState_IsConstraintValid;

function asn1SccT_FaultState_Init return asn1SccT_FaultState
is
    val: asn1SccT_FaultState;
begin
    val := asn1Sccfault;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_FaultState_Init;



function asn1SccT_SelectionState_Equal (val1, val2 :  asn1SccT_SelectionState) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_SelectionState_Equal;

function asn1SccT_SelectionState_IsConstraintValid(val : asn1SccT_SelectionState) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccnot_selected)) OR ((val = asn1Sccselected)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_SELECTIONSTATE);
    return ret;
end asn1SccT_SelectionState_IsConstraintValid;

function asn1SccT_SelectionState_Init return asn1SccT_SelectionState
is
    val: asn1SccT_SelectionState;
begin
    val := asn1Sccnot_selected;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_SelectionState_Init;



function asn1SccT_PresenceState_Equal (val1, val2 :  asn1SccT_PresenceState) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_PresenceState_Equal;

function asn1SccT_PresenceState_IsConstraintValid(val : asn1SccT_PresenceState) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccabsent)) OR ((val = asn1Sccpresent)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_PRESENCESTATE);
    return ret;
end asn1SccT_PresenceState_IsConstraintValid;

function asn1SccT_PresenceState_Init return asn1SccT_PresenceState
is
    val: asn1SccT_PresenceState;
begin
    val := asn1Sccabsent;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_PresenceState_Init;



function asn1SccT_ForwardBackwardState_Equal (val1, val2 :  asn1SccT_ForwardBackwardState) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_ForwardBackwardState_Equal;

function asn1SccT_ForwardBackwardState_IsConstraintValid(val : asn1SccT_ForwardBackwardState) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccbackward)) OR ((val = asn1Sccforward)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_FORWARDBACKWARDSTATE);
    return ret;
end asn1SccT_ForwardBackwardState_IsConstraintValid;

function asn1SccT_ForwardBackwardState_Init return asn1SccT_ForwardBackwardState
is
    val: asn1SccT_ForwardBackwardState;
begin
    val := asn1Sccbackward;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_ForwardBackwardState_Init;



function asn1SccT_LeftRightState_Equal (val1, val2 :  asn1SccT_LeftRightState) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_LeftRightState_Equal;

function asn1SccT_LeftRightState_IsConstraintValid(val : asn1SccT_LeftRightState) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccleft)) OR ((val = asn1Sccright)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_LEFTRIGHTSTATE);
    return ret;
end asn1SccT_LeftRightState_IsConstraintValid;

function asn1SccT_LeftRightState_Init return asn1SccT_LeftRightState
is
    val: asn1SccT_LeftRightState;
begin
    val := asn1Sccleft;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_LeftRightState_Init;



function asn1SccT_UsedUnusedState_Equal (val1, val2 :  asn1SccT_UsedUnusedState) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_UsedUnusedState_Equal;

function asn1SccT_UsedUnusedState_IsConstraintValid(val : asn1SccT_UsedUnusedState) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccunused)) OR ((val = asn1Sccused)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_USEDUNUSEDSTATE);
    return ret;
end asn1SccT_UsedUnusedState_IsConstraintValid;

function asn1SccT_UsedUnusedState_Init return asn1SccT_UsedUnusedState
is
    val: asn1SccT_UsedUnusedState;
begin
    val := asn1Sccunused;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_UsedUnusedState_Init;



function asn1SccT_MovingStillState_Equal (val1, val2 :  asn1SccT_MovingStillState) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_MovingStillState_Equal;

function asn1SccT_MovingStillState_IsConstraintValid(val : asn1SccT_MovingStillState) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccstationary)) OR ((val = asn1Sccmoving)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_MOVINGSTILLSTATE);
    return ret;
end asn1SccT_MovingStillState_IsConstraintValid;

function asn1SccT_MovingStillState_Init return asn1SccT_MovingStillState
is
    val: asn1SccT_MovingStillState;
begin
    val := asn1Sccstationary;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_MovingStillState_Init;



function asn1SccT_PlusMinusState_Equal (val1, val2 :  asn1SccT_PlusMinusState) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_PlusMinusState_Equal;

function asn1SccT_PlusMinusState_IsConstraintValid(val : asn1SccT_PlusMinusState) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccplus)) OR ((val = asn1Sccminus)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_PLUSMINUSSTATE);
    return ret;
end asn1SccT_PlusMinusState_IsConstraintValid;

function asn1SccT_PlusMinusState_Init return asn1SccT_PlusMinusState
is
    val: asn1SccT_PlusMinusState;
begin
    val := asn1Sccplus;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_PlusMinusState_Init;



function asn1SccT_ArmedDisarmedState_Equal (val1, val2 :  asn1SccT_ArmedDisarmedState) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_ArmedDisarmedState_Equal;

function asn1SccT_ArmedDisarmedState_IsConstraintValid(val : asn1SccT_ArmedDisarmedState) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccdisarmed)) OR ((val = asn1Sccarmed)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_ARMEDDISARMEDSTATE);
    return ret;
end asn1SccT_ArmedDisarmedState_IsConstraintValid;

function asn1SccT_ArmedDisarmedState_Init return asn1SccT_ArmedDisarmedState
is
    val: asn1SccT_ArmedDisarmedState;
begin
    val := asn1Sccdisarmed;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_ArmedDisarmedState_Init;



function asn1SccT_ActiveInactiveState_Equal (val1, val2 :  asn1SccT_ActiveInactiveState) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_ActiveInactiveState_Equal;

function asn1SccT_ActiveInactiveState_IsConstraintValid(val : asn1SccT_ActiveInactiveState) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccinactive)) OR ((val = asn1Sccactive)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_ACTIVEINACTIVESTATE);
    return ret;
end asn1SccT_ActiveInactiveState_IsConstraintValid;

function asn1SccT_ActiveInactiveState_Init return asn1SccT_ActiveInactiveState
is
    val: asn1SccT_ActiveInactiveState;
begin
    val := asn1Sccinactive;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_ActiveInactiveState_Init;



function asn1SccT_EnabledInhibitedState_Equal (val1, val2 :  asn1SccT_EnabledInhibitedState) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_EnabledInhibitedState_Equal;

function asn1SccT_EnabledInhibitedState_IsConstraintValid(val : asn1SccT_EnabledInhibitedState) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccinhibited)) OR ((val = asn1Sccenabled)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_ENABLEDINHIBITEDSTATE);
    return ret;
end asn1SccT_EnabledInhibitedState_IsConstraintValid;

function asn1SccT_EnabledInhibitedState_Init return asn1SccT_EnabledInhibitedState
is
    val: asn1SccT_EnabledInhibitedState;
begin
    val := asn1Sccinhibited;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_EnabledInhibitedState_Init;



function asn1SccT_FlagState_Equal (val1, val2 :  asn1SccT_FlagState) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_FlagState_Equal;

function asn1SccT_FlagState_IsConstraintValid(val : asn1SccT_FlagState) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccclear)) OR ((val = asn1Sccset)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_FLAGSTATE);
    return ret;
end asn1SccT_FlagState_IsConstraintValid;

function asn1SccT_FlagState_Init return asn1SccT_FlagState
is
    val: asn1SccT_FlagState;
begin
    val := asn1Sccclear;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_FlagState_Init;



function asn1SccT_SuccessFailState_Equal (val1, val2 :  asn1SccT_SuccessFailState) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_SuccessFailState_Equal;

function asn1SccT_SuccessFailState_IsConstraintValid(val : asn1SccT_SuccessFailState) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccfail)) OR ((val = asn1Sccsuccess)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_SUCCESSFAILSTATE);
    return ret;
end asn1SccT_SuccessFailState_IsConstraintValid;

function asn1SccT_SuccessFailState_Init return asn1SccT_SuccessFailState
is
    val: asn1SccT_SuccessFailState;
begin
    val := asn1Sccfail;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_SuccessFailState_Init;



function asn1SccT_HighLowState_Equal (val1, val2 :  asn1SccT_HighLowState) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_HighLowState_Equal;

function asn1SccT_HighLowState_IsConstraintValid(val : asn1SccT_HighLowState) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Scclow)) OR ((val = asn1Scchigh)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_HIGHLOWSTATE);
    return ret;
end asn1SccT_HighLowState_IsConstraintValid;

function asn1SccT_HighLowState_Init return asn1SccT_HighLowState
is
    val: asn1SccT_HighLowState;
begin
    val := asn1Scclow;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_HighLowState_Init;



function asn1SccT_OverrideState_Equal (val1, val2 :  asn1SccT_OverrideState) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_OverrideState_Equal;

function asn1SccT_OverrideState_IsConstraintValid(val : asn1SccT_OverrideState) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccnormal)) OR ((val = asn1Sccoverridden)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_OVERRIDESTATE);
    return ret;
end asn1SccT_OverrideState_IsConstraintValid;

function asn1SccT_OverrideState_Init return asn1SccT_OverrideState
is
    val: asn1SccT_OverrideState;
begin
    val := asn1Sccnormal;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_OverrideState_Init;



function asn1SccT_LockedUnlockedState_Equal (val1, val2 :  asn1SccT_LockedUnlockedState) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_LockedUnlockedState_Equal;

function asn1SccT_LockedUnlockedState_IsConstraintValid(val : asn1SccT_LockedUnlockedState) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccunlocked)) OR ((val = asn1Scclocked)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_LOCKEDUNLOCKEDSTATE);
    return ret;
end asn1SccT_LockedUnlockedState_IsConstraintValid;

function asn1SccT_LockedUnlockedState_Init return asn1SccT_LockedUnlockedState
is
    val: asn1SccT_LockedUnlockedState;
begin
    val := asn1Sccunlocked;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_LockedUnlockedState_Init;



function asn1SccT_WarningState_Equal (val1, val2 :  asn1SccT_WarningState) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_WarningState_Equal;

function asn1SccT_WarningState_IsConstraintValid(val : asn1SccT_WarningState) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccok)) OR ((val = asn1Sccwarning)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_WARNINGSTATE);
    return ret;
end asn1SccT_WarningState_IsConstraintValid;

function asn1SccT_WarningState_Init return asn1SccT_WarningState
is
    val: asn1SccT_WarningState;
begin
    val := asn1Sccok;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_WarningState_Init;



function asn1SccT_ValidInvalidState_Equal (val1, val2 :  asn1SccT_ValidInvalidState) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_ValidInvalidState_Equal;

function asn1SccT_ValidInvalidState_IsConstraintValid(val : asn1SccT_ValidInvalidState) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccinvalid)) OR ((val = asn1Sccvalid)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_VALIDINVALIDSTATE);
    return ret;
end asn1SccT_ValidInvalidState_IsConstraintValid;

function asn1SccT_ValidInvalidState_Init return asn1SccT_ValidInvalidState
is
    val: asn1SccT_ValidInvalidState;
begin
    val := asn1Sccinvalid;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_ValidInvalidState_Init;


pragma Warnings (On, "condition can only be False if invalid values present");
pragma Warnings (On, "condition can only be True if invalid values present");

 
end Bilevel_Types;