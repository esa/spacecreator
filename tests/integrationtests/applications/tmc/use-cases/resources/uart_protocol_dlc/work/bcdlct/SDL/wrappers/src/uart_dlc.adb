pragma Style_Checks (Off);
--  Code automatically generated by asn1scc tool
pragma Warnings (Off, "redundant with clause in body");

pragma Warnings (Off, "no entities of ""Basic_Types"" are referenced");
pragma Warnings (Off, "use clause for package ""Basic_Types"" has no effect");
pragma Warnings (Off, "unit ""Basic_Types"" is not referenced");
with Basic_Types;
pragma Warnings (On, "no entities of ""Basic_Types"" are referenced");
pragma Warnings (On, "use clause for package ""Basic_Types"" has no effect");
pragma Warnings (On, "unit ""Basic_Types"" is not referenced");

pragma Warnings (On, "redundant with clause in body");

pragma Warnings (Off, "use clause for type");
pragma Warnings (Off, "is already use-visible through previous use_type_clause at");
use type Basic_Types.asn1SccUINT8;
pragma Warnings (On, "use clause for type");
pragma Warnings (On, "is already use-visible through previous use_type_clause at");
package body UART_DLC with SPARK_Mode is



pragma Warnings (Off, "condition can only be False if invalid values present");
pragma Warnings (Off, "condition can only be True if invalid values present");


function asn1SccT_UART_DLC_Header_Equal (val1, val2 :  asn1SccT_UART_DLC_Header) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_UART_DLC_Header_Equal;

function asn1SccT_UART_DLC_Header_IsConstraintValid(val : asn1SccT_UART_DLC_Header) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := Basic_Types.asn1SccUINT8_IsConstraintValid(val);
    if ret.Success then
        ret.Success := (val = 22);
        ret.ErrorCode := (if ret.Success then 0 else ERR_T_UART_DLC_HEADER_2);
    end if;
    return ret;
end asn1SccT_UART_DLC_Header_IsConstraintValid;

function asn1SccT_UART_DLC_Header_Init return asn1SccT_UART_DLC_Header
is
    val: asn1SccT_UART_DLC_Header;
begin
    val := 22;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_UART_DLC_Header_Init;



function asn1SccT_UART_DLC_FrameCRC_Equal (val1, val2 :  asn1SccT_UART_DLC_FrameCRC) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_UART_DLC_FrameCRC_Equal;

function asn1SccT_UART_DLC_FrameCRC_IsConstraintValid(val : asn1SccT_UART_DLC_FrameCRC) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := Basic_Types.asn1SccUINT8_IsConstraintValid(val);
    return ret;
end asn1SccT_UART_DLC_FrameCRC_IsConstraintValid;

function asn1SccT_UART_DLC_FrameCRC_Init return asn1SccT_UART_DLC_FrameCRC
is
    val: asn1SccT_UART_DLC_FrameCRC;
begin
    val := Basic_Types.asn1SccUINT8_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_UART_DLC_FrameCRC_Init;



function asn1SccT_RMAPCRCTable_Equal (val1, val2 :  asn1SccT_RMAPCRCTable) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 256 loop
        --  pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end asn1SccT_RMAPCRCTable_Equal;

function asn1SccT_RMAPCRCTable_IsConstraintValid(val : asn1SccT_RMAPCRCTable) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
begin
    i1 := val.Data'First;
    while ret.Success and i1 <= 256 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 256);
        ret := Basic_Types.asn1SccUINT8_IsConstraintValid(val.Data(i1));
        i1 := i1+1;
    end loop;
    return ret;
end asn1SccT_RMAPCRCTable_IsConstraintValid;

function asn1SccT_RMAPCRCTable_Init return asn1SccT_RMAPCRCTable
is
    val: asn1SccT_RMAPCRCTable;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 256 loop
        --  commented because it casues this warning    
        --  warning: condition can only be False if invalid values present
        pragma Loop_Invariant (i1 >=1 and i1<=256);
        val.Data(i1) := Basic_Types.asn1SccUINT8_Init;
        i1 := i1 + 1;
    end loop;

	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_RMAPCRCTable_Init;



function asn1SccT_UART_DLC_FrameBuffer_Equal (val1, val2 :  asn1SccT_UART_DLC_FrameBuffer) return Boolean
is

begin
	return val1.Data = val2.Data;

end asn1SccT_UART_DLC_FrameBuffer_Equal;

function asn1SccT_UART_DLC_FrameBuffer_IsConstraintValid(val : asn1SccT_UART_DLC_FrameBuffer) return adaasn1rtl.ASN1_RESULT
is
    pragma Unreferenced (val);
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    return ret;
end asn1SccT_UART_DLC_FrameBuffer_IsConstraintValid;

function asn1SccT_UART_DLC_FrameBuffer_Init return asn1SccT_UART_DLC_FrameBuffer
is
    val: asn1SccT_UART_DLC_FrameBuffer;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 16 loop
        --  commented because it casues this warning    
        --  warning: condition can only be False if invalid values present
        pragma Loop_Invariant (i1 >=1 and i1<=16);
        val.Data(i1) := adaasn1rtl.Asn1Byte(0);
        i1 := i1 + 1;
    end loop;

	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_UART_DLC_FrameBuffer_Init;



function asn1SccT_UART_DLC_SDU_Equal (val1, val2 :  asn1SccT_UART_DLC_SDU) return Boolean
is

begin
	return val1.Data = val2.Data;

end asn1SccT_UART_DLC_SDU_Equal;

function asn1SccT_UART_DLC_SDU_IsConstraintValid(val : asn1SccT_UART_DLC_SDU) return adaasn1rtl.ASN1_RESULT
is
    pragma Unreferenced (val);
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    return ret;
end asn1SccT_UART_DLC_SDU_IsConstraintValid;

function asn1SccT_UART_DLC_SDU_Init return asn1SccT_UART_DLC_SDU
is
    val: asn1SccT_UART_DLC_SDU;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 14 loop
        --  commented because it casues this warning    
        --  warning: condition can only be False if invalid values present
        pragma Loop_Invariant (i1 >=1 and i1<=14);
        val.Data(i1) := adaasn1rtl.Asn1Byte(0);
        i1 := i1 + 1;
    end loop;

	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_UART_DLC_SDU_Init;



function asn1SccT_UART_DLC_PDU_Equal (val1, val2 :  asn1SccT_UART_DLC_PDU) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (val1.dlc_header = val2.dlc_header);

    if ret then
        ret := asn1SccT_UART_DLC_SDU_Equal(val1.dlc_payload, val2.dlc_payload);

        if ret then
            ret := (val1.crc = val2.crc);

        end if;
    end if;
	return ret;

end asn1SccT_UART_DLC_PDU_Equal;

function asn1SccT_UART_DLC_PDU_IsConstraintValid(val : asn1SccT_UART_DLC_PDU) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := asn1SccUINT8_IsConstraintValid(val.dlc_header);
    if ret.Success then
        ret := asn1SccT_UART_DLC_SDU_IsConstraintValid(val.dlc_payload);
        if ret.Success then
            ret := asn1SccUINT8_IsConstraintValid(val.crc);
        end if;
    end if;
    return ret;
end asn1SccT_UART_DLC_PDU_IsConstraintValid;

function asn1SccT_UART_DLC_PDU_Init return asn1SccT_UART_DLC_PDU
is
    val: asn1SccT_UART_DLC_PDU;
begin

    --set dlc_header 
    val.dlc_header := asn1SccT_UART_DLC_Header_Init;
    --set dlc_payload 
    val.dlc_payload := asn1SccT_UART_DLC_SDU_Init;
    --set crc 
    val.crc := Basic_Types.asn1SccUINT8_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_UART_DLC_PDU_Init;



function asn1SccT_UART_DLC_RxErrorCode_Equal (val1, val2 :  asn1SccT_UART_DLC_RxErrorCode) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_UART_DLC_RxErrorCode_Equal;

function asn1SccT_UART_DLC_RxErrorCode_IsConstraintValid(val : asn1SccT_UART_DLC_RxErrorCode) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((((((((val = asn1Sccno_error)) OR ((val = asn1Sccbad_start_char)))) OR ((val = asn1Scccrc_fail)))) OR ((val = asn1Sccframe_timeout)))) OR ((val = asn1Sccbad_request_type)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_UART_DLC_RXERRORCODE);
    return ret;
end asn1SccT_UART_DLC_RxErrorCode_IsConstraintValid;

function asn1SccT_UART_DLC_RxErrorCode_Init return asn1SccT_UART_DLC_RxErrorCode
is
    val: asn1SccT_UART_DLC_RxErrorCode;
begin
    val := asn1Sccno_error;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_UART_DLC_RxErrorCode_Init;


pragma Warnings (On, "condition can only be False if invalid values present");
pragma Warnings (On, "condition can only be True if invalid values present");

 
end UART_DLC;