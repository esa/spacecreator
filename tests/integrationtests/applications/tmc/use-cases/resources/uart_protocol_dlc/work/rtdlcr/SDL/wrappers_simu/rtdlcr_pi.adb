-- DO NOT EDIT THIS FILE, IT WILL BE OVERWRITTEN DURING THE BUILD
-- (Generated by TASTE/Kazoo - $TOOL_SRC/kazoo/templates/glue/language_wrappers/simu_pi_adb/function.tmplt)
with demo_Timer_Manager;
with demo_Timer_Manager;
package body Rtdlcr_PI is

   procedure Update_States_For_Synchronous_Calls (Global_State : asn1SccSystem_State) is
   begin
      demo_Timer_Manager.Ctxt := Global_State.demo_Timer_Manager;
      demo_Timer_Manager.Ctxt := Global_State.demo_Timer_Manager;
   end Update_States_For_Synchronous_Calls;

   procedure Update_Global_State_After_Synchronous_Calls (Global_State : in out asn1SccSystem_State)  is
   begin
      Global_State.demo_Timer_Manager := demo_Timer_Manager.Ctxt;
      Global_State.demo_Timer_Manager := demo_Timer_Manager.Ctxt;
   end Update_Global_State_After_Synchronous_Calls;

   procedure Startup (Global_State : in out asn1SccSystem_State) is
   begin
      --  Initialize the global state after startup function has run
      Global_State.Rtdlcr := Rtdlcr.Ctxt;
   end Startup;

   procedure Continuous_Signals (Global_State : in out asn1SccSystem_State) is
   begin
      Rtdlcr.Ctxt := Global_State.Rtdlcr;
      Rtdlcr.Execute_Transition (Rtdlcr.CS_Only);
      Global_State.Rtdlcr := Rtdlcr.Ctxt;
   end Continuous_Signals;

   --  Provided interfaces
   procedure Dlcrxreset (Global_State : in out asn1SccSystem_State) is
   begin
      -- Set the current context (provided by the simulation API)
      Rtdlcr.Ctxt := Global_State.Rtdlcr;
      --  If user code calls synchronous RIs, set their state too
      Update_States_For_Synchronous_Calls (Global_State);
      Rtdlcr.Dlcrxreset;
      -- Update the global state
      Global_State.Rtdlcr := Rtdlcr.Ctxt;
      --  If user code called synchronous RIs, populate their state
      Update_Global_State_After_Synchronous_Calls (Global_State);
   end Dlcrxreset;
   
   
   procedure Frametimer (Global_State : in out asn1SccSystem_State) is
   begin
      -- Set the current context (provided by the simulation API)
      Rtdlcr.Ctxt := Global_State.Rtdlcr;
      --  If user code calls synchronous RIs, set their state too
      Update_States_For_Synchronous_Calls (Global_State);
      Rtdlcr.Frametimer;
      -- Update the global state
      Global_State.Rtdlcr := Rtdlcr.Ctxt;
      --  If user code called synchronous RIs, populate their state
      Update_Global_State_After_Synchronous_Calls (Global_State);
   end Frametimer;
   
   
   procedure Phyrxchar
      (Global_State : in out asn1SccSystem_State;
      P1 : in out asn1SccUint8) is
   begin
      -- Set the current context (provided by the simulation API)
      Rtdlcr.Ctxt := Global_State.Rtdlcr;
      --  If user code calls synchronous RIs, set their state too
      Update_States_For_Synchronous_Calls (Global_State);
      Rtdlcr.Phyrxchar
         (P1 => P1);
      -- Update the global state
      Global_State.Rtdlcr := Rtdlcr.Ctxt;
      --  If user code called synchronous RIs, populate their state
      Update_Global_State_After_Synchronous_Calls (Global_State);
   end Phyrxchar;
   
   
   procedure Phyrxerror (Global_State : in out asn1SccSystem_State) is
   begin
      -- Set the current context (provided by the simulation API)
      Rtdlcr.Ctxt := Global_State.Rtdlcr;
      --  If user code calls synchronous RIs, set their state too
      Update_States_For_Synchronous_Calls (Global_State);
      Rtdlcr.Phyrxerror;
      -- Update the global state
      Global_State.Rtdlcr := Rtdlcr.Ctxt;
      --  If user code called synchronous RIs, populate their state
      Update_Global_State_After_Synchronous_Calls (Global_State);
   end Phyrxerror;

end Rtdlcr_PI;
