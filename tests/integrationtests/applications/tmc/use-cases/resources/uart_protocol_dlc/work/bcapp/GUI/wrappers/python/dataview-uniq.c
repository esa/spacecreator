/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>

#include "asn1crt_encoding.h"
#include "asn1crt_encoding_uper.h"
#include "asn1crt_encoding_acn.h"

#include "dataview-uniq.h"


const UINT8 c_UART_DLC_SDU_SIZE = 14;
const UINT8 c_UART_DLC_PDU_SIZE = 16;
const UINT8 c_UART_DLC_SYNC_VALUE = 22;
const T_RMAPCRCTable c_RMAPCRCTable = {    .arr = 
    {
        0,
        7,
        14,
        9,
        28,
        27,
        18,
        21,
        56,
        63,
        54,
        49,
        36,
        35,
        42,
        45,
        112,
        119,
        126,
        121,
        108,
        107,
        98,
        101,
        72,
        79,
        70,
        65,
        84,
        83,
        90,
        93,
        224,
        231,
        238,
        233,
        252,
        251,
        242,
        245,
        216,
        223,
        214,
        209,
        196,
        195,
        202,
        205,
        144,
        151,
        158,
        153,
        140,
        139,
        130,
        133,
        168,
        175,
        166,
        161,
        180,
        179,
        186,
        189,
        199,
        192,
        201,
        206,
        219,
        220,
        213,
        210,
        255,
        248,
        241,
        246,
        227,
        228,
        237,
        234,
        183,
        176,
        185,
        190,
        171,
        172,
        165,
        162,
        143,
        136,
        129,
        134,
        147,
        148,
        157,
        154,
        39,
        32,
        41,
        46,
        59,
        60,
        53,
        50,
        31,
        24,
        17,
        22,
        3,
        4,
        13,
        10,
        87,
        80,
        89,
        94,
        75,
        76,
        69,
        66,
        111,
        104,
        97,
        102,
        115,
        116,
        125,
        122,
        137,
        142,
        135,
        128,
        149,
        146,
        155,
        156,
        177,
        182,
        191,
        184,
        173,
        170,
        163,
        164,
        249,
        254,
        247,
        240,
        229,
        226,
        235,
        236,
        193,
        198,
        207,
        200,
        221,
        218,
        211,
        212,
        105,
        110,
        103,
        96,
        117,
        114,
        123,
        124,
        81,
        86,
        95,
        88,
        77,
        74,
        67,
        68,
        25,
        30,
        23,
        16,
        5,
        2,
        11,
        12,
        33,
        38,
        47,
        40,
        61,
        58,
        51,
        52,
        78,
        73,
        64,
        71,
        82,
        85,
        92,
        91,
        118,
        113,
        120,
        127,
        106,
        109,
        100,
        99,
        62,
        57,
        48,
        55,
        34,
        37,
        44,
        43,
        6,
        1,
        8,
        15,
        26,
        29,
        20,
        19,
        174,
        169,
        160,
        167,
        178,
        181,
        188,
        187,
        150,
        145,
        152,
        159,
        138,
        141,
        132,
        131,
        222,
        217,
        208,
        215,
        194,
        197,
        204,
        203,
        230,
        225,
        232,
        239,
        250,
        253,
        244,
        243        
    }
};


flag UINT40_Equal(const UINT40* pVal1, const UINT40* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag UINT40_IsConstraintValid(const UINT40* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 1099511627775UL);
    *pErrCode = ret ? 0 :  ERR_UINT40; 

	return ret;
}

void UINT40_Initialize(UINT40* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag UINT40_Encode(const UINT40* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? UINT40_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 1099511627775LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT40_Decode(UINT40* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 1099511627775LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_UINT40;

	return ret  && UINT40_IsConstraintValid(pVal, pErrCode);
}

flag UINT40_ACN_Encode(const UINT40* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? UINT40_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 1099511627775LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT40_ACN_Decode(UINT40* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 1099511627775LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_UINT40;

    return ret && UINT40_IsConstraintValid(pVal, pErrCode);
}



flag UINT32_Equal(const UINT32* pVal1, const UINT32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag UINT32_IsConstraintValid(const UINT32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_UINT32; 

	return ret;
}

void UINT32_Initialize(UINT32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag UINT32_Encode(const UINT32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? UINT32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT32_Decode(UINT32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_UINT32;

	return ret  && UINT32_IsConstraintValid(pVal, pErrCode);
}

flag UINT32_ACN_Encode(const UINT32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? UINT32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT32_ACN_Decode(UINT32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_UINT32;

    return ret && UINT32_IsConstraintValid(pVal, pErrCode);
}



flag UINT24_Equal(const UINT24* pVal1, const UINT24* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag UINT24_IsConstraintValid(const UINT24* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 16777215UL);
    *pErrCode = ret ? 0 :  ERR_UINT24; 

	return ret;
}

void UINT24_Initialize(UINT24* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag UINT24_Encode(const UINT24* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? UINT24_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 16777215);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT24_Decode(UINT24* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 16777215);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_UINT24;

	return ret  && UINT24_IsConstraintValid(pVal, pErrCode);
}

flag UINT24_ACN_Encode(const UINT24* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? UINT24_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 16777215);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT24_ACN_Decode(UINT24* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 16777215);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_UINT24;

    return ret && UINT24_IsConstraintValid(pVal, pErrCode);
}



flag UINT16_Equal(const UINT16* pVal1, const UINT16* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag UINT16_IsConstraintValid(const UINT16* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 65535UL);
    *pErrCode = ret ? 0 :  ERR_UINT16; 

	return ret;
}

void UINT16_Initialize(UINT16* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag UINT16_Encode(const UINT16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? UINT16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 65535);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT16_Decode(UINT16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_UINT16;

	return ret  && UINT16_IsConstraintValid(pVal, pErrCode);
}

flag UINT16_ACN_Encode(const UINT16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? UINT16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 65535);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT16_ACN_Decode(UINT16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_UINT16;

    return ret && UINT16_IsConstraintValid(pVal, pErrCode);
}



flag UINT14_Equal(const UINT14* pVal1, const UINT14* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag UINT14_IsConstraintValid(const UINT14* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 16383UL);
    *pErrCode = ret ? 0 :  ERR_UINT14; 

	return ret;
}

void UINT14_Initialize(UINT14* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag UINT14_Encode(const UINT14* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? UINT14_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 16383);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT14_Decode(UINT14* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 16383);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_UINT14;

	return ret  && UINT14_IsConstraintValid(pVal, pErrCode);
}

flag UINT14_ACN_Encode(const UINT14* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? UINT14_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 16383);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT14_ACN_Decode(UINT14* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 16383);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_UINT14;

    return ret && UINT14_IsConstraintValid(pVal, pErrCode);
}



flag UINT12_Equal(const UINT12* pVal1, const UINT12* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag UINT12_IsConstraintValid(const UINT12* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4095UL);
    *pErrCode = ret ? 0 :  ERR_UINT12; 

	return ret;
}

void UINT12_Initialize(UINT12* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag UINT12_Encode(const UINT12* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? UINT12_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4095);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT12_Decode(UINT12* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4095);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_UINT12;

	return ret  && UINT12_IsConstraintValid(pVal, pErrCode);
}

flag UINT12_ACN_Encode(const UINT12* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? UINT12_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4095);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT12_ACN_Decode(UINT12* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4095);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_UINT12;

    return ret && UINT12_IsConstraintValid(pVal, pErrCode);
}



flag UINT11_Equal(const UINT11* pVal1, const UINT11* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag UINT11_IsConstraintValid(const UINT11* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 2047UL);
    *pErrCode = ret ? 0 :  ERR_UINT11; 

	return ret;
}

void UINT11_Initialize(UINT11* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag UINT11_Encode(const UINT11* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? UINT11_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 2047);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT11_Decode(UINT11* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 2047);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_UINT11;

	return ret  && UINT11_IsConstraintValid(pVal, pErrCode);
}

flag UINT11_ACN_Encode(const UINT11* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? UINT11_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 2047);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT11_ACN_Decode(UINT11* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 2047);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_UINT11;

    return ret && UINT11_IsConstraintValid(pVal, pErrCode);
}



flag UINT10_Equal(const UINT10* pVal1, const UINT10* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag UINT10_IsConstraintValid(const UINT10* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 1023UL);
    *pErrCode = ret ? 0 :  ERR_UINT10; 

	return ret;
}

void UINT10_Initialize(UINT10* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag UINT10_Encode(const UINT10* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? UINT10_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 1023);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT10_Decode(UINT10* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 1023);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_UINT10;

	return ret  && UINT10_IsConstraintValid(pVal, pErrCode);
}

flag UINT10_ACN_Encode(const UINT10* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? UINT10_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 1023);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT10_ACN_Decode(UINT10* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 1023);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_UINT10;

    return ret && UINT10_IsConstraintValid(pVal, pErrCode);
}



flag UINT8_Equal(const UINT8* pVal1, const UINT8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag UINT8_IsConstraintValid(const UINT8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_UINT8; 

	return ret;
}

void UINT8_Initialize(UINT8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag UINT8_Encode(const UINT8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? UINT8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT8_Decode(UINT8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_UINT8;

	return ret  && UINT8_IsConstraintValid(pVal, pErrCode);
}

flag UINT8_ACN_Encode(const UINT8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? UINT8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT8_ACN_Decode(UINT8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_UINT8;

    return ret && UINT8_IsConstraintValid(pVal, pErrCode);
}



flag T_UART_DLC_Header_Equal(const T_UART_DLC_Header* pVal1, const T_UART_DLC_Header* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_UART_DLC_Header_IsConstraintValid(const T_UART_DLC_Header* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = UINT8_IsConstraintValid(pVal, pErrCode);
    if (ret) {
        ret = ((*(pVal)) == 22UL);
        *pErrCode = ret ? 0 :  ERR_T_UART_DLC_HEADER_2; 
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void T_UART_DLC_Header_Initialize(T_UART_DLC_Header* pVal)
{
	(void)pVal;


	(*(pVal)) = 22;
}

flag T_UART_DLC_Header_Encode(const T_UART_DLC_Header* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_UART_DLC_Header_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /* No need to encode value since it will always be 22 */
	    (void)pBitStrm;
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UART_DLC_Header_Decode(T_UART_DLC_Header* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;
	(void)pVal;
	(void)pBitStrm;


	(*(pVal))=22; 
	(void)pBitStrm;
	ret = TRUE; 
	*pErrCode = 0;

	return ret  && T_UART_DLC_Header_IsConstraintValid(pVal, pErrCode);
}

flag T_UART_DLC_Header_ACN_Encode(const T_UART_DLC_Header* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_UART_DLC_Header_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /* No need to encode value since it will always be 22 */
	    (void)pBitStrm;
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UART_DLC_Header_ACN_Decode(T_UART_DLC_Header* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
	(void)pBitStrm;
	*pErrCode = 0;


	(*(pVal))=22; 
	(void)pBitStrm;
	ret = TRUE; 
	*pErrCode = 0;

    return ret && T_UART_DLC_Header_IsConstraintValid(pVal, pErrCode);
}



flag T_UART_DLC_FrameCRC_Equal(const T_UART_DLC_FrameCRC* pVal1, const T_UART_DLC_FrameCRC* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_UART_DLC_FrameCRC_IsConstraintValid(const T_UART_DLC_FrameCRC* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = UINT8_IsConstraintValid(pVal, pErrCode);

	return ret;
}

void T_UART_DLC_FrameCRC_Initialize(T_UART_DLC_FrameCRC* pVal)
{
	(void)pVal;


	UINT8_Initialize(pVal);
}

flag T_UART_DLC_FrameCRC_Encode(const T_UART_DLC_FrameCRC* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_UART_DLC_FrameCRC_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = UINT8_Encode(pVal, pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UART_DLC_FrameCRC_Decode(T_UART_DLC_FrameCRC* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = UINT8_Decode(pVal, pBitStrm, pErrCode);

	return ret  && T_UART_DLC_FrameCRC_IsConstraintValid(pVal, pErrCode);
}

flag T_UART_DLC_FrameCRC_ACN_Encode(const T_UART_DLC_FrameCRC* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_UART_DLC_FrameCRC_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = UINT8_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UART_DLC_FrameCRC_ACN_Decode(T_UART_DLC_FrameCRC* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = UINT8_ACN_Decode(pVal, pBitStrm, pErrCode);

    return ret && T_UART_DLC_FrameCRC_IsConstraintValid(pVal, pErrCode);
}



flag T_RMAPCRCTable_Equal(const T_RMAPCRCTable* pVal1, const T_RMAPCRCTable* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 256; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

flag T_RMAPCRCTable_IsConstraintValid(const T_RMAPCRCTable* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 256; i1++) 
    {
    	ret = UINT8_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

void T_RMAPCRCTable_Initialize(T_RMAPCRCTable* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 256) {
	    UINT8_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag T_RMAPCRCTable_Encode(const T_RMAPCRCTable* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	*pErrCode = 0;
	ret = bCheckConstraints ? T_RMAPCRCTable_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    	
	    for(i1=0; (i1 < (int)256) && ret; i1++) 
	    {
	    	ret = UINT8_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_RMAPCRCTable_Decode(T_RMAPCRCTable* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)256) && ret; i1++) 
	{
		ret = UINT8_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && T_RMAPCRCTable_IsConstraintValid(pVal, pErrCode);
}

flag T_RMAPCRCTable_ACN_Encode(const T_RMAPCRCTable* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_RMAPCRCTable_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    	
	    for(i1=0; (i1 < (int)256) && ret; i1++) 
	    {
	    	ret = UINT8_ACN_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_RMAPCRCTable_ACN_Decode(T_RMAPCRCTable* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)256) && ret; i1++) 
	{
		ret = UINT8_ACN_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

    return ret && T_RMAPCRCTable_IsConstraintValid(pVal, pErrCode);
}



flag UINT7_Equal(const UINT7* pVal1, const UINT7* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag UINT7_IsConstraintValid(const UINT7* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 127UL);
    *pErrCode = ret ? 0 :  ERR_UINT7; 

	return ret;
}

void UINT7_Initialize(UINT7* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag UINT7_Encode(const UINT7* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? UINT7_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT7_Decode(UINT7* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 127);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_UINT7;

	return ret  && UINT7_IsConstraintValid(pVal, pErrCode);
}

flag UINT7_ACN_Encode(const UINT7* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? UINT7_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT7_ACN_Decode(UINT7* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 127);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_UINT7;

    return ret && UINT7_IsConstraintValid(pVal, pErrCode);
}



flag UINT6_Equal(const UINT6* pVal1, const UINT6* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag UINT6_IsConstraintValid(const UINT6* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 63UL);
    *pErrCode = ret ? 0 :  ERR_UINT6; 

	return ret;
}

void UINT6_Initialize(UINT6* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag UINT6_Encode(const UINT6* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? UINT6_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 63);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT6_Decode(UINT6* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 63);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_UINT6;

	return ret  && UINT6_IsConstraintValid(pVal, pErrCode);
}

flag UINT6_ACN_Encode(const UINT6* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? UINT6_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 63);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT6_ACN_Decode(UINT6* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 63);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_UINT6;

    return ret && UINT6_IsConstraintValid(pVal, pErrCode);
}



flag UINT5_Equal(const UINT5* pVal1, const UINT5* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag UINT5_IsConstraintValid(const UINT5* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 31UL);
    *pErrCode = ret ? 0 :  ERR_UINT5; 

	return ret;
}

void UINT5_Initialize(UINT5* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag UINT5_Encode(const UINT5* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? UINT5_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 31);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT5_Decode(UINT5* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 31);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_UINT5;

	return ret  && UINT5_IsConstraintValid(pVal, pErrCode);
}

flag UINT5_ACN_Encode(const UINT5* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? UINT5_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 31);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT5_ACN_Decode(UINT5* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 31);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_UINT5;

    return ret && UINT5_IsConstraintValid(pVal, pErrCode);
}



flag UINT4_Equal(const UINT4* pVal1, const UINT4* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag UINT4_IsConstraintValid(const UINT4* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 15UL);
    *pErrCode = ret ? 0 :  ERR_UINT4; 

	return ret;
}

void UINT4_Initialize(UINT4* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag UINT4_Encode(const UINT4* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? UINT4_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 15);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT4_Decode(UINT4* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 15);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_UINT4;

	return ret  && UINT4_IsConstraintValid(pVal, pErrCode);
}

flag UINT4_ACN_Encode(const UINT4* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? UINT4_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 15);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT4_ACN_Decode(UINT4* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 15);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_UINT4;

    return ret && UINT4_IsConstraintValid(pVal, pErrCode);
}



flag UINT3_Equal(const UINT3* pVal1, const UINT3* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag UINT3_IsConstraintValid(const UINT3* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 7UL);
    *pErrCode = ret ? 0 :  ERR_UINT3; 

	return ret;
}

void UINT3_Initialize(UINT3* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag UINT3_Encode(const UINT3* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? UINT3_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 7);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT3_Decode(UINT3* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 7);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_UINT3;

	return ret  && UINT3_IsConstraintValid(pVal, pErrCode);
}

flag UINT3_ACN_Encode(const UINT3* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? UINT3_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 7);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT3_ACN_Decode(UINT3* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 7);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_UINT3;

    return ret && UINT3_IsConstraintValid(pVal, pErrCode);
}



flag UINT2_Equal(const UINT2* pVal1, const UINT2* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag UINT2_IsConstraintValid(const UINT2* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 3UL);
    *pErrCode = ret ? 0 :  ERR_UINT2; 

	return ret;
}

void UINT2_Initialize(UINT2* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag UINT2_Encode(const UINT2* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? UINT2_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 3);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT2_Decode(UINT2* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 3);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_UINT2;

	return ret  && UINT2_IsConstraintValid(pVal, pErrCode);
}

flag UINT2_ACN_Encode(const UINT2* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? UINT2_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 3);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT2_ACN_Decode(UINT2* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_UINT2;

    return ret && UINT2_IsConstraintValid(pVal, pErrCode);
}



flag UINT1_Equal(const UINT1* pVal1, const UINT1* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag UINT1_IsConstraintValid(const UINT1* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 1UL);
    *pErrCode = ret ? 0 :  ERR_UINT1; 

	return ret;
}

void UINT1_Initialize(UINT1* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag UINT1_Encode(const UINT1* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? UINT1_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 1);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT1_Decode(UINT1* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 1);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_UINT1;

	return ret  && UINT1_IsConstraintValid(pVal, pErrCode);
}

flag UINT1_ACN_Encode(const UINT1* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? UINT1_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 1);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag UINT1_ACN_Decode(UINT1* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_UINT1;

    return ret && UINT1_IsConstraintValid(pVal, pErrCode);
}



flag T_Bit_Equal(const T_Bit* pVal1, const T_Bit* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_Bit_IsConstraintValid(const T_Bit* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = UINT1_IsConstraintValid(pVal, pErrCode);

	return ret;
}

void T_Bit_Initialize(T_Bit* pVal)
{
	(void)pVal;


	UINT1_Initialize(pVal);
}

flag T_Bit_Encode(const T_Bit* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_Bit_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = UINT1_Encode(pVal, pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Bit_Decode(T_Bit* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = UINT1_Decode(pVal, pBitStrm, pErrCode);

	return ret  && T_Bit_IsConstraintValid(pVal, pErrCode);
}

flag T_Bit_ACN_Encode(const T_Bit* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_Bit_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = UINT1_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Bit_ACN_Decode(T_Bit* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = UINT1_ACN_Decode(pVal, pBitStrm, pErrCode);

    return ret && T_Bit_IsConstraintValid(pVal, pErrCode);
}



flag INT16_Equal(const INT16* pVal1, const INT16* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag INT16_IsConstraintValid(const INT16* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-32768LL <= (*(pVal))) && ((*(pVal)) <= 32767LL));
    *pErrCode = ret ? 0 :  ERR_INT16; 

	return ret;
}

void INT16_Initialize(INT16* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag INT16_Encode(const INT16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? INT16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -32768, 32767);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag INT16_Decode(INT16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -32768, 32767);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_INT16;

	return ret  && INT16_IsConstraintValid(pVal, pErrCode);
}

flag INT16_ACN_Encode(const INT16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? INT16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -32768, 32767);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag INT16_ACN_Decode(INT16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -32768, 32767);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_INT16;

    return ret && INT16_IsConstraintValid(pVal, pErrCode);
}



flag INT32_Equal(const INT32* pVal1, const INT32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag INT32_IsConstraintValid(const INT32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-2147483648LL <= (*(pVal))) && ((*(pVal)) <= 2147483647LL));
    *pErrCode = ret ? 0 :  ERR_INT32; 

	return ret;
}

void INT32_Initialize(INT32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag INT32_Encode(const INT32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? INT32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag INT32_Decode(INT32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_INT32;

	return ret  && INT32_IsConstraintValid(pVal, pErrCode);
}

flag INT32_ACN_Encode(const INT32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? INT32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag INT32_ACN_Decode(INT32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_INT32;

    return ret && INT32_IsConstraintValid(pVal, pErrCode);
}



flag INT24_Equal(const INT24* pVal1, const INT24* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag INT24_IsConstraintValid(const INT24* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-8388608LL <= (*(pVal))) && ((*(pVal)) <= 8388607LL));
    *pErrCode = ret ? 0 :  ERR_INT24; 

	return ret;
}

void INT24_Initialize(INT24* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag INT24_Encode(const INT24* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? INT24_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -8388608, 8388607);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag INT24_Decode(INT24* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -8388608, 8388607);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_INT24;

	return ret  && INT24_IsConstraintValid(pVal, pErrCode);
}

flag INT24_ACN_Encode(const INT24* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? INT24_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -8388608, 8388607);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag INT24_ACN_Decode(INT24* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -8388608, 8388607);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_INT24;

    return ret && INT24_IsConstraintValid(pVal, pErrCode);
}



flag T_OCTET_Equal(const T_OCTET* pVal1, const T_OCTET* pVal2)
{
	return memcmp(pVal1->arr, pVal2->arr, 1) ==0	;

}

flag T_OCTET_IsConstraintValid(const T_OCTET* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

void T_OCTET_Initialize(T_OCTET* pVal)
{
	(void)pVal;


	memset(pVal->arr, 0x0, 1);


}

flag T_OCTET_Encode(const T_OCTET* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_OCTET_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, 1);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_OCTET_Decode(T_OCTET* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, 1);

	return ret  && T_OCTET_IsConstraintValid(pVal, pErrCode);
}

flag T_OCTET_ACN_Encode(const T_OCTET* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_OCTET_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, 1);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_OCTET_ACN_Decode(T_OCTET* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, 1);

    return ret && T_OCTET_IsConstraintValid(pVal, pErrCode);
}



flag T_OnOffState_Equal(const T_OnOffState* pVal1, const T_OnOffState* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_OnOffState_IsConstraintValid(const T_OnOffState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == T_OnOffState_off)) || (((*(pVal)) == T_OnOffState_on)));
    *pErrCode = ret ? 0 :  ERR_T_ONOFFSTATE; 

	return ret;
}

void T_OnOffState_Initialize(T_OnOffState* pVal)
{
	(void)pVal;


	(*(pVal)) = T_OnOffState_off;
}

flag T_OnOffState_Encode(const T_OnOffState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_OnOffState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case T_OnOffState_off:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case T_OnOffState_on:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_T_ONOFFSTATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_OnOffState_Decode(T_OnOffState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_T_ONOFFSTATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = T_OnOffState_off;
	                break;
	            case 1: 
	                (*(pVal)) = T_OnOffState_on;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_T_ONOFFSTATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = T_OnOffState_off;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && T_OnOffState_IsConstraintValid(pVal, pErrCode);
}

flag T_OnOffState_ACN_Encode(const T_OnOffState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_OnOffState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case T_OnOffState_off:
	            uIntVal = 0;
	            break;
	        case T_OnOffState_on:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_T_ONOFFSTATE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_OnOffState_ACN_Decode(T_OnOffState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_ONOFFSTATE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = T_OnOffState_off;
	            break;
	        case 1:
	            (*(pVal)) = T_OnOffState_on;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_T_ONOFFSTATE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && T_OnOffState_IsConstraintValid(pVal, pErrCode);
}



flag T_NominalRedundantState_Equal(const T_NominalRedundantState* pVal1, const T_NominalRedundantState* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_NominalRedundantState_IsConstraintValid(const T_NominalRedundantState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == T_NominalRedundantState_redundant)) || (((*(pVal)) == T_NominalRedundantState_nominal)));
    *pErrCode = ret ? 0 :  ERR_T_NOMINALREDUNDANTSTATE; 

	return ret;
}

void T_NominalRedundantState_Initialize(T_NominalRedundantState* pVal)
{
	(void)pVal;


	(*(pVal)) = T_NominalRedundantState_redundant;
}

flag T_NominalRedundantState_Encode(const T_NominalRedundantState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_NominalRedundantState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case T_NominalRedundantState_redundant:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case T_NominalRedundantState_nominal:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_T_NOMINALREDUNDANTSTATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_NominalRedundantState_Decode(T_NominalRedundantState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_T_NOMINALREDUNDANTSTATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = T_NominalRedundantState_redundant;
	                break;
	            case 1: 
	                (*(pVal)) = T_NominalRedundantState_nominal;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_T_NOMINALREDUNDANTSTATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = T_NominalRedundantState_redundant;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && T_NominalRedundantState_IsConstraintValid(pVal, pErrCode);
}

flag T_NominalRedundantState_ACN_Encode(const T_NominalRedundantState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_NominalRedundantState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case T_NominalRedundantState_redundant:
	            uIntVal = 0;
	            break;
	        case T_NominalRedundantState_nominal:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_T_NOMINALREDUNDANTSTATE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_NominalRedundantState_ACN_Decode(T_NominalRedundantState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_NOMINALREDUNDANTSTATE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = T_NominalRedundantState_redundant;
	            break;
	        case 1:
	            (*(pVal)) = T_NominalRedundantState_nominal;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_T_NOMINALREDUNDANTSTATE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && T_NominalRedundantState_IsConstraintValid(pVal, pErrCode);
}



flag T_ConnectionState_Equal(const T_ConnectionState* pVal1, const T_ConnectionState* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_ConnectionState_IsConstraintValid(const T_ConnectionState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == T_ConnectionState_disconnected)) || (((*(pVal)) == T_ConnectionState_connected)));
    *pErrCode = ret ? 0 :  ERR_T_CONNECTIONSTATE; 

	return ret;
}

void T_ConnectionState_Initialize(T_ConnectionState* pVal)
{
	(void)pVal;


	(*(pVal)) = T_ConnectionState_disconnected;
}

flag T_ConnectionState_Encode(const T_ConnectionState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_ConnectionState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case T_ConnectionState_disconnected:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case T_ConnectionState_connected:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_T_CONNECTIONSTATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_ConnectionState_Decode(T_ConnectionState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_T_CONNECTIONSTATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = T_ConnectionState_disconnected;
	                break;
	            case 1: 
	                (*(pVal)) = T_ConnectionState_connected;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_T_CONNECTIONSTATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = T_ConnectionState_disconnected;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && T_ConnectionState_IsConstraintValid(pVal, pErrCode);
}

flag T_ConnectionState_ACN_Encode(const T_ConnectionState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_ConnectionState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case T_ConnectionState_disconnected:
	            uIntVal = 0;
	            break;
	        case T_ConnectionState_connected:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_T_CONNECTIONSTATE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_ConnectionState_ACN_Decode(T_ConnectionState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_CONNECTIONSTATE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = T_ConnectionState_disconnected;
	            break;
	        case 1:
	            (*(pVal)) = T_ConnectionState_connected;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_T_CONNECTIONSTATE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && T_ConnectionState_IsConstraintValid(pVal, pErrCode);
}



flag T_SwitchState_Equal(const T_SwitchState* pVal1, const T_SwitchState* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_SwitchState_IsConstraintValid(const T_SwitchState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == T_SwitchState_switch_open)) || (((*(pVal)) == T_SwitchState_switch_closed)));
    *pErrCode = ret ? 0 :  ERR_T_SWITCHSTATE; 

	return ret;
}

void T_SwitchState_Initialize(T_SwitchState* pVal)
{
	(void)pVal;


	(*(pVal)) = T_SwitchState_switch_open;
}

flag T_SwitchState_Encode(const T_SwitchState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_SwitchState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case T_SwitchState_switch_open:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case T_SwitchState_switch_closed:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_T_SWITCHSTATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_SwitchState_Decode(T_SwitchState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_T_SWITCHSTATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = T_SwitchState_switch_open;
	                break;
	            case 1: 
	                (*(pVal)) = T_SwitchState_switch_closed;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_T_SWITCHSTATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = T_SwitchState_switch_open;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && T_SwitchState_IsConstraintValid(pVal, pErrCode);
}

flag T_SwitchState_ACN_Encode(const T_SwitchState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_SwitchState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case T_SwitchState_switch_open:
	            uIntVal = 0;
	            break;
	        case T_SwitchState_switch_closed:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_T_SWITCHSTATE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_SwitchState_ACN_Decode(T_SwitchState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_SWITCHSTATE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = T_SwitchState_switch_open;
	            break;
	        case 1:
	            (*(pVal)) = T_SwitchState_switch_closed;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_T_SWITCHSTATE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && T_SwitchState_IsConstraintValid(pVal, pErrCode);
}



flag T_FaultState_Equal(const T_FaultState* pVal1, const T_FaultState* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_FaultState_IsConstraintValid(const T_FaultState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == T_FaultState_fault)) || (((*(pVal)) == T_FaultState_ok)));
    *pErrCode = ret ? 0 :  ERR_T_FAULTSTATE; 

	return ret;
}

void T_FaultState_Initialize(T_FaultState* pVal)
{
	(void)pVal;


	(*(pVal)) = T_FaultState_fault;
}

flag T_FaultState_Encode(const T_FaultState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_FaultState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case T_FaultState_fault:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case T_FaultState_ok:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_T_FAULTSTATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_FaultState_Decode(T_FaultState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_T_FAULTSTATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = T_FaultState_fault;
	                break;
	            case 1: 
	                (*(pVal)) = T_FaultState_ok;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_T_FAULTSTATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = T_FaultState_fault;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && T_FaultState_IsConstraintValid(pVal, pErrCode);
}

flag T_FaultState_ACN_Encode(const T_FaultState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_FaultState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case T_FaultState_fault:
	            uIntVal = 0;
	            break;
	        case T_FaultState_ok:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_T_FAULTSTATE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_FaultState_ACN_Decode(T_FaultState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_FAULTSTATE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = T_FaultState_fault;
	            break;
	        case 1:
	            (*(pVal)) = T_FaultState_ok;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_T_FAULTSTATE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && T_FaultState_IsConstraintValid(pVal, pErrCode);
}



flag T_SelectionState_Equal(const T_SelectionState* pVal1, const T_SelectionState* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_SelectionState_IsConstraintValid(const T_SelectionState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == T_SelectionState_not_selected)) || (((*(pVal)) == T_SelectionState_selected)));
    *pErrCode = ret ? 0 :  ERR_T_SELECTIONSTATE; 

	return ret;
}

void T_SelectionState_Initialize(T_SelectionState* pVal)
{
	(void)pVal;


	(*(pVal)) = T_SelectionState_not_selected;
}

flag T_SelectionState_Encode(const T_SelectionState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_SelectionState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case T_SelectionState_not_selected:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case T_SelectionState_selected:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_T_SELECTIONSTATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_SelectionState_Decode(T_SelectionState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_T_SELECTIONSTATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = T_SelectionState_not_selected;
	                break;
	            case 1: 
	                (*(pVal)) = T_SelectionState_selected;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_T_SELECTIONSTATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = T_SelectionState_not_selected;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && T_SelectionState_IsConstraintValid(pVal, pErrCode);
}

flag T_SelectionState_ACN_Encode(const T_SelectionState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_SelectionState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case T_SelectionState_not_selected:
	            uIntVal = 0;
	            break;
	        case T_SelectionState_selected:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_T_SELECTIONSTATE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_SelectionState_ACN_Decode(T_SelectionState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_SELECTIONSTATE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = T_SelectionState_not_selected;
	            break;
	        case 1:
	            (*(pVal)) = T_SelectionState_selected;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_T_SELECTIONSTATE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && T_SelectionState_IsConstraintValid(pVal, pErrCode);
}



flag T_PresenceState_Equal(const T_PresenceState* pVal1, const T_PresenceState* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_PresenceState_IsConstraintValid(const T_PresenceState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == T_PresenceState_absent)) || (((*(pVal)) == T_PresenceState_present)));
    *pErrCode = ret ? 0 :  ERR_T_PRESENCESTATE; 

	return ret;
}

void T_PresenceState_Initialize(T_PresenceState* pVal)
{
	(void)pVal;


	(*(pVal)) = T_PresenceState_absent;
}

flag T_PresenceState_Encode(const T_PresenceState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_PresenceState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case T_PresenceState_absent:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case T_PresenceState_present:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_T_PRESENCESTATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_PresenceState_Decode(T_PresenceState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_T_PRESENCESTATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = T_PresenceState_absent;
	                break;
	            case 1: 
	                (*(pVal)) = T_PresenceState_present;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_T_PRESENCESTATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = T_PresenceState_absent;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && T_PresenceState_IsConstraintValid(pVal, pErrCode);
}

flag T_PresenceState_ACN_Encode(const T_PresenceState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_PresenceState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case T_PresenceState_absent:
	            uIntVal = 0;
	            break;
	        case T_PresenceState_present:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_T_PRESENCESTATE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_PresenceState_ACN_Decode(T_PresenceState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_PRESENCESTATE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = T_PresenceState_absent;
	            break;
	        case 1:
	            (*(pVal)) = T_PresenceState_present;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_T_PRESENCESTATE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && T_PresenceState_IsConstraintValid(pVal, pErrCode);
}



flag T_ForwardBackwardState_Equal(const T_ForwardBackwardState* pVal1, const T_ForwardBackwardState* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_ForwardBackwardState_IsConstraintValid(const T_ForwardBackwardState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == T_ForwardBackwardState_backward)) || (((*(pVal)) == T_ForwardBackwardState_forward)));
    *pErrCode = ret ? 0 :  ERR_T_FORWARDBACKWARDSTATE; 

	return ret;
}

void T_ForwardBackwardState_Initialize(T_ForwardBackwardState* pVal)
{
	(void)pVal;


	(*(pVal)) = T_ForwardBackwardState_backward;
}

flag T_ForwardBackwardState_Encode(const T_ForwardBackwardState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_ForwardBackwardState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case T_ForwardBackwardState_backward:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case T_ForwardBackwardState_forward:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_T_FORWARDBACKWARDSTATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_ForwardBackwardState_Decode(T_ForwardBackwardState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_T_FORWARDBACKWARDSTATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = T_ForwardBackwardState_backward;
	                break;
	            case 1: 
	                (*(pVal)) = T_ForwardBackwardState_forward;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_T_FORWARDBACKWARDSTATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = T_ForwardBackwardState_backward;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && T_ForwardBackwardState_IsConstraintValid(pVal, pErrCode);
}

flag T_ForwardBackwardState_ACN_Encode(const T_ForwardBackwardState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_ForwardBackwardState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case T_ForwardBackwardState_backward:
	            uIntVal = 0;
	            break;
	        case T_ForwardBackwardState_forward:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_T_FORWARDBACKWARDSTATE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_ForwardBackwardState_ACN_Decode(T_ForwardBackwardState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_FORWARDBACKWARDSTATE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = T_ForwardBackwardState_backward;
	            break;
	        case 1:
	            (*(pVal)) = T_ForwardBackwardState_forward;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_T_FORWARDBACKWARDSTATE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && T_ForwardBackwardState_IsConstraintValid(pVal, pErrCode);
}



flag T_LeftRightState_Equal(const T_LeftRightState* pVal1, const T_LeftRightState* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_LeftRightState_IsConstraintValid(const T_LeftRightState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == T_LeftRightState_left)) || (((*(pVal)) == T_LeftRightState_right)));
    *pErrCode = ret ? 0 :  ERR_T_LEFTRIGHTSTATE; 

	return ret;
}

void T_LeftRightState_Initialize(T_LeftRightState* pVal)
{
	(void)pVal;


	(*(pVal)) = T_LeftRightState_left;
}

flag T_LeftRightState_Encode(const T_LeftRightState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_LeftRightState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case T_LeftRightState_left:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case T_LeftRightState_right:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_T_LEFTRIGHTSTATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_LeftRightState_Decode(T_LeftRightState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_T_LEFTRIGHTSTATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = T_LeftRightState_left;
	                break;
	            case 1: 
	                (*(pVal)) = T_LeftRightState_right;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_T_LEFTRIGHTSTATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = T_LeftRightState_left;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && T_LeftRightState_IsConstraintValid(pVal, pErrCode);
}

flag T_LeftRightState_ACN_Encode(const T_LeftRightState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_LeftRightState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case T_LeftRightState_left:
	            uIntVal = 0;
	            break;
	        case T_LeftRightState_right:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_T_LEFTRIGHTSTATE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_LeftRightState_ACN_Decode(T_LeftRightState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_LEFTRIGHTSTATE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = T_LeftRightState_left;
	            break;
	        case 1:
	            (*(pVal)) = T_LeftRightState_right;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_T_LEFTRIGHTSTATE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && T_LeftRightState_IsConstraintValid(pVal, pErrCode);
}



flag T_UsedUnusedState_Equal(const T_UsedUnusedState* pVal1, const T_UsedUnusedState* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_UsedUnusedState_IsConstraintValid(const T_UsedUnusedState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == T_UsedUnusedState_unused)) || (((*(pVal)) == T_UsedUnusedState_used)));
    *pErrCode = ret ? 0 :  ERR_T_USEDUNUSEDSTATE; 

	return ret;
}

void T_UsedUnusedState_Initialize(T_UsedUnusedState* pVal)
{
	(void)pVal;


	(*(pVal)) = T_UsedUnusedState_unused;
}

flag T_UsedUnusedState_Encode(const T_UsedUnusedState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_UsedUnusedState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case T_UsedUnusedState_unused:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case T_UsedUnusedState_used:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_T_USEDUNUSEDSTATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UsedUnusedState_Decode(T_UsedUnusedState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_T_USEDUNUSEDSTATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = T_UsedUnusedState_unused;
	                break;
	            case 1: 
	                (*(pVal)) = T_UsedUnusedState_used;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_T_USEDUNUSEDSTATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = T_UsedUnusedState_unused;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && T_UsedUnusedState_IsConstraintValid(pVal, pErrCode);
}

flag T_UsedUnusedState_ACN_Encode(const T_UsedUnusedState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_UsedUnusedState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case T_UsedUnusedState_unused:
	            uIntVal = 0;
	            break;
	        case T_UsedUnusedState_used:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_T_USEDUNUSEDSTATE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UsedUnusedState_ACN_Decode(T_UsedUnusedState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_USEDUNUSEDSTATE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = T_UsedUnusedState_unused;
	            break;
	        case 1:
	            (*(pVal)) = T_UsedUnusedState_used;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_T_USEDUNUSEDSTATE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && T_UsedUnusedState_IsConstraintValid(pVal, pErrCode);
}



flag T_MovingStillState_Equal(const T_MovingStillState* pVal1, const T_MovingStillState* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_MovingStillState_IsConstraintValid(const T_MovingStillState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == T_MovingStillState_stationary)) || (((*(pVal)) == T_MovingStillState_moving)));
    *pErrCode = ret ? 0 :  ERR_T_MOVINGSTILLSTATE; 

	return ret;
}

void T_MovingStillState_Initialize(T_MovingStillState* pVal)
{
	(void)pVal;


	(*(pVal)) = T_MovingStillState_stationary;
}

flag T_MovingStillState_Encode(const T_MovingStillState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_MovingStillState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case T_MovingStillState_stationary:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case T_MovingStillState_moving:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_T_MOVINGSTILLSTATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_MovingStillState_Decode(T_MovingStillState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_T_MOVINGSTILLSTATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = T_MovingStillState_stationary;
	                break;
	            case 1: 
	                (*(pVal)) = T_MovingStillState_moving;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_T_MOVINGSTILLSTATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = T_MovingStillState_stationary;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && T_MovingStillState_IsConstraintValid(pVal, pErrCode);
}

flag T_MovingStillState_ACN_Encode(const T_MovingStillState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_MovingStillState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case T_MovingStillState_stationary:
	            uIntVal = 0;
	            break;
	        case T_MovingStillState_moving:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_T_MOVINGSTILLSTATE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_MovingStillState_ACN_Decode(T_MovingStillState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_MOVINGSTILLSTATE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = T_MovingStillState_stationary;
	            break;
	        case 1:
	            (*(pVal)) = T_MovingStillState_moving;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_T_MOVINGSTILLSTATE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && T_MovingStillState_IsConstraintValid(pVal, pErrCode);
}



flag T_PlusMinusState_Equal(const T_PlusMinusState* pVal1, const T_PlusMinusState* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_PlusMinusState_IsConstraintValid(const T_PlusMinusState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == T_PlusMinusState_plus)) || (((*(pVal)) == T_PlusMinusState_minus)));
    *pErrCode = ret ? 0 :  ERR_T_PLUSMINUSSTATE; 

	return ret;
}

void T_PlusMinusState_Initialize(T_PlusMinusState* pVal)
{
	(void)pVal;


	(*(pVal)) = T_PlusMinusState_plus;
}

flag T_PlusMinusState_Encode(const T_PlusMinusState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_PlusMinusState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case T_PlusMinusState_plus:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case T_PlusMinusState_minus:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_T_PLUSMINUSSTATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_PlusMinusState_Decode(T_PlusMinusState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_T_PLUSMINUSSTATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = T_PlusMinusState_plus;
	                break;
	            case 1: 
	                (*(pVal)) = T_PlusMinusState_minus;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_T_PLUSMINUSSTATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = T_PlusMinusState_plus;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && T_PlusMinusState_IsConstraintValid(pVal, pErrCode);
}

flag T_PlusMinusState_ACN_Encode(const T_PlusMinusState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_PlusMinusState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case T_PlusMinusState_plus:
	            uIntVal = 0;
	            break;
	        case T_PlusMinusState_minus:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_T_PLUSMINUSSTATE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_PlusMinusState_ACN_Decode(T_PlusMinusState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_PLUSMINUSSTATE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = T_PlusMinusState_plus;
	            break;
	        case 1:
	            (*(pVal)) = T_PlusMinusState_minus;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_T_PLUSMINUSSTATE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && T_PlusMinusState_IsConstraintValid(pVal, pErrCode);
}



flag T_ArmedDisarmedState_Equal(const T_ArmedDisarmedState* pVal1, const T_ArmedDisarmedState* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_ArmedDisarmedState_IsConstraintValid(const T_ArmedDisarmedState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == T_ArmedDisarmedState_disarmed)) || (((*(pVal)) == T_ArmedDisarmedState_armed)));
    *pErrCode = ret ? 0 :  ERR_T_ARMEDDISARMEDSTATE; 

	return ret;
}

void T_ArmedDisarmedState_Initialize(T_ArmedDisarmedState* pVal)
{
	(void)pVal;


	(*(pVal)) = T_ArmedDisarmedState_disarmed;
}

flag T_ArmedDisarmedState_Encode(const T_ArmedDisarmedState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_ArmedDisarmedState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case T_ArmedDisarmedState_disarmed:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case T_ArmedDisarmedState_armed:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_T_ARMEDDISARMEDSTATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_ArmedDisarmedState_Decode(T_ArmedDisarmedState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_T_ARMEDDISARMEDSTATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = T_ArmedDisarmedState_disarmed;
	                break;
	            case 1: 
	                (*(pVal)) = T_ArmedDisarmedState_armed;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_T_ARMEDDISARMEDSTATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = T_ArmedDisarmedState_disarmed;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && T_ArmedDisarmedState_IsConstraintValid(pVal, pErrCode);
}

flag T_ArmedDisarmedState_ACN_Encode(const T_ArmedDisarmedState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_ArmedDisarmedState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case T_ArmedDisarmedState_disarmed:
	            uIntVal = 0;
	            break;
	        case T_ArmedDisarmedState_armed:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_T_ARMEDDISARMEDSTATE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_ArmedDisarmedState_ACN_Decode(T_ArmedDisarmedState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_ARMEDDISARMEDSTATE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = T_ArmedDisarmedState_disarmed;
	            break;
	        case 1:
	            (*(pVal)) = T_ArmedDisarmedState_armed;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_T_ARMEDDISARMEDSTATE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && T_ArmedDisarmedState_IsConstraintValid(pVal, pErrCode);
}



flag T_ActiveInactiveState_Equal(const T_ActiveInactiveState* pVal1, const T_ActiveInactiveState* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_ActiveInactiveState_IsConstraintValid(const T_ActiveInactiveState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == T_ActiveInactiveState_inactive)) || (((*(pVal)) == T_ActiveInactiveState_active)));
    *pErrCode = ret ? 0 :  ERR_T_ACTIVEINACTIVESTATE; 

	return ret;
}

void T_ActiveInactiveState_Initialize(T_ActiveInactiveState* pVal)
{
	(void)pVal;


	(*(pVal)) = T_ActiveInactiveState_inactive;
}

flag T_ActiveInactiveState_Encode(const T_ActiveInactiveState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_ActiveInactiveState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case T_ActiveInactiveState_inactive:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case T_ActiveInactiveState_active:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_T_ACTIVEINACTIVESTATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_ActiveInactiveState_Decode(T_ActiveInactiveState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_T_ACTIVEINACTIVESTATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = T_ActiveInactiveState_inactive;
	                break;
	            case 1: 
	                (*(pVal)) = T_ActiveInactiveState_active;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_T_ACTIVEINACTIVESTATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = T_ActiveInactiveState_inactive;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && T_ActiveInactiveState_IsConstraintValid(pVal, pErrCode);
}

flag T_ActiveInactiveState_ACN_Encode(const T_ActiveInactiveState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_ActiveInactiveState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case T_ActiveInactiveState_inactive:
	            uIntVal = 0;
	            break;
	        case T_ActiveInactiveState_active:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_T_ACTIVEINACTIVESTATE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_ActiveInactiveState_ACN_Decode(T_ActiveInactiveState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_ACTIVEINACTIVESTATE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = T_ActiveInactiveState_inactive;
	            break;
	        case 1:
	            (*(pVal)) = T_ActiveInactiveState_active;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_T_ACTIVEINACTIVESTATE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && T_ActiveInactiveState_IsConstraintValid(pVal, pErrCode);
}



flag T_EnabledInhibitedState_Equal(const T_EnabledInhibitedState* pVal1, const T_EnabledInhibitedState* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_EnabledInhibitedState_IsConstraintValid(const T_EnabledInhibitedState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == T_EnabledInhibitedState_inhibited)) || (((*(pVal)) == T_EnabledInhibitedState_enabled)));
    *pErrCode = ret ? 0 :  ERR_T_ENABLEDINHIBITEDSTATE; 

	return ret;
}

void T_EnabledInhibitedState_Initialize(T_EnabledInhibitedState* pVal)
{
	(void)pVal;


	(*(pVal)) = T_EnabledInhibitedState_inhibited;
}

flag T_EnabledInhibitedState_Encode(const T_EnabledInhibitedState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_EnabledInhibitedState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case T_EnabledInhibitedState_inhibited:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case T_EnabledInhibitedState_enabled:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_T_ENABLEDINHIBITEDSTATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_EnabledInhibitedState_Decode(T_EnabledInhibitedState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_T_ENABLEDINHIBITEDSTATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = T_EnabledInhibitedState_inhibited;
	                break;
	            case 1: 
	                (*(pVal)) = T_EnabledInhibitedState_enabled;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_T_ENABLEDINHIBITEDSTATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = T_EnabledInhibitedState_inhibited;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && T_EnabledInhibitedState_IsConstraintValid(pVal, pErrCode);
}

flag T_EnabledInhibitedState_ACN_Encode(const T_EnabledInhibitedState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_EnabledInhibitedState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case T_EnabledInhibitedState_inhibited:
	            uIntVal = 0;
	            break;
	        case T_EnabledInhibitedState_enabled:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_T_ENABLEDINHIBITEDSTATE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_EnabledInhibitedState_ACN_Decode(T_EnabledInhibitedState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_ENABLEDINHIBITEDSTATE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = T_EnabledInhibitedState_inhibited;
	            break;
	        case 1:
	            (*(pVal)) = T_EnabledInhibitedState_enabled;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_T_ENABLEDINHIBITEDSTATE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && T_EnabledInhibitedState_IsConstraintValid(pVal, pErrCode);
}



flag T_FlagState_Equal(const T_FlagState* pVal1, const T_FlagState* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_FlagState_IsConstraintValid(const T_FlagState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == T_FlagState_clear)) || (((*(pVal)) == T_FlagState_set)));
    *pErrCode = ret ? 0 :  ERR_T_FLAGSTATE; 

	return ret;
}

void T_FlagState_Initialize(T_FlagState* pVal)
{
	(void)pVal;


	(*(pVal)) = T_FlagState_clear;
}

flag T_FlagState_Encode(const T_FlagState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_FlagState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case T_FlagState_clear:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case T_FlagState_set:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_T_FLAGSTATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_FlagState_Decode(T_FlagState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_T_FLAGSTATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = T_FlagState_clear;
	                break;
	            case 1: 
	                (*(pVal)) = T_FlagState_set;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_T_FLAGSTATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = T_FlagState_clear;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && T_FlagState_IsConstraintValid(pVal, pErrCode);
}

flag T_FlagState_ACN_Encode(const T_FlagState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_FlagState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case T_FlagState_clear:
	            uIntVal = 0;
	            break;
	        case T_FlagState_set:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_T_FLAGSTATE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_FlagState_ACN_Decode(T_FlagState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_FLAGSTATE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = T_FlagState_clear;
	            break;
	        case 1:
	            (*(pVal)) = T_FlagState_set;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_T_FLAGSTATE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && T_FlagState_IsConstraintValid(pVal, pErrCode);
}



flag T_SuccessFailState_Equal(const T_SuccessFailState* pVal1, const T_SuccessFailState* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_SuccessFailState_IsConstraintValid(const T_SuccessFailState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == T_SuccessFailState_fail)) || (((*(pVal)) == T_SuccessFailState_success)));
    *pErrCode = ret ? 0 :  ERR_T_SUCCESSFAILSTATE; 

	return ret;
}

void T_SuccessFailState_Initialize(T_SuccessFailState* pVal)
{
	(void)pVal;


	(*(pVal)) = T_SuccessFailState_fail;
}

flag T_SuccessFailState_Encode(const T_SuccessFailState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_SuccessFailState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case T_SuccessFailState_fail:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case T_SuccessFailState_success:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_T_SUCCESSFAILSTATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_SuccessFailState_Decode(T_SuccessFailState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_T_SUCCESSFAILSTATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = T_SuccessFailState_fail;
	                break;
	            case 1: 
	                (*(pVal)) = T_SuccessFailState_success;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_T_SUCCESSFAILSTATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = T_SuccessFailState_fail;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && T_SuccessFailState_IsConstraintValid(pVal, pErrCode);
}

flag T_SuccessFailState_ACN_Encode(const T_SuccessFailState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_SuccessFailState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case T_SuccessFailState_fail:
	            uIntVal = 0;
	            break;
	        case T_SuccessFailState_success:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_T_SUCCESSFAILSTATE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_SuccessFailState_ACN_Decode(T_SuccessFailState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_SUCCESSFAILSTATE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = T_SuccessFailState_fail;
	            break;
	        case 1:
	            (*(pVal)) = T_SuccessFailState_success;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_T_SUCCESSFAILSTATE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && T_SuccessFailState_IsConstraintValid(pVal, pErrCode);
}



flag T_HighLowState_Equal(const T_HighLowState* pVal1, const T_HighLowState* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_HighLowState_IsConstraintValid(const T_HighLowState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == T_HighLowState_low)) || (((*(pVal)) == T_HighLowState_high)));
    *pErrCode = ret ? 0 :  ERR_T_HIGHLOWSTATE; 

	return ret;
}

void T_HighLowState_Initialize(T_HighLowState* pVal)
{
	(void)pVal;


	(*(pVal)) = T_HighLowState_low;
}

flag T_HighLowState_Encode(const T_HighLowState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_HighLowState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case T_HighLowState_low:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case T_HighLowState_high:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_T_HIGHLOWSTATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_HighLowState_Decode(T_HighLowState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_T_HIGHLOWSTATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = T_HighLowState_low;
	                break;
	            case 1: 
	                (*(pVal)) = T_HighLowState_high;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_T_HIGHLOWSTATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = T_HighLowState_low;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && T_HighLowState_IsConstraintValid(pVal, pErrCode);
}

flag T_HighLowState_ACN_Encode(const T_HighLowState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_HighLowState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case T_HighLowState_low:
	            uIntVal = 0;
	            break;
	        case T_HighLowState_high:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_T_HIGHLOWSTATE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_HighLowState_ACN_Decode(T_HighLowState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_HIGHLOWSTATE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = T_HighLowState_low;
	            break;
	        case 1:
	            (*(pVal)) = T_HighLowState_high;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_T_HIGHLOWSTATE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && T_HighLowState_IsConstraintValid(pVal, pErrCode);
}



flag T_OverrideState_Equal(const T_OverrideState* pVal1, const T_OverrideState* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_OverrideState_IsConstraintValid(const T_OverrideState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == T_OverrideState_normal)) || (((*(pVal)) == T_OverrideState_overridden)));
    *pErrCode = ret ? 0 :  ERR_T_OVERRIDESTATE; 

	return ret;
}

void T_OverrideState_Initialize(T_OverrideState* pVal)
{
	(void)pVal;


	(*(pVal)) = T_OverrideState_normal;
}

flag T_OverrideState_Encode(const T_OverrideState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_OverrideState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case T_OverrideState_normal:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case T_OverrideState_overridden:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_T_OVERRIDESTATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_OverrideState_Decode(T_OverrideState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_T_OVERRIDESTATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = T_OverrideState_normal;
	                break;
	            case 1: 
	                (*(pVal)) = T_OverrideState_overridden;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_T_OVERRIDESTATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = T_OverrideState_normal;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && T_OverrideState_IsConstraintValid(pVal, pErrCode);
}

flag T_OverrideState_ACN_Encode(const T_OverrideState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_OverrideState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case T_OverrideState_normal:
	            uIntVal = 0;
	            break;
	        case T_OverrideState_overridden:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_T_OVERRIDESTATE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_OverrideState_ACN_Decode(T_OverrideState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_OVERRIDESTATE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = T_OverrideState_normal;
	            break;
	        case 1:
	            (*(pVal)) = T_OverrideState_overridden;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_T_OVERRIDESTATE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && T_OverrideState_IsConstraintValid(pVal, pErrCode);
}



flag T_LockedUnlockedState_Equal(const T_LockedUnlockedState* pVal1, const T_LockedUnlockedState* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_LockedUnlockedState_IsConstraintValid(const T_LockedUnlockedState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == T_LockedUnlockedState_unlocked)) || (((*(pVal)) == T_LockedUnlockedState_locked)));
    *pErrCode = ret ? 0 :  ERR_T_LOCKEDUNLOCKEDSTATE; 

	return ret;
}

void T_LockedUnlockedState_Initialize(T_LockedUnlockedState* pVal)
{
	(void)pVal;


	(*(pVal)) = T_LockedUnlockedState_unlocked;
}

flag T_LockedUnlockedState_Encode(const T_LockedUnlockedState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_LockedUnlockedState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case T_LockedUnlockedState_unlocked:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case T_LockedUnlockedState_locked:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_T_LOCKEDUNLOCKEDSTATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_LockedUnlockedState_Decode(T_LockedUnlockedState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_T_LOCKEDUNLOCKEDSTATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = T_LockedUnlockedState_unlocked;
	                break;
	            case 1: 
	                (*(pVal)) = T_LockedUnlockedState_locked;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_T_LOCKEDUNLOCKEDSTATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = T_LockedUnlockedState_unlocked;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && T_LockedUnlockedState_IsConstraintValid(pVal, pErrCode);
}

flag T_LockedUnlockedState_ACN_Encode(const T_LockedUnlockedState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_LockedUnlockedState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case T_LockedUnlockedState_unlocked:
	            uIntVal = 0;
	            break;
	        case T_LockedUnlockedState_locked:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_T_LOCKEDUNLOCKEDSTATE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_LockedUnlockedState_ACN_Decode(T_LockedUnlockedState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_LOCKEDUNLOCKEDSTATE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = T_LockedUnlockedState_unlocked;
	            break;
	        case 1:
	            (*(pVal)) = T_LockedUnlockedState_locked;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_T_LOCKEDUNLOCKEDSTATE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && T_LockedUnlockedState_IsConstraintValid(pVal, pErrCode);
}



flag T_WarningState_Equal(const T_WarningState* pVal1, const T_WarningState* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_WarningState_IsConstraintValid(const T_WarningState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == T_WarningState_ok)) || (((*(pVal)) == T_WarningState_warning)));
    *pErrCode = ret ? 0 :  ERR_T_WARNINGSTATE; 

	return ret;
}

void T_WarningState_Initialize(T_WarningState* pVal)
{
	(void)pVal;


	(*(pVal)) = T_WarningState_ok;
}

flag T_WarningState_Encode(const T_WarningState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_WarningState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case T_WarningState_ok:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case T_WarningState_warning:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_T_WARNINGSTATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_WarningState_Decode(T_WarningState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_T_WARNINGSTATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = T_WarningState_ok;
	                break;
	            case 1: 
	                (*(pVal)) = T_WarningState_warning;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_T_WARNINGSTATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = T_WarningState_ok;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && T_WarningState_IsConstraintValid(pVal, pErrCode);
}

flag T_WarningState_ACN_Encode(const T_WarningState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_WarningState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case T_WarningState_ok:
	            uIntVal = 0;
	            break;
	        case T_WarningState_warning:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_T_WARNINGSTATE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_WarningState_ACN_Decode(T_WarningState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_WARNINGSTATE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = T_WarningState_ok;
	            break;
	        case 1:
	            (*(pVal)) = T_WarningState_warning;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_T_WARNINGSTATE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && T_WarningState_IsConstraintValid(pVal, pErrCode);
}



flag T_ValidInvalidState_Equal(const T_ValidInvalidState* pVal1, const T_ValidInvalidState* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_ValidInvalidState_IsConstraintValid(const T_ValidInvalidState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == T_ValidInvalidState_invalid)) || (((*(pVal)) == T_ValidInvalidState_valid)));
    *pErrCode = ret ? 0 :  ERR_T_VALIDINVALIDSTATE; 

	return ret;
}

void T_ValidInvalidState_Initialize(T_ValidInvalidState* pVal)
{
	(void)pVal;


	(*(pVal)) = T_ValidInvalidState_invalid;
}

flag T_ValidInvalidState_Encode(const T_ValidInvalidState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_ValidInvalidState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case T_ValidInvalidState_invalid:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case T_ValidInvalidState_valid:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_T_VALIDINVALIDSTATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_ValidInvalidState_Decode(T_ValidInvalidState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_T_VALIDINVALIDSTATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = T_ValidInvalidState_invalid;
	                break;
	            case 1: 
	                (*(pVal)) = T_ValidInvalidState_valid;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_T_VALIDINVALIDSTATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = T_ValidInvalidState_invalid;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && T_ValidInvalidState_IsConstraintValid(pVal, pErrCode);
}

flag T_ValidInvalidState_ACN_Encode(const T_ValidInvalidState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_ValidInvalidState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case T_ValidInvalidState_invalid:
	            uIntVal = 0;
	            break;
	        case T_ValidInvalidState_valid:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_T_VALIDINVALIDSTATE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_ValidInvalidState_ACN_Decode(T_ValidInvalidState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_VALIDINVALIDSTATE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = T_ValidInvalidState_invalid;
	            break;
	        case 1:
	            (*(pVal)) = T_ValidInvalidState_valid;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_T_VALIDINVALIDSTATE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && T_ValidInvalidState_IsConstraintValid(pVal, pErrCode);
}



flag T_UART_DLC_FrameBuffer_Equal(const T_UART_DLC_FrameBuffer* pVal1, const T_UART_DLC_FrameBuffer* pVal2)
{
	return memcmp(pVal1->arr, pVal2->arr, 16) ==0	;

}

flag T_UART_DLC_FrameBuffer_IsConstraintValid(const T_UART_DLC_FrameBuffer* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

void T_UART_DLC_FrameBuffer_Initialize(T_UART_DLC_FrameBuffer* pVal)
{
	(void)pVal;


	memset(pVal->arr, 0x0, 16);


}

flag T_UART_DLC_FrameBuffer_Encode(const T_UART_DLC_FrameBuffer* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_UART_DLC_FrameBuffer_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, 16);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UART_DLC_FrameBuffer_Decode(T_UART_DLC_FrameBuffer* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, 16);

	return ret  && T_UART_DLC_FrameBuffer_IsConstraintValid(pVal, pErrCode);
}

flag T_UART_DLC_FrameBuffer_ACN_Encode(const T_UART_DLC_FrameBuffer* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_UART_DLC_FrameBuffer_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, 16);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UART_DLC_FrameBuffer_ACN_Decode(T_UART_DLC_FrameBuffer* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, 16);

    return ret && T_UART_DLC_FrameBuffer_IsConstraintValid(pVal, pErrCode);
}



flag T_UART_DLC_SDU_Equal(const T_UART_DLC_SDU* pVal1, const T_UART_DLC_SDU* pVal2)
{
	return memcmp(pVal1->arr, pVal2->arr, 14) ==0	;

}

flag T_UART_DLC_SDU_IsConstraintValid(const T_UART_DLC_SDU* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

void T_UART_DLC_SDU_Initialize(T_UART_DLC_SDU* pVal)
{
	(void)pVal;


	memset(pVal->arr, 0x0, 14);


}

flag T_UART_DLC_SDU_Encode(const T_UART_DLC_SDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_UART_DLC_SDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, 14);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UART_DLC_SDU_Decode(T_UART_DLC_SDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, 14);

	return ret  && T_UART_DLC_SDU_IsConstraintValid(pVal, pErrCode);
}

flag T_UART_DLC_SDU_ACN_Encode(const T_UART_DLC_SDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_UART_DLC_SDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, 14);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UART_DLC_SDU_ACN_Decode(T_UART_DLC_SDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, 14);

    return ret && T_UART_DLC_SDU_IsConstraintValid(pVal, pErrCode);
}



flag T_UART_DLC_PDU_Equal(const T_UART_DLC_PDU* pVal1, const T_UART_DLC_PDU* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->dlc_header == pVal2->dlc_header);

    if (ret) {
        ret = T_UART_DLC_SDU_Equal((&(pVal1->dlc_payload)), (&(pVal2->dlc_payload)));

        if (ret) {
            ret = (pVal1->crc == pVal2->crc);

        }

    }

	return ret;

}

flag T_UART_DLC_PDU_IsConstraintValid(const T_UART_DLC_PDU* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = UINT8_IsConstraintValid((&(pVal->dlc_header)), pErrCode);
    if (ret) {
        ret = T_UART_DLC_SDU_IsConstraintValid((&(pVal->dlc_payload)), pErrCode);
        if (ret) {
            ret = UINT8_IsConstraintValid((&(pVal->crc)), pErrCode);
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void T_UART_DLC_PDU_Initialize(T_UART_DLC_PDU* pVal)
{
	(void)pVal;



	/*set dlc_header */
	T_UART_DLC_Header_Initialize((&(pVal->dlc_header)));
	/*set dlc_payload */
	T_UART_DLC_SDU_Initialize((&(pVal->dlc_payload)));
	/*set crc */
	UINT8_Initialize((&(pVal->crc)));
}

flag T_UART_DLC_PDU_Encode(const T_UART_DLC_PDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_UART_DLC_PDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode dlc_header */
	    /* No need to encode value since it will always be 22 */
	    (void)pBitStrm;
	    if (ret) {
	        /*Encode dlc_payload */
	        ret = T_UART_DLC_SDU_Encode((&(pVal->dlc_payload)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode crc */
	            ret = UINT8_Encode((&(pVal->crc)), pBitStrm, pErrCode, FALSE);
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UART_DLC_PDU_Decode(T_UART_DLC_PDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode dlc_header */
	pVal->dlc_header=22; 
	(void)pBitStrm;
	ret = TRUE; 
	*pErrCode = 0;
	if (ret) {
	    /*Decode dlc_payload */
	    ret = T_UART_DLC_SDU_Decode((&(pVal->dlc_payload)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode crc */
	        ret = UINT8_Decode((&(pVal->crc)), pBitStrm, pErrCode);
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

	return ret  && T_UART_DLC_PDU_IsConstraintValid(pVal, pErrCode);
}

flag T_UART_DLC_PDU_ACN_Encode(const T_UART_DLC_PDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_UART_DLC_PDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode dlc_header */
	    ret = UINT8_ACN_Encode((&(pVal->dlc_header)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode dlc_payload */
	        ret = T_UART_DLC_SDU_ACN_Encode((&(pVal->dlc_payload)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode crc */
	            ret = UINT8_ACN_Encode((&(pVal->crc)), pBitStrm, pErrCode, FALSE);
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UART_DLC_PDU_ACN_Decode(T_UART_DLC_PDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode dlc_header */
	ret = UINT8_ACN_Decode((&(pVal->dlc_header)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode dlc_payload */
	    ret = T_UART_DLC_SDU_ACN_Decode((&(pVal->dlc_payload)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode crc */
	        ret = UINT8_ACN_Decode((&(pVal->crc)), pBitStrm, pErrCode);
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

    return ret && T_UART_DLC_PDU_IsConstraintValid(pVal, pErrCode);
}



flag T_UART_DLC_RxErrorCode_Equal(const T_UART_DLC_RxErrorCode* pVal1, const T_UART_DLC_RxErrorCode* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_UART_DLC_RxErrorCode_IsConstraintValid(const T_UART_DLC_RxErrorCode* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((*(pVal)) == T_UART_DLC_RxErrorCode_no_error)) || (((*(pVal)) == T_UART_DLC_RxErrorCode_bad_start_char)))) || (((*(pVal)) == T_UART_DLC_RxErrorCode_crc_fail)))) || (((*(pVal)) == T_UART_DLC_RxErrorCode_frame_timeout)))) || (((*(pVal)) == T_UART_DLC_RxErrorCode_bad_request_type)));
    *pErrCode = ret ? 0 :  ERR_T_UART_DLC_RXERRORCODE; 

	return ret;
}

void T_UART_DLC_RxErrorCode_Initialize(T_UART_DLC_RxErrorCode* pVal)
{
	(void)pVal;


	(*(pVal)) = T_UART_DLC_RxErrorCode_no_error;
}

flag T_UART_DLC_RxErrorCode_Encode(const T_UART_DLC_RxErrorCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_UART_DLC_RxErrorCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case T_UART_DLC_RxErrorCode_no_error:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 4);
	        	break;
	        case T_UART_DLC_RxErrorCode_bad_start_char:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 4);
	        	break;
	        case T_UART_DLC_RxErrorCode_crc_fail:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 4);
	        	break;
	        case T_UART_DLC_RxErrorCode_frame_timeout:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 4);
	        	break;
	        case T_UART_DLC_RxErrorCode_bad_request_type:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 4);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_T_UART_DLC_RXERRORCODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UART_DLC_RxErrorCode_Decode(T_UART_DLC_RxErrorCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 4);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UART_DLC_RXERRORCODE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = T_UART_DLC_RxErrorCode_no_error;
	                break;
	            case 1: 
	                (*(pVal)) = T_UART_DLC_RxErrorCode_bad_start_char;
	                break;
	            case 2: 
	                (*(pVal)) = T_UART_DLC_RxErrorCode_crc_fail;
	                break;
	            case 3: 
	                (*(pVal)) = T_UART_DLC_RxErrorCode_frame_timeout;
	                break;
	            case 4: 
	                (*(pVal)) = T_UART_DLC_RxErrorCode_bad_request_type;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_T_UART_DLC_RXERRORCODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = T_UART_DLC_RxErrorCode_no_error;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && T_UART_DLC_RxErrorCode_IsConstraintValid(pVal, pErrCode);
}

flag T_UART_DLC_RxErrorCode_ACN_Encode(const T_UART_DLC_RxErrorCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_UART_DLC_RxErrorCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case T_UART_DLC_RxErrorCode_no_error:
	            uIntVal = 0;
	            break;
	        case T_UART_DLC_RxErrorCode_bad_start_char:
	            uIntVal = 1;
	            break;
	        case T_UART_DLC_RxErrorCode_crc_fail:
	            uIntVal = 2;
	            break;
	        case T_UART_DLC_RxErrorCode_frame_timeout:
	            uIntVal = 3;
	            break;
	        case T_UART_DLC_RxErrorCode_bad_request_type:
	            uIntVal = 4;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_T_UART_DLC_RXERRORCODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 4);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UART_DLC_RxErrorCode_ACN_Decode(T_UART_DLC_RxErrorCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 4);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UART_DLC_RXERRORCODE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = T_UART_DLC_RxErrorCode_no_error;
	            break;
	        case 1:
	            (*(pVal)) = T_UART_DLC_RxErrorCode_bad_start_char;
	            break;
	        case 2:
	            (*(pVal)) = T_UART_DLC_RxErrorCode_crc_fail;
	            break;
	        case 3:
	            (*(pVal)) = T_UART_DLC_RxErrorCode_frame_timeout;
	            break;
	        case 4:
	            (*(pVal)) = T_UART_DLC_RxErrorCode_bad_request_type;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_T_UART_DLC_RXERRORCODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && T_UART_DLC_RxErrorCode_IsConstraintValid(pVal, pErrCode);
}



flag T_Int32_Equal(const T_Int32* pVal1, const T_Int32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_Int32_IsConstraintValid(const T_Int32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-2147483648LL <= (*(pVal))) && ((*(pVal)) <= 2147483647LL));
    *pErrCode = ret ? 0 :  ERR_T_INT32; 

	return ret;
}

void T_Int32_Initialize(T_Int32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_Int32_Encode(const T_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int32_Decode(T_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT32;

	return ret  && T_Int32_IsConstraintValid(pVal, pErrCode);
}

flag T_Int32_ACN_Encode(const T_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int32_ACN_Decode(T_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT32;

    return ret && T_Int32_IsConstraintValid(pVal, pErrCode);
}



flag T_UInt32_Equal(const T_UInt32* pVal1, const T_UInt32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_UInt32_IsConstraintValid(const T_UInt32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT32; 

	return ret;
}

void T_UInt32_Initialize(T_UInt32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_UInt32_Encode(const T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt32_Decode(T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT32;

	return ret  && T_UInt32_IsConstraintValid(pVal, pErrCode);
}

flag T_UInt32_ACN_Encode(const T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt32_ACN_Decode(T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT32;

    return ret && T_UInt32_IsConstraintValid(pVal, pErrCode);
}



flag T_Int8_Equal(const T_Int8* pVal1, const T_Int8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_Int8_IsConstraintValid(const T_Int8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-128LL <= (*(pVal))) && ((*(pVal)) <= 127LL));
    *pErrCode = ret ? 0 :  ERR_T_INT8; 

	return ret;
}

void T_Int8_Initialize(T_Int8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_Int8_Encode(const T_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int8_Decode(T_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT8;

	return ret  && T_Int8_IsConstraintValid(pVal, pErrCode);
}

flag T_Int8_ACN_Encode(const T_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int8_ACN_Decode(T_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT8;

    return ret && T_Int8_IsConstraintValid(pVal, pErrCode);
}



flag T_UInt8_Equal(const T_UInt8* pVal1, const T_UInt8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_UInt8_IsConstraintValid(const T_UInt8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT8; 

	return ret;
}

void T_UInt8_Initialize(T_UInt8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_UInt8_Encode(const T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt8_Decode(T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT8;

	return ret  && T_UInt8_IsConstraintValid(pVal, pErrCode);
}

flag T_UInt8_ACN_Encode(const T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt8_ACN_Decode(T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT8;

    return ret && T_UInt8_IsConstraintValid(pVal, pErrCode);
}



flag T_Boolean_Equal(const T_Boolean* pVal1, const T_Boolean* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_Boolean_IsConstraintValid(const T_Boolean* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

void T_Boolean_Initialize(T_Boolean* pVal)
{
	(void)pVal;


	(*(pVal)) = FALSE;
}

flag T_Boolean_Encode(const T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Boolean_Decode(T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_BOOLEAN;

	return ret  && T_Boolean_IsConstraintValid(pVal, pErrCode);
}

flag T_Boolean_ACN_Encode(const T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Boolean_ACN_Decode(T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_BOOLEAN;

    return ret && T_Boolean_IsConstraintValid(pVal, pErrCode);
}



flag T_Null_Record_Equal(const T_Null_Record* pVal1, const T_Null_Record* pVal2)
{
	(void)pVal1;
	(void)pVal2;
	return TRUE;

}

flag T_Null_Record_IsConstraintValid(const T_Null_Record* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

void T_Null_Record_Initialize(T_Null_Record* pVal)
{
	(void)pVal;


}

flag T_Null_Record_Encode(const T_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Null_Record_Decode(T_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;
	(void)pBitStrm;



	return ret  && T_Null_Record_IsConstraintValid(pVal, pErrCode);
}

flag T_Null_Record_ACN_Encode(const T_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Null_Record_ACN_Decode(T_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	(void)pBitStrm;
	*pErrCode = 0;



    return ret && T_Null_Record_IsConstraintValid(pVal, pErrCode);
}



flag MyInteger_Equal(const MyInteger* pVal1, const MyInteger* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag MyInteger_IsConstraintValid(const MyInteger* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 10000UL);
    *pErrCode = ret ? 0 :  ERR_MYINTEGER; 

	return ret;
}

void MyInteger_Initialize(MyInteger* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag MyInteger_Encode(const MyInteger* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? MyInteger_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 10000);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag MyInteger_Decode(MyInteger* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 10000);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_MYINTEGER;

	return ret  && MyInteger_IsConstraintValid(pVal, pErrCode);
}

flag MyInteger_ACN_Encode(const MyInteger* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? MyInteger_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 10000);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag MyInteger_ACN_Decode(MyInteger* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 10000);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_MYINTEGER;

    return ret && MyInteger_IsConstraintValid(pVal, pErrCode);
}



flag PID_Equal(const PID* pVal1, const PID* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag PID_IsConstraintValid(const PID* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((((*(pVal)) == PID_bcapp)) || (((*(pVal)) == PID_bcdlct)))) || (((*(pVal)) == PID_channeleffects)))) || (((*(pVal)) == PID_erroredchannel)))) || (((*(pVal)) == PID_rtapp)))) || (((*(pVal)) == PID_rtdlcr)))) || (((*(pVal)) == PID_env)));
    *pErrCode = ret ? 0 :  ERR_PID; 

	return ret;
}

void PID_Initialize(PID* pVal)
{
	(void)pVal;


	(*(pVal)) = PID_bcapp;
}

flag PID_Encode(const PID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? PID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case PID_bcapp:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 6);
	        	break;
	        case PID_bcdlct:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 6);
	        	break;
	        case PID_channeleffects:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 6);
	        	break;
	        case PID_erroredchannel:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 6);
	        	break;
	        case PID_rtapp:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 6);
	        	break;
	        case PID_rtdlcr:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 6);
	        	break;
	        case PID_env:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 6);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_PID; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PID_Decode(PID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 6);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_PID;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = PID_bcapp;
	                break;
	            case 1: 
	                (*(pVal)) = PID_bcdlct;
	                break;
	            case 2: 
	                (*(pVal)) = PID_channeleffects;
	                break;
	            case 3: 
	                (*(pVal)) = PID_erroredchannel;
	                break;
	            case 4: 
	                (*(pVal)) = PID_rtapp;
	                break;
	            case 5: 
	                (*(pVal)) = PID_rtdlcr;
	                break;
	            case 6: 
	                (*(pVal)) = PID_env;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_PID;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = PID_bcapp;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && PID_IsConstraintValid(pVal, pErrCode);
}

flag PID_ACN_Encode(const PID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? PID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case PID_bcapp:
	            uIntVal = 0;
	            break;
	        case PID_bcdlct:
	            uIntVal = 1;
	            break;
	        case PID_channeleffects:
	            uIntVal = 2;
	            break;
	        case PID_erroredchannel:
	            uIntVal = 3;
	            break;
	        case PID_rtapp:
	            uIntVal = 4;
	            break;
	        case PID_rtdlcr:
	            uIntVal = 5;
	            break;
	        case PID_env:
	            uIntVal = 6;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_PID;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 6);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PID_ACN_Decode(PID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 6);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PID;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = PID_bcapp;
	            break;
	        case 1:
	            (*(pVal)) = PID_bcdlct;
	            break;
	        case 2:
	            (*(pVal)) = PID_channeleffects;
	            break;
	        case 3:
	            (*(pVal)) = PID_erroredchannel;
	            break;
	        case 4:
	            (*(pVal)) = PID_rtapp;
	            break;
	        case 5:
	            (*(pVal)) = PID_rtdlcr;
	            break;
	        case 6:
	            (*(pVal)) = PID_env;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_PID;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && PID_IsConstraintValid(pVal, pErrCode);
}

