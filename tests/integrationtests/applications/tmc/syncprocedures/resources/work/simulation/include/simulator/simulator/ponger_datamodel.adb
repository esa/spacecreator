pragma Style_Checks (Off);
--  Code automatically generated by asn1scc tool
pragma Warnings (Off, "redundant with clause in body");

pragma Warnings (Off, "no entities of ""adaasn1rtl.encoding.uper"" are referenced");
pragma Warnings (Off, "use clause for package ""adaasn1rtl.encoding.uper"" has no effect");
pragma Warnings (Off, "unit ""adaasn1rtl.encoding.uper"" is not referenced");
with adaasn1rtl.encoding.uper;
pragma Warnings (On, "no entities of ""adaasn1rtl.encoding.uper"" are referenced");
pragma Warnings (On, "use clause for package ""adaasn1rtl.encoding.uper"" has no effect");
pragma Warnings (On, "unit ""adaasn1rtl.encoding.uper"" is not referenced");


pragma Warnings (Off, "no entities of ""SYNCPROCEDURES_DATAVIEW"" are referenced");
pragma Warnings (Off, "use clause for package ""SYNCPROCEDURES_DATAVIEW"" has no effect");
pragma Warnings (Off, "unit ""SYNCPROCEDURES_DATAVIEW"" is not referenced");
with SYNCPROCEDURES_DATAVIEW;
pragma Warnings (On, "no entities of ""SYNCPROCEDURES_DATAVIEW"" are referenced");
pragma Warnings (On, "use clause for package ""SYNCPROCEDURES_DATAVIEW"" has no effect");
pragma Warnings (On, "unit ""SYNCPROCEDURES_DATAVIEW"" is not referenced");

pragma Warnings (On, "redundant with clause in body");

pragma Warnings (Off, "use clause for type");
pragma Warnings (Off, "is already use-visible through previous use_type_clause at");
use type SYNCPROCEDURES_DATAVIEW.asn1SccMyInteger;
pragma Warnings (On, "use clause for type");
pragma Warnings (On, "is already use-visible through previous use_type_clause at");
package body Ponger_Datamodel with SPARK_Mode is



pragma Warnings (Off, "condition can only be False if invalid values present");
pragma Warnings (Off, "condition can only be True if invalid values present");


function asn1SccPonger_States_Equal (val1, val2 :  asn1SccPonger_States) return Boolean
is

begin
	return val1 = val2;

end asn1SccPonger_States_Equal;

function asn1SccPonger_States_Init return asn1SccPonger_States
is
    val: asn1SccPonger_States;
begin
    val := asn1Sccwait;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPonger_States_Init;

function asn1SccPonger_States_IsConstraintValid(val : asn1SccPonger_States) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val = asn1Sccwait);
    ret.ErrorCode := (if ret.Success then 0 else ERR_PONGER_STATES);
    return ret;
end asn1SccPonger_States_IsConstraintValid;

procedure asn1SccPonger_States_Encode_aux(val : asn1SccPonger_States; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is

begin
    result := asn1SccPonger_States_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        declare
            intVal:Asn1Int;
        begin
            case val is 
                when asn1Sccwait    => intVal := 0;
            end case;
            adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, intVal, 0, 0);
        end;
    end if;

end asn1SccPonger_States_Encode_aux;

procedure asn1SccPonger_States_Encode(val : asn1SccPonger_States; Stream : out asn1SccPonger_States_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := asn1SccPonger_States_uPER_Stream'(Size_In_Bytes => 1, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    asn1SccPonger_States_Encode_aux(val, Stream, result);
end asn1SccPonger_States_Encode;

procedure asn1SccPonger_States_Decode_aux(val: out asn1SccPonger_States; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    declare
        intVal:Asn1Int;
    begin
        adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumber(bs, intVal, 0, 0, 0, result.Success);
        if result.Success then
            case asn1SccPonger_States_index_range(intVal) is
                when 0 => val := asn1Sccwait;
            end case;
            result.ErrorCode := 0;
        else
            val := asn1Sccwait;					-- COVERAGE_IGNORE
            result.ErrorCode := ERR_UPER_DECODE_PONGER_STATES;				-- COVERAGE_IGNORE
        end if;
    end;
end asn1SccPonger_States_Decode_aux;
procedure asn1SccPonger_States_Decode(val:out asn1SccPonger_States; Stream : IN OUT asn1SccPonger_States_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    asn1SccPonger_States_Decode_aux(val, Stream, result);
    if result.success then
        result := asn1SccPonger_States_IsConstraintValid(val);
    end if;

end asn1SccPonger_States_Decode;



function asn1SccPonger_Context_Equal (val1, val2 :  asn1SccPonger_Context) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (val1.state = val2.state);

    if ret then
        ret := (val1.init_done = val2.init_done);

        if ret then
            ret := (val1.pingarg = val2.pingarg);

        end if;
    end if;
	return ret;

end asn1SccPonger_Context_Equal;

function asn1SccPonger_Context_Init return asn1SccPonger_Context
is
    val: asn1SccPonger_Context;
begin

    --set state 
    val.state := asn1SccPonger_States_Init;
    --set init_done 
    val.init_done := FALSE;
    --set pingarg 
    val.pingarg := SYNCPROCEDURES_DATAVIEW.asn1SccMyInteger_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPonger_Context_Init;

function asn1SccPonger_Context_IsConstraintValid(val : asn1SccPonger_Context) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := asn1SccPonger_States_IsConstraintValid(val.state);
    if ret.Success then
        ret := SYNCPROCEDURES_DATAVIEW.asn1SccMyInteger_IsConstraintValid(val.pingarg);
    end if;
    return ret;
end asn1SccPonger_Context_IsConstraintValid;

procedure asn1SccPonger_Context_Encode_aux(val : asn1SccPonger_Context; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is

begin
    result := asn1SccPonger_Context_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        --Encode state 
        asn1SccPonger_States_Encode_aux(val.state, bs, result);
        if result.Success then
            --Encode init_done 
            adaasn1rtl.encoding.uper.UPER_Enc_Boolean(bs, val.init_done);
            if result.Success then
                --Encode pingarg 
                SYNCPROCEDURES_DATAVIEW.asn1SccMyInteger_Encode_aux(val.pingarg, bs, result);
            end if;
        end if;
    end if;

end asn1SccPonger_Context_Encode_aux;

procedure asn1SccPonger_Context_Encode(val : asn1SccPonger_Context; Stream : out asn1SccPonger_Context_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := asn1SccPonger_Context_uPER_Stream'(Size_In_Bytes => asn1SccPonger_Context_REQUIRED_BYTES_FOR_ENCODING, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    asn1SccPonger_Context_Encode_aux(val, Stream, result);
end asn1SccPonger_Context_Encode;

procedure asn1SccPonger_Context_Decode_aux(val: out asn1SccPonger_Context; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    --Decode state 
    asn1SccPonger_States_Decode_aux(val.state, bs, result);
    if result.Success then
        --Decode init_done 
        result.ErrorCode := ERR_UPER_DECODE_PONGER_CONTEXT_INIT_DONE;
        adaasn1rtl.encoding.uper.UPER_Dec_boolean(bs, val.init_done, result.Success);
        if result.Success then
            --Decode pingarg 
            SYNCPROCEDURES_DATAVIEW.asn1SccMyInteger_Decode_aux(val.pingarg, bs, result);
        end if;
    end if;
end asn1SccPonger_Context_Decode_aux;
procedure asn1SccPonger_Context_Decode(val:out asn1SccPonger_Context; Stream : IN OUT asn1SccPonger_Context_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    asn1SccPonger_Context_Decode_aux(val, Stream, result);
    if result.success then
        result := asn1SccPonger_Context_IsConstraintValid(val);
    end if;

end asn1SccPonger_Context_Decode;


pragma Warnings (On, "condition can only be False if invalid values present");
pragma Warnings (On, "condition can only be True if invalid values present");

 
end Ponger_Datamodel;