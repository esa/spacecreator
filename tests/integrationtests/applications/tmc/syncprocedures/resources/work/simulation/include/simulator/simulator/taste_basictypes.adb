pragma Style_Checks (Off);
--  Code automatically generated by asn1scc tool
pragma Warnings (Off, "redundant with clause in body");

pragma Warnings (Off, "no entities of ""adaasn1rtl.encoding.uper"" are referenced");
pragma Warnings (Off, "use clause for package ""adaasn1rtl.encoding.uper"" has no effect");
pragma Warnings (Off, "unit ""adaasn1rtl.encoding.uper"" is not referenced");
with adaasn1rtl.encoding.uper;
pragma Warnings (On, "no entities of ""adaasn1rtl.encoding.uper"" are referenced");
pragma Warnings (On, "use clause for package ""adaasn1rtl.encoding.uper"" has no effect");
pragma Warnings (On, "unit ""adaasn1rtl.encoding.uper"" is not referenced");

pragma Warnings (On, "redundant with clause in body");

package body TASTE_BasicTypes with SPARK_Mode is



pragma Warnings (Off, "condition can only be False if invalid values present");
pragma Warnings (Off, "condition can only be True if invalid values present");


function asn1SccT_Int32_Equal (val1, val2 :  asn1SccT_Int32) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_Int32_Equal;

function asn1SccT_Int32_Init return asn1SccT_Int32
is
    val: asn1SccT_Int32;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_Int32_Init;

function asn1SccT_Int32_IsConstraintValid(val : asn1SccT_Int32) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := ((-2147483648 <= val) AND (val <= 2147483647));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_INT32);
    return ret;
end asn1SccT_Int32_IsConstraintValid;

procedure asn1SccT_Int32_Encode_aux(val : asn1SccT_Int32; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is

begin
    result := asn1SccT_Int32_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, val, -2147483648, 32);
    end if;

end asn1SccT_Int32_Encode_aux;

procedure asn1SccT_Int32_Encode(val : asn1SccT_Int32; Stream : out asn1SccT_Int32_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := asn1SccT_Int32_uPER_Stream'(Size_In_Bytes => asn1SccT_Int32_REQUIRED_BYTES_FOR_ENCODING, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    asn1SccT_Int32_Encode_aux(val, Stream, result);
end asn1SccT_Int32_Encode;

procedure asn1SccT_Int32_Decode_aux(val: out asn1SccT_Int32; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    result.ErrorCode := ERR_UPER_DECODE_T_INT32;
    adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumber(bs, val, -2147483648, 2147483647, 32, result.Success);
end asn1SccT_Int32_Decode_aux;
procedure asn1SccT_Int32_Decode(val:out asn1SccT_Int32; Stream : IN OUT asn1SccT_Int32_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    asn1SccT_Int32_Decode_aux(val, Stream, result);
    if result.success then
        result := asn1SccT_Int32_IsConstraintValid(val);
    end if;

end asn1SccT_Int32_Decode;



function asn1SccT_UInt32_Equal (val1, val2 :  asn1SccT_UInt32) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_UInt32_Equal;

function asn1SccT_UInt32_Init return asn1SccT_UInt32
is
    val: asn1SccT_UInt32;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_UInt32_Init;

function asn1SccT_UInt32_IsConstraintValid(val : asn1SccT_UInt32) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val <= 4294967295);
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_UINT32);
    return ret;
end asn1SccT_UInt32_IsConstraintValid;

procedure asn1SccT_UInt32_Encode_aux(val : asn1SccT_UInt32; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is

begin
    result := asn1SccT_UInt32_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        adaasn1rtl.encoding.uper.UPER_Enc_ConstraintPosWholeNumber(bs, val, 0, 32);
    end if;

end asn1SccT_UInt32_Encode_aux;

procedure asn1SccT_UInt32_Encode(val : asn1SccT_UInt32; Stream : out asn1SccT_UInt32_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := asn1SccT_UInt32_uPER_Stream'(Size_In_Bytes => asn1SccT_UInt32_REQUIRED_BYTES_FOR_ENCODING, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    asn1SccT_UInt32_Encode_aux(val, Stream, result);
end asn1SccT_UInt32_Encode;

procedure asn1SccT_UInt32_Decode_aux(val: out asn1SccT_UInt32; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    result.ErrorCode := ERR_UPER_DECODE_T_UINT32;
    adaasn1rtl.encoding.uper.UPER_Dec_ConstraintPosWholeNumber(bs, val, 0, 4294967295, 32, result.Success);
end asn1SccT_UInt32_Decode_aux;
procedure asn1SccT_UInt32_Decode(val:out asn1SccT_UInt32; Stream : IN OUT asn1SccT_UInt32_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    asn1SccT_UInt32_Decode_aux(val, Stream, result);
    if result.success then
        result := asn1SccT_UInt32_IsConstraintValid(val);
    end if;

end asn1SccT_UInt32_Decode;



function asn1SccT_Int8_Equal (val1, val2 :  asn1SccT_Int8) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_Int8_Equal;

function asn1SccT_Int8_Init return asn1SccT_Int8
is
    val: asn1SccT_Int8;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_Int8_Init;

function asn1SccT_Int8_IsConstraintValid(val : asn1SccT_Int8) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := ((-128 <= val) AND (val <= 127));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_INT8);
    return ret;
end asn1SccT_Int8_IsConstraintValid;

procedure asn1SccT_Int8_Encode_aux(val : asn1SccT_Int8; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is

begin
    result := asn1SccT_Int8_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, val, -128, 8);
    end if;

end asn1SccT_Int8_Encode_aux;

procedure asn1SccT_Int8_Encode(val : asn1SccT_Int8; Stream : out asn1SccT_Int8_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := asn1SccT_Int8_uPER_Stream'(Size_In_Bytes => asn1SccT_Int8_REQUIRED_BYTES_FOR_ENCODING, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    asn1SccT_Int8_Encode_aux(val, Stream, result);
end asn1SccT_Int8_Encode;

procedure asn1SccT_Int8_Decode_aux(val: out asn1SccT_Int8; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    result.ErrorCode := ERR_UPER_DECODE_T_INT8;
    adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumber(bs, val, -128, 127, 8, result.Success);
end asn1SccT_Int8_Decode_aux;
procedure asn1SccT_Int8_Decode(val:out asn1SccT_Int8; Stream : IN OUT asn1SccT_Int8_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    asn1SccT_Int8_Decode_aux(val, Stream, result);
    if result.success then
        result := asn1SccT_Int8_IsConstraintValid(val);
    end if;

end asn1SccT_Int8_Decode;



function asn1SccT_UInt8_Equal (val1, val2 :  asn1SccT_UInt8) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_UInt8_Equal;

function asn1SccT_UInt8_Init return asn1SccT_UInt8
is
    val: asn1SccT_UInt8;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_UInt8_Init;

function asn1SccT_UInt8_IsConstraintValid(val : asn1SccT_UInt8) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val <= 255);
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_UINT8);
    return ret;
end asn1SccT_UInt8_IsConstraintValid;

procedure asn1SccT_UInt8_Encode_aux(val : asn1SccT_UInt8; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is

begin
    result := asn1SccT_UInt8_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        adaasn1rtl.encoding.uper.UPER_Enc_ConstraintPosWholeNumber(bs, val, 0, 8);
    end if;

end asn1SccT_UInt8_Encode_aux;

procedure asn1SccT_UInt8_Encode(val : asn1SccT_UInt8; Stream : out asn1SccT_UInt8_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := asn1SccT_UInt8_uPER_Stream'(Size_In_Bytes => asn1SccT_UInt8_REQUIRED_BYTES_FOR_ENCODING, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    asn1SccT_UInt8_Encode_aux(val, Stream, result);
end asn1SccT_UInt8_Encode;

procedure asn1SccT_UInt8_Decode_aux(val: out asn1SccT_UInt8; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    result.ErrorCode := ERR_UPER_DECODE_T_UINT8;
    adaasn1rtl.encoding.uper.UPER_Dec_ConstraintPosWholeNumber(bs, val, 0, 255, 8, result.Success);
end asn1SccT_UInt8_Decode_aux;
procedure asn1SccT_UInt8_Decode(val:out asn1SccT_UInt8; Stream : IN OUT asn1SccT_UInt8_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    asn1SccT_UInt8_Decode_aux(val, Stream, result);
    if result.success then
        result := asn1SccT_UInt8_IsConstraintValid(val);
    end if;

end asn1SccT_UInt8_Decode;



function asn1SccT_Boolean_Equal (val1, val2 :  asn1SccT_Boolean) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_Boolean_Equal;

function asn1SccT_Boolean_Init return asn1SccT_Boolean
is
    val: asn1SccT_Boolean;
begin
    val := FALSE;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_Boolean_Init;

function asn1SccT_Boolean_IsConstraintValid(val : asn1SccT_Boolean) return adaasn1rtl.ASN1_RESULT
is
    pragma Unreferenced (val);
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    return ret;
end asn1SccT_Boolean_IsConstraintValid;

procedure asn1SccT_Boolean_Encode_aux(val : asn1SccT_Boolean; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is

begin
    result := asn1SccT_Boolean_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        adaasn1rtl.encoding.uper.UPER_Enc_Boolean(bs, val);
    end if;

end asn1SccT_Boolean_Encode_aux;

procedure asn1SccT_Boolean_Encode(val : asn1SccT_Boolean; Stream : out asn1SccT_Boolean_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := asn1SccT_Boolean_uPER_Stream'(Size_In_Bytes => asn1SccT_Boolean_REQUIRED_BYTES_FOR_ENCODING, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    asn1SccT_Boolean_Encode_aux(val, Stream, result);
end asn1SccT_Boolean_Encode;

procedure asn1SccT_Boolean_Decode_aux(val: out asn1SccT_Boolean; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    result.ErrorCode := ERR_UPER_DECODE_T_BOOLEAN;
    adaasn1rtl.encoding.uper.UPER_Dec_boolean(bs, val, result.Success);
end asn1SccT_Boolean_Decode_aux;
procedure asn1SccT_Boolean_Decode(val:out asn1SccT_Boolean; Stream : IN OUT asn1SccT_Boolean_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    asn1SccT_Boolean_Decode_aux(val, Stream, result);
    if result.success then
        result := asn1SccT_Boolean_IsConstraintValid(val);
    end if;

end asn1SccT_Boolean_Decode;



function asn1SccT_Null_Record_Equal (val1, val2 :  asn1SccT_Null_Record) return Boolean
is
   pragma Unreferenced (val1);
   pragma Unreferenced (val2);

begin
	return True;

end asn1SccT_Null_Record_Equal;

function asn1SccT_Null_Record_Init return asn1SccT_Null_Record
is
    val: asn1SccT_Null_Record;
begin
    val := (null record);
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_Null_Record_Init;

function asn1SccT_Null_Record_IsConstraintValid(val : asn1SccT_Null_Record) return adaasn1rtl.ASN1_RESULT
is
    pragma Unreferenced (val);
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    return ret;
end asn1SccT_Null_Record_IsConstraintValid;

procedure asn1SccT_Null_Record_Encode_aux(val : asn1SccT_Null_Record; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
    pragma Unreferenced (bs);

begin
    result := asn1SccT_Null_Record_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        null;
    end if;

end asn1SccT_Null_Record_Encode_aux;

procedure asn1SccT_Null_Record_Encode(val : asn1SccT_Null_Record; Stream : out asn1SccT_Null_Record_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := asn1SccT_Null_Record_uPER_Stream'(Size_In_Bytes => 1, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    asn1SccT_Null_Record_Encode_aux(val, Stream, result);
end asn1SccT_Null_Record_Encode;

procedure asn1SccT_Null_Record_Decode_aux(val: out asn1SccT_Null_Record; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    null;
end asn1SccT_Null_Record_Decode_aux;
procedure asn1SccT_Null_Record_Decode(val:out asn1SccT_Null_Record; Stream : IN OUT asn1SccT_Null_Record_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    asn1SccT_Null_Record_Decode_aux(val, Stream, result);
    if result.success then
        result := asn1SccT_Null_Record_IsConstraintValid(val);
    end if;

end asn1SccT_Null_Record_Decode;


pragma Warnings (On, "condition can only be False if invalid values present");
pragma Warnings (On, "condition can only be True if invalid values present");

 
end TASTE_BasicTypes;