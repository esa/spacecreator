pragma Style_Checks (Off);
--  Code automatically generated by asn1scc tool
pragma Warnings (Off, "redundant with clause in body");

pragma Warnings (Off, "no entities of ""adaasn1rtl.encoding.uper"" are referenced");
pragma Warnings (Off, "use clause for package ""adaasn1rtl.encoding.uper"" has no effect");
pragma Warnings (Off, "unit ""adaasn1rtl.encoding.uper"" is not referenced");
with adaasn1rtl.encoding.uper;
pragma Warnings (On, "no entities of ""adaasn1rtl.encoding.uper"" are referenced");
pragma Warnings (On, "use clause for package ""adaasn1rtl.encoding.uper"" has no effect");
pragma Warnings (On, "unit ""adaasn1rtl.encoding.uper"" is not referenced");


pragma Warnings (Off, "no entities of ""SYNCPROCEDURES_DATAVIEW"" are referenced");
pragma Warnings (Off, "use clause for package ""SYNCPROCEDURES_DATAVIEW"" has no effect");
pragma Warnings (Off, "unit ""SYNCPROCEDURES_DATAVIEW"" is not referenced");
with SYNCPROCEDURES_DATAVIEW;
pragma Warnings (On, "no entities of ""SYNCPROCEDURES_DATAVIEW"" are referenced");
pragma Warnings (On, "use clause for package ""SYNCPROCEDURES_DATAVIEW"" has no effect");
pragma Warnings (On, "unit ""SYNCPROCEDURES_DATAVIEW"" is not referenced");


pragma Warnings (Off, "no entities of ""Pinger_Datamodel"" are referenced");
pragma Warnings (Off, "use clause for package ""Pinger_Datamodel"" has no effect");
pragma Warnings (Off, "unit ""Pinger_Datamodel"" is not referenced");
with Pinger_Datamodel;
pragma Warnings (On, "no entities of ""Pinger_Datamodel"" are referenced");
pragma Warnings (On, "use clause for package ""Pinger_Datamodel"" has no effect");
pragma Warnings (On, "unit ""Pinger_Datamodel"" is not referenced");


pragma Warnings (Off, "no entities of ""Ponger_Datamodel"" are referenced");
pragma Warnings (Off, "use clause for package ""Ponger_Datamodel"" has no effect");
pragma Warnings (Off, "unit ""Ponger_Datamodel"" is not referenced");
with Ponger_Datamodel;
pragma Warnings (On, "no entities of ""Ponger_Datamodel"" are referenced");
pragma Warnings (On, "use clause for package ""Ponger_Datamodel"" has no effect");
pragma Warnings (On, "unit ""Ponger_Datamodel"" is not referenced");

pragma Warnings (On, "redundant with clause in body");

pragma Warnings (Off, "use clause for type");
pragma Warnings (Off, "is already use-visible through previous use_type_clause at");
use type SYNCPROCEDURES_DATAVIEW.asn1SccMyInteger;
use type Pinger_Datamodel.asn1SccPinger_Context;
use type Pinger_Datamodel.asn1SccPinger_States;
use type Ponger_Datamodel.asn1SccPonger_Context;
use type Ponger_Datamodel.asn1SccPonger_States;
pragma Warnings (On, "use clause for type");
pragma Warnings (On, "is already use-visible through previous use_type_clause at");
package body Simulation_DataView with SPARK_Mode is



pragma Warnings (Off, "condition can only be False if invalid values present");
pragma Warnings (Off, "condition can only be True if invalid values present");


function asn1SccPinger_Event_msg_in_input_none_Equal (val1, val2 :  asn1SccPinger_Event_msg_in_input_none) return Boolean
is
   pragma Unreferenced (val1);
   pragma Unreferenced (val2);

begin
	return True;

end asn1SccPinger_Event_msg_in_input_none_Equal;

function asn1SccPinger_Event_msg_in_pong_Equal (val1, val2 :  asn1SccPinger_Event_msg_in_pong) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (val1.pongarg = val2.pongarg);

	return ret;

end asn1SccPinger_Event_msg_in_pong_Equal;

function asn1SccPinger_Event_msg_in_tick_Equal (val1, val2 :  asn1SccPinger_Event_msg_in_tick) return Boolean
is
   pragma Unreferenced (val1);
   pragma Unreferenced (val2);

begin
	return True;

end asn1SccPinger_Event_msg_in_tick_Equal;

function asn1SccPinger_Event_msg_in_Equal (val1, val2 :  asn1SccPinger_Event_msg_in) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when input_none_PRESENT =>
                ret := asn1SccPinger_Event_msg_in_input_none_Equal(val1.input_none, val2.input_none);
            when pong_PRESENT =>
                ret := asn1SccPinger_Event_msg_in_pong_Equal(val1.pong, val2.pong);
            when tick_PRESENT =>
                ret := asn1SccPinger_Event_msg_in_tick_Equal(val1.tick, val2.tick);
        end case;
    end if;
	return ret;

end asn1SccPinger_Event_msg_in_Equal;

function asn1SccPinger_Event_msg_out_ping_Equal (val1, val2 :  asn1SccPinger_Event_msg_out_ping) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (val1.pingarg = val2.pingarg);

	return ret;

end asn1SccPinger_Event_msg_out_ping_Equal;

function asn1SccPinger_Event_msg_out_Equal (val1, val2 :  asn1SccPinger_Event_msg_out) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when ping_PRESENT =>
                ret := asn1SccPinger_Event_msg_out_ping_Equal(val1.ping, val2.ping);
        end case;
    end if;
	return ret;

end asn1SccPinger_Event_msg_out_Equal;

function asn1SccPinger_Event_Equal (val1, val2 :  asn1SccPinger_Event) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when msg_in_PRESENT =>
                ret := asn1SccPinger_Event_msg_in_Equal(val1.msg_in, val2.msg_in);
            when msg_out_PRESENT =>
                ret := asn1SccPinger_Event_msg_out_Equal(val1.msg_out, val2.msg_out);
        end case;
    end if;
	return ret;

end asn1SccPinger_Event_Equal;

function asn1SccPinger_Event_msg_in_input_none_Init return asn1SccPinger_Event_msg_in_input_none
is
    val: asn1SccPinger_Event_msg_in_input_none;
begin
    val := (null record);
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPinger_Event_msg_in_input_none_Init;
function asn1SccPinger_Event_msg_in_pong_Init return asn1SccPinger_Event_msg_in_pong
is
    val: asn1SccPinger_Event_msg_in_pong;
begin

    --set pongarg 
    val.pongarg := SYNCPROCEDURES_DATAVIEW.asn1SccMyInteger_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPinger_Event_msg_in_pong_Init;
function asn1SccPinger_Event_msg_in_tick_Init return asn1SccPinger_Event_msg_in_tick
is
    val: asn1SccPinger_Event_msg_in_tick;
begin
    val := (null record);
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPinger_Event_msg_in_tick_Init;
function asn1SccPinger_Event_msg_in_Init return asn1SccPinger_Event_msg_in
is
    val: asn1SccPinger_Event_msg_in;
begin
    --set input_none 
    declare
        input_none_tmp:asn1SccPinger_Event_msg_in_input_none;
    begin
        input_none_tmp := asn1SccPinger_Event_msg_in_input_none_Init;
    	pragma Warnings (Off, "object ""input_none_tmp"" is always False at this point");
        val := asn1SccPinger_Event_msg_in'(kind => input_none_PRESENT, input_none => input_none_tmp);
    	pragma Warnings (On, "object ""input_none_tmp"" is always False at this point");
    end;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPinger_Event_msg_in_Init;
function asn1SccPinger_Event_msg_out_ping_Init return asn1SccPinger_Event_msg_out_ping
is
    val: asn1SccPinger_Event_msg_out_ping;
begin

    --set pingarg 
    val.pingarg := SYNCPROCEDURES_DATAVIEW.asn1SccMyInteger_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPinger_Event_msg_out_ping_Init;
function asn1SccPinger_Event_msg_out_Init return asn1SccPinger_Event_msg_out
is
    val: asn1SccPinger_Event_msg_out;
begin
    --set ping 
    declare
        ping_tmp:asn1SccPinger_Event_msg_out_ping;
    begin
        ping_tmp := asn1SccPinger_Event_msg_out_ping_Init;
    	pragma Warnings (Off, "object ""ping_tmp"" is always False at this point");
        val := asn1SccPinger_Event_msg_out'(kind => ping_PRESENT, ping => ping_tmp);
    	pragma Warnings (On, "object ""ping_tmp"" is always False at this point");
    end;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPinger_Event_msg_out_Init;
function asn1SccPinger_Event_Init return asn1SccPinger_Event
is
    val: asn1SccPinger_Event;
begin
    --set msg_in 
    declare
        msg_in_tmp:asn1SccPinger_Event_msg_in;
    begin
        msg_in_tmp := asn1SccPinger_Event_msg_in_Init;
    	pragma Warnings (Off, "object ""msg_in_tmp"" is always False at this point");
        val := asn1SccPinger_Event'(kind => msg_in_PRESENT, msg_in => msg_in_tmp);
    	pragma Warnings (On, "object ""msg_in_tmp"" is always False at this point");
    end;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPinger_Event_Init;

function asn1SccPinger_Event_IsConstraintValid(val : asn1SccPinger_Event) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    if val.kind = msg_in_PRESENT then
    	if val.msg_in.kind = pong_PRESENT then
    		ret := SYNCPROCEDURES_DATAVIEW.asn1SccMyInteger_IsConstraintValid(val.msg_in.pong.pongarg);
    	end if;
    end if;
    if ret.Success then
        if val.kind = msg_out_PRESENT then
        	if val.msg_out.kind = ping_PRESENT then
        		ret := SYNCPROCEDURES_DATAVIEW.asn1SccMyInteger_IsConstraintValid(val.msg_out.ping.pingarg);
        	end if;
        end if;
    end if;
    return ret;
end asn1SccPinger_Event_IsConstraintValid;

procedure asn1SccPinger_Event_Encode_aux(val : asn1SccPinger_Event; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is

begin
    result := asn1SccPinger_Event_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        case val.kind is
            when msg_in_PRESENT =>
                adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, 0, 0, 1);
                case val.msg_in.kind is
                    when input_none_PRESENT =>
                        adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, 0, 0, 2);
                        --no encoding/decoding is required
                    when pong_PRESENT =>
                        adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, 1, 0, 2);
                        --Encode pongarg 
                        SYNCPROCEDURES_DATAVIEW.asn1SccMyInteger_Encode_aux(val.msg_in.pong.pongarg, bs, result);
                    when tick_PRESENT =>
                        adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, 2, 0, 2);
                        --no encoding/decoding is required
                end case;
            when msg_out_PRESENT =>
                adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, 1, 0, 1);
                case val.msg_out.kind is
                    when ping_PRESENT =>
                        adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, 0, 0, 0);
                        --Encode pingarg 
                        SYNCPROCEDURES_DATAVIEW.asn1SccMyInteger_Encode_aux(val.msg_out.ping.pingarg, bs, result);
                end case;
        end case;
    end if;

end asn1SccPinger_Event_Encode_aux;

procedure asn1SccPinger_Event_Encode(val : asn1SccPinger_Event; Stream : out asn1SccPinger_Event_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := asn1SccPinger_Event_uPER_Stream'(Size_In_Bytes => asn1SccPinger_Event_REQUIRED_BYTES_FOR_ENCODING, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    asn1SccPinger_Event_Encode_aux(val, Stream, result);
end asn1SccPinger_Event_Encode;

procedure asn1SccPinger_Event_Decode_aux(val: out asn1SccPinger_Event; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
    asn1SccPinger_Event_index_tmp:adaasn1rtl.Asn1Int;
    asn1SccPinger_Event_msg_in_index_tmp:adaasn1rtl.Asn1Int;
    asn1SccPinger_Event_msg_out_index_tmp:adaasn1rtl.Asn1Int;
begin
    result.ErrorCode := ERR_UPER_DECODE_PINGER_EVENT;
    adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumber(bs, asn1SccPinger_Event_index_tmp, 0, 1, 1, result.Success);
    if result.Success and asn1SccPinger_Event_index_tmp >= 0 and  asn1SccPinger_Event_index_tmp <= 1 then
        case asn1SccPinger_Event_index_range(asn1SccPinger_Event_index_tmp) is
            when 0 =>
              declare
                 msg_in_tmp:asn1SccPinger_Event_msg_in;
              begin
                result.ErrorCode := ERR_UPER_DECODE_PINGER_EVENT_MSG_IN;
                adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumber(bs, asn1SccPinger_Event_msg_in_index_tmp, 0, 2, 2, result.Success);
                if result.Success and asn1SccPinger_Event_msg_in_index_tmp >= 0 and  asn1SccPinger_Event_msg_in_index_tmp <= 2 then
                    case asn1SccPinger_Event_msg_in_index_range(asn1SccPinger_Event_msg_in_index_tmp) is
                        when 0 =>
                          declare
                             input_none_tmp:asn1SccPinger_Event_msg_in_input_none;
                          begin
                            input_none_tmp := (null record);
                            result := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
                            if result.Success then
                                msg_in_tmp := asn1SccPinger_Event_msg_in'(kind => input_none_PRESENT, input_none => input_none_tmp);
                                pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                            end if;
                          end;
                        when 1 =>
                          declare
                             pong_tmp:asn1SccPinger_Event_msg_in_pong;
                          begin
                            --Decode pongarg 
                            SYNCPROCEDURES_DATAVIEW.asn1SccMyInteger_Decode_aux(pong_tmp.pongarg, bs, result);
                            if result.Success then
                                msg_in_tmp := asn1SccPinger_Event_msg_in'(kind => pong_PRESENT, pong => pong_tmp);
                                pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                            end if;
                          end;
                        when 2 =>
                          declare
                             tick_tmp:asn1SccPinger_Event_msg_in_tick;
                          begin
                            tick_tmp := (null record);
                            result := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
                            if result.Success then
                                msg_in_tmp := asn1SccPinger_Event_msg_in'(kind => tick_PRESENT, tick => tick_tmp);
                                pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                            end if;
                          end;
                    end case;
                end if;
                if result.Success then
                    val := asn1SccPinger_Event'(kind => msg_in_PRESENT, msg_in => msg_in_tmp);
                    pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                end if;
              end;
            when 1 =>
              declare
                 msg_out_tmp:asn1SccPinger_Event_msg_out;
              begin
                result.ErrorCode := ERR_UPER_DECODE_PINGER_EVENT_MSG_OUT;
                adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumber(bs, asn1SccPinger_Event_msg_out_index_tmp, 0, 0, 0, result.Success);
                if result.Success and asn1SccPinger_Event_msg_out_index_tmp >= 0 and  asn1SccPinger_Event_msg_out_index_tmp <= 0 then
                    case asn1SccPinger_Event_msg_out_index_range(asn1SccPinger_Event_msg_out_index_tmp) is
                        when 0 =>
                          declare
                             ping_tmp:asn1SccPinger_Event_msg_out_ping;
                          begin
                            --Decode pingarg 
                            SYNCPROCEDURES_DATAVIEW.asn1SccMyInteger_Decode_aux(ping_tmp.pingarg, bs, result);
                            if result.Success then
                                msg_out_tmp := asn1SccPinger_Event_msg_out'(kind => ping_PRESENT, ping => ping_tmp);
                                pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                            end if;
                          end;
                    end case;
                end if;
                if result.Success then
                    val := asn1SccPinger_Event'(kind => msg_out_PRESENT, msg_out => msg_out_tmp);
                    pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                end if;
              end;
        end case;
    end if;
end asn1SccPinger_Event_Decode_aux;
procedure asn1SccPinger_Event_Decode(val:out asn1SccPinger_Event; Stream : IN OUT asn1SccPinger_Event_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    asn1SccPinger_Event_Decode_aux(val, Stream, result);
    if result.success then
        result := asn1SccPinger_Event_IsConstraintValid(val);
    end if;

end asn1SccPinger_Event_Decode;



function asn1SccPonger_Event_msg_in_input_none_Equal (val1, val2 :  asn1SccPonger_Event_msg_in_input_none) return Boolean
is
   pragma Unreferenced (val1);
   pragma Unreferenced (val2);

begin
	return True;

end asn1SccPonger_Event_msg_in_input_none_Equal;

function asn1SccPonger_Event_msg_in_ping_Equal (val1, val2 :  asn1SccPonger_Event_msg_in_ping) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (val1.pingarg = val2.pingarg);

	return ret;

end asn1SccPonger_Event_msg_in_ping_Equal;

function asn1SccPonger_Event_msg_in_Equal (val1, val2 :  asn1SccPonger_Event_msg_in) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when input_none_PRESENT =>
                ret := asn1SccPonger_Event_msg_in_input_none_Equal(val1.input_none, val2.input_none);
            when ping_PRESENT =>
                ret := asn1SccPonger_Event_msg_in_ping_Equal(val1.ping, val2.ping);
        end case;
    end if;
	return ret;

end asn1SccPonger_Event_msg_in_Equal;

function asn1SccPonger_Event_msg_out_pong_Equal (val1, val2 :  asn1SccPonger_Event_msg_out_pong) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (val1.pongarg = val2.pongarg);

	return ret;

end asn1SccPonger_Event_msg_out_pong_Equal;

function asn1SccPonger_Event_msg_out_Equal (val1, val2 :  asn1SccPonger_Event_msg_out) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when pong_PRESENT =>
                ret := asn1SccPonger_Event_msg_out_pong_Equal(val1.pong, val2.pong);
        end case;
    end if;
	return ret;

end asn1SccPonger_Event_msg_out_Equal;

function asn1SccPonger_Event_Equal (val1, val2 :  asn1SccPonger_Event) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when msg_in_PRESENT =>
                ret := asn1SccPonger_Event_msg_in_Equal(val1.msg_in, val2.msg_in);
            when msg_out_PRESENT =>
                ret := asn1SccPonger_Event_msg_out_Equal(val1.msg_out, val2.msg_out);
        end case;
    end if;
	return ret;

end asn1SccPonger_Event_Equal;

function asn1SccPonger_Event_msg_in_input_none_Init return asn1SccPonger_Event_msg_in_input_none
is
    val: asn1SccPonger_Event_msg_in_input_none;
begin
    val := (null record);
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPonger_Event_msg_in_input_none_Init;
function asn1SccPonger_Event_msg_in_ping_Init return asn1SccPonger_Event_msg_in_ping
is
    val: asn1SccPonger_Event_msg_in_ping;
begin

    --set pingarg 
    val.pingarg := SYNCPROCEDURES_DATAVIEW.asn1SccMyInteger_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPonger_Event_msg_in_ping_Init;
function asn1SccPonger_Event_msg_in_Init return asn1SccPonger_Event_msg_in
is
    val: asn1SccPonger_Event_msg_in;
begin
    --set input_none 
    declare
        input_none_tmp:asn1SccPonger_Event_msg_in_input_none;
    begin
        input_none_tmp := asn1SccPonger_Event_msg_in_input_none_Init;
    	pragma Warnings (Off, "object ""input_none_tmp"" is always False at this point");
        val := asn1SccPonger_Event_msg_in'(kind => input_none_PRESENT, input_none => input_none_tmp);
    	pragma Warnings (On, "object ""input_none_tmp"" is always False at this point");
    end;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPonger_Event_msg_in_Init;
function asn1SccPonger_Event_msg_out_pong_Init return asn1SccPonger_Event_msg_out_pong
is
    val: asn1SccPonger_Event_msg_out_pong;
begin

    --set pongarg 
    val.pongarg := SYNCPROCEDURES_DATAVIEW.asn1SccMyInteger_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPonger_Event_msg_out_pong_Init;
function asn1SccPonger_Event_msg_out_Init return asn1SccPonger_Event_msg_out
is
    val: asn1SccPonger_Event_msg_out;
begin
    --set pong 
    declare
        pong_tmp:asn1SccPonger_Event_msg_out_pong;
    begin
        pong_tmp := asn1SccPonger_Event_msg_out_pong_Init;
    	pragma Warnings (Off, "object ""pong_tmp"" is always False at this point");
        val := asn1SccPonger_Event_msg_out'(kind => pong_PRESENT, pong => pong_tmp);
    	pragma Warnings (On, "object ""pong_tmp"" is always False at this point");
    end;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPonger_Event_msg_out_Init;
function asn1SccPonger_Event_Init return asn1SccPonger_Event
is
    val: asn1SccPonger_Event;
begin
    --set msg_in 
    declare
        msg_in_tmp:asn1SccPonger_Event_msg_in;
    begin
        msg_in_tmp := asn1SccPonger_Event_msg_in_Init;
    	pragma Warnings (Off, "object ""msg_in_tmp"" is always False at this point");
        val := asn1SccPonger_Event'(kind => msg_in_PRESENT, msg_in => msg_in_tmp);
    	pragma Warnings (On, "object ""msg_in_tmp"" is always False at this point");
    end;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPonger_Event_Init;

function asn1SccPonger_Event_IsConstraintValid(val : asn1SccPonger_Event) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    if val.kind = msg_in_PRESENT then
    	if val.msg_in.kind = ping_PRESENT then
    		ret := SYNCPROCEDURES_DATAVIEW.asn1SccMyInteger_IsConstraintValid(val.msg_in.ping.pingarg);
    	end if;
    end if;
    if ret.Success then
        if val.kind = msg_out_PRESENT then
        	if val.msg_out.kind = pong_PRESENT then
        		ret := SYNCPROCEDURES_DATAVIEW.asn1SccMyInteger_IsConstraintValid(val.msg_out.pong.pongarg);
        	end if;
        end if;
    end if;
    return ret;
end asn1SccPonger_Event_IsConstraintValid;

procedure asn1SccPonger_Event_Encode_aux(val : asn1SccPonger_Event; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is

begin
    result := asn1SccPonger_Event_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        case val.kind is
            when msg_in_PRESENT =>
                adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, 0, 0, 1);
                case val.msg_in.kind is
                    when input_none_PRESENT =>
                        adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, 0, 0, 1);
                        --no encoding/decoding is required
                    when ping_PRESENT =>
                        adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, 1, 0, 1);
                        --Encode pingarg 
                        SYNCPROCEDURES_DATAVIEW.asn1SccMyInteger_Encode_aux(val.msg_in.ping.pingarg, bs, result);
                end case;
            when msg_out_PRESENT =>
                adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, 1, 0, 1);
                case val.msg_out.kind is
                    when pong_PRESENT =>
                        adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, 0, 0, 0);
                        --Encode pongarg 
                        SYNCPROCEDURES_DATAVIEW.asn1SccMyInteger_Encode_aux(val.msg_out.pong.pongarg, bs, result);
                end case;
        end case;
    end if;

end asn1SccPonger_Event_Encode_aux;

procedure asn1SccPonger_Event_Encode(val : asn1SccPonger_Event; Stream : out asn1SccPonger_Event_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := asn1SccPonger_Event_uPER_Stream'(Size_In_Bytes => asn1SccPonger_Event_REQUIRED_BYTES_FOR_ENCODING, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    asn1SccPonger_Event_Encode_aux(val, Stream, result);
end asn1SccPonger_Event_Encode;

procedure asn1SccPonger_Event_Decode_aux(val: out asn1SccPonger_Event; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
    asn1SccPonger_Event_index_tmp:adaasn1rtl.Asn1Int;
    asn1SccPonger_Event_msg_in_index_tmp:adaasn1rtl.Asn1Int;
    asn1SccPonger_Event_msg_out_index_tmp:adaasn1rtl.Asn1Int;
begin
    result.ErrorCode := ERR_UPER_DECODE_PONGER_EVENT;
    adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumber(bs, asn1SccPonger_Event_index_tmp, 0, 1, 1, result.Success);
    if result.Success and asn1SccPonger_Event_index_tmp >= 0 and  asn1SccPonger_Event_index_tmp <= 1 then
        case asn1SccPonger_Event_index_range(asn1SccPonger_Event_index_tmp) is
            when 0 =>
              declare
                 msg_in_tmp:asn1SccPonger_Event_msg_in;
              begin
                result.ErrorCode := ERR_UPER_DECODE_PONGER_EVENT_MSG_IN;
                adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumber(bs, asn1SccPonger_Event_msg_in_index_tmp, 0, 1, 1, result.Success);
                if result.Success and asn1SccPonger_Event_msg_in_index_tmp >= 0 and  asn1SccPonger_Event_msg_in_index_tmp <= 1 then
                    case asn1SccPonger_Event_msg_in_index_range(asn1SccPonger_Event_msg_in_index_tmp) is
                        when 0 =>
                          declare
                             input_none_tmp:asn1SccPonger_Event_msg_in_input_none;
                          begin
                            input_none_tmp := (null record);
                            result := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
                            if result.Success then
                                msg_in_tmp := asn1SccPonger_Event_msg_in'(kind => input_none_PRESENT, input_none => input_none_tmp);
                                pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                            end if;
                          end;
                        when 1 =>
                          declare
                             ping_tmp:asn1SccPonger_Event_msg_in_ping;
                          begin
                            --Decode pingarg 
                            SYNCPROCEDURES_DATAVIEW.asn1SccMyInteger_Decode_aux(ping_tmp.pingarg, bs, result);
                            if result.Success then
                                msg_in_tmp := asn1SccPonger_Event_msg_in'(kind => ping_PRESENT, ping => ping_tmp);
                                pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                            end if;
                          end;
                    end case;
                end if;
                if result.Success then
                    val := asn1SccPonger_Event'(kind => msg_in_PRESENT, msg_in => msg_in_tmp);
                    pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                end if;
              end;
            when 1 =>
              declare
                 msg_out_tmp:asn1SccPonger_Event_msg_out;
              begin
                result.ErrorCode := ERR_UPER_DECODE_PONGER_EVENT_MSG_OUT;
                adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumber(bs, asn1SccPonger_Event_msg_out_index_tmp, 0, 0, 0, result.Success);
                if result.Success and asn1SccPonger_Event_msg_out_index_tmp >= 0 and  asn1SccPonger_Event_msg_out_index_tmp <= 0 then
                    case asn1SccPonger_Event_msg_out_index_range(asn1SccPonger_Event_msg_out_index_tmp) is
                        when 0 =>
                          declare
                             pong_tmp:asn1SccPonger_Event_msg_out_pong;
                          begin
                            --Decode pongarg 
                            SYNCPROCEDURES_DATAVIEW.asn1SccMyInteger_Decode_aux(pong_tmp.pongarg, bs, result);
                            if result.Success then
                                msg_out_tmp := asn1SccPonger_Event_msg_out'(kind => pong_PRESENT, pong => pong_tmp);
                                pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                            end if;
                          end;
                    end case;
                end if;
                if result.Success then
                    val := asn1SccPonger_Event'(kind => msg_out_PRESENT, msg_out => msg_out_tmp);
                    pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                end if;
              end;
        end case;
    end if;
end asn1SccPonger_Event_Decode_aux;
procedure asn1SccPonger_Event_Decode(val:out asn1SccPonger_Event; Stream : IN OUT asn1SccPonger_Event_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    asn1SccPonger_Event_Decode_aux(val, Stream, result);
    if result.success then
        result := asn1SccPonger_Event_IsConstraintValid(val);
    end if;

end asn1SccPonger_Event_Decode;



function asn1SccPID_Equal (val1, val2 :  asn1SccPID) return Boolean
is

begin
	return val1 = val2;

end asn1SccPID_Equal;

function asn1SccPID_Init return asn1SccPID
is
    val: asn1SccPID;
begin
    val := asn1Sccenv;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPID_Init;

function asn1SccPID_IsConstraintValid(val : asn1SccPID) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((((((val = asn1Sccenv)) OR ((val = asn1Sccclock)))) OR ((val = asn1Sccpinger)))) OR ((val = asn1Sccponger)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_PID);
    return ret;
end asn1SccPID_IsConstraintValid;

procedure asn1SccPID_Encode_aux(val : asn1SccPID; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is

begin
    result := asn1SccPID_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        declare
            intVal:Asn1Int;
        begin
            case val is 
                when asn1Sccenv    => intVal := 0;
                when asn1Sccclock    => intVal := 1;
                when asn1Sccpinger    => intVal := 2;
                when asn1Sccponger    => intVal := 3;
            end case;
            adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, intVal, 0, 2);
        end;
    end if;

end asn1SccPID_Encode_aux;

procedure asn1SccPID_Encode(val : asn1SccPID; Stream : out asn1SccPID_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := asn1SccPID_uPER_Stream'(Size_In_Bytes => asn1SccPID_REQUIRED_BYTES_FOR_ENCODING, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    asn1SccPID_Encode_aux(val, Stream, result);
end asn1SccPID_Encode;

procedure asn1SccPID_Decode_aux(val: out asn1SccPID; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    declare
        intVal:Asn1Int;
    begin
        adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumber(bs, intVal, 0, 3, 2, result.Success);
        if result.Success then
            case asn1SccPID_index_range(intVal) is
                when 0 => val := asn1Sccenv;
                when 1 => val := asn1Sccclock;
                when 2 => val := asn1Sccpinger;
                when 3 => val := asn1Sccponger;
            end case;
            result.ErrorCode := 0;
        else
            val := asn1Sccenv;					-- COVERAGE_IGNORE
            result.ErrorCode := ERR_UPER_DECODE_PID;				-- COVERAGE_IGNORE
        end if;
    end;
end asn1SccPID_Decode_aux;
procedure asn1SccPID_Decode(val:out asn1SccPID; Stream : IN OUT asn1SccPID_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    asn1SccPID_Decode_aux(val, Stream, result);
    if result.success then
        result := asn1SccPID_IsConstraintValid(val);
    end if;

end asn1SccPID_Decode;



function asn1SccClock_Event_msg_out_tick_Equal (val1, val2 :  asn1SccClock_Event_msg_out_tick) return Boolean
is
   pragma Unreferenced (val1);
   pragma Unreferenced (val2);

begin
	return True;

end asn1SccClock_Event_msg_out_tick_Equal;

function asn1SccClock_Event_msg_out_Equal (val1, val2 :  asn1SccClock_Event_msg_out) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when tick_PRESENT =>
                ret := asn1SccClock_Event_msg_out_tick_Equal(val1.tick, val2.tick);
        end case;
    end if;
	return ret;

end asn1SccClock_Event_msg_out_Equal;

function asn1SccClock_Event_Equal (val1, val2 :  asn1SccClock_Event) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when msg_out_PRESENT =>
                ret := asn1SccClock_Event_msg_out_Equal(val1.msg_out, val2.msg_out);
        end case;
    end if;
	return ret;

end asn1SccClock_Event_Equal;

function asn1SccClock_Event_msg_out_tick_Init return asn1SccClock_Event_msg_out_tick
is
    val: asn1SccClock_Event_msg_out_tick;
begin
    val := (null record);
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccClock_Event_msg_out_tick_Init;
function asn1SccClock_Event_msg_out_Init return asn1SccClock_Event_msg_out
is
    val: asn1SccClock_Event_msg_out;
begin
    --set tick 
    declare
        tick_tmp:asn1SccClock_Event_msg_out_tick;
    begin
        tick_tmp := asn1SccClock_Event_msg_out_tick_Init;
    	pragma Warnings (Off, "object ""tick_tmp"" is always False at this point");
        val := asn1SccClock_Event_msg_out'(kind => tick_PRESENT, tick => tick_tmp);
    	pragma Warnings (On, "object ""tick_tmp"" is always False at this point");
    end;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccClock_Event_msg_out_Init;
function asn1SccClock_Event_Init return asn1SccClock_Event
is
    val: asn1SccClock_Event;
begin
    --set msg_out 
    declare
        msg_out_tmp:asn1SccClock_Event_msg_out;
    begin
        msg_out_tmp := asn1SccClock_Event_msg_out_Init;
    	pragma Warnings (Off, "object ""msg_out_tmp"" is always False at this point");
        val := asn1SccClock_Event'(kind => msg_out_PRESENT, msg_out => msg_out_tmp);
    	pragma Warnings (On, "object ""msg_out_tmp"" is always False at this point");
    end;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccClock_Event_Init;

function asn1SccClock_Event_IsConstraintValid(val : asn1SccClock_Event) return adaasn1rtl.ASN1_RESULT
is
    pragma Unreferenced (val);
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    return ret;
end asn1SccClock_Event_IsConstraintValid;

procedure asn1SccClock_Event_Encode_aux(val : asn1SccClock_Event; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is

begin
    result := asn1SccClock_Event_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        case val.kind is
            when msg_out_PRESENT =>
                adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, 0, 0, 0);
                case val.msg_out.kind is
                    when tick_PRESENT =>
                        adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, 0, 0, 0);
                        --no encoding/decoding is required
                end case;
        end case;
    end if;

end asn1SccClock_Event_Encode_aux;

procedure asn1SccClock_Event_Encode(val : asn1SccClock_Event; Stream : out asn1SccClock_Event_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := asn1SccClock_Event_uPER_Stream'(Size_In_Bytes => 1, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    asn1SccClock_Event_Encode_aux(val, Stream, result);
end asn1SccClock_Event_Encode;

procedure asn1SccClock_Event_Decode_aux(val: out asn1SccClock_Event; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
    asn1SccClock_Event_index_tmp:adaasn1rtl.Asn1Int;
    asn1SccClock_Event_msg_out_index_tmp:adaasn1rtl.Asn1Int;
begin
    result.ErrorCode := ERR_UPER_DECODE_CLOCK_EVENT;
    adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumber(bs, asn1SccClock_Event_index_tmp, 0, 0, 0, result.Success);
    if result.Success and asn1SccClock_Event_index_tmp >= 0 and  asn1SccClock_Event_index_tmp <= 0 then
        case asn1SccClock_Event_index_range(asn1SccClock_Event_index_tmp) is
            when 0 =>
              declare
                 msg_out_tmp:asn1SccClock_Event_msg_out;
              begin
                result.ErrorCode := ERR_UPER_DECODE_CLOCK_EVENT_MSG_OUT;
                adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumber(bs, asn1SccClock_Event_msg_out_index_tmp, 0, 0, 0, result.Success);
                if result.Success and asn1SccClock_Event_msg_out_index_tmp >= 0 and  asn1SccClock_Event_msg_out_index_tmp <= 0 then
                    case asn1SccClock_Event_msg_out_index_range(asn1SccClock_Event_msg_out_index_tmp) is
                        when 0 =>
                          declare
                             tick_tmp:asn1SccClock_Event_msg_out_tick;
                          begin
                            tick_tmp := (null record);
                            result := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
                            if result.Success then
                                msg_out_tmp := asn1SccClock_Event_msg_out'(kind => tick_PRESENT, tick => tick_tmp);
                                pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                            end if;
                          end;
                    end case;
                end if;
                if result.Success then
                    val := asn1SccClock_Event'(kind => msg_out_PRESENT, msg_out => msg_out_tmp);
                    pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                end if;
              end;
        end case;
    end if;
end asn1SccClock_Event_Decode_aux;
procedure asn1SccClock_Event_Decode(val:out asn1SccClock_Event; Stream : IN OUT asn1SccClock_Event_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    asn1SccClock_Event_Decode_aux(val, Stream, result);
    if result.success then
        result := asn1SccClock_Event_IsConstraintValid(val);
    end if;

end asn1SccClock_Event_Decode;



function asn1SccFunction_Event_Equal (val1, val2 :  asn1SccFunction_Event) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when clock_PRESENT =>
                ret := asn1SccClock_Event_Equal(val1.clock, val2.clock);
            when pinger_PRESENT =>
                ret := asn1SccPinger_Event_Equal(val1.pinger, val2.pinger);
            when ponger_PRESENT =>
                ret := asn1SccPonger_Event_Equal(val1.ponger, val2.ponger);
        end case;
    end if;
	return ret;

end asn1SccFunction_Event_Equal;

function asn1SccFunction_Event_Init return asn1SccFunction_Event
is
    val: asn1SccFunction_Event;
begin
    --set clock 
    declare
        clock_tmp:asn1SccClock_Event;
    begin
        clock_tmp := asn1SccClock_Event_Init;
    	pragma Warnings (Off, "object ""clock_tmp"" is always False at this point");
        val := asn1SccFunction_Event'(kind => clock_PRESENT, clock => clock_tmp);
    	pragma Warnings (On, "object ""clock_tmp"" is always False at this point");
    end;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccFunction_Event_Init;

function asn1SccFunction_Event_IsConstraintValid(val : asn1SccFunction_Event) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    if val.kind = clock_PRESENT then
    	ret := asn1SccClock_Event_IsConstraintValid(val.clock);
    end if;
    if ret.Success then
        if val.kind = pinger_PRESENT then
        	ret := asn1SccPinger_Event_IsConstraintValid(val.pinger);
        end if;
        if ret.Success then
            if val.kind = ponger_PRESENT then
            	ret := asn1SccPonger_Event_IsConstraintValid(val.ponger);
            end if;
        end if;
    end if;
    return ret;
end asn1SccFunction_Event_IsConstraintValid;

procedure asn1SccFunction_Event_Encode_aux(val : asn1SccFunction_Event; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is

begin
    result := asn1SccFunction_Event_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        case val.kind is
            when clock_PRESENT =>
                adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, 0, 0, 2);
                asn1SccClock_Event_Encode_aux(val.clock, bs, result);
            when pinger_PRESENT =>
                adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, 1, 0, 2);
                asn1SccPinger_Event_Encode_aux(val.pinger, bs, result);
            when ponger_PRESENT =>
                adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, 2, 0, 2);
                asn1SccPonger_Event_Encode_aux(val.ponger, bs, result);
        end case;
    end if;

end asn1SccFunction_Event_Encode_aux;

procedure asn1SccFunction_Event_Encode(val : asn1SccFunction_Event; Stream : out asn1SccFunction_Event_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := asn1SccFunction_Event_uPER_Stream'(Size_In_Bytes => asn1SccFunction_Event_REQUIRED_BYTES_FOR_ENCODING, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    asn1SccFunction_Event_Encode_aux(val, Stream, result);
end asn1SccFunction_Event_Encode;

procedure asn1SccFunction_Event_Decode_aux(val: out asn1SccFunction_Event; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
    asn1SccFunction_Event_index_tmp:adaasn1rtl.Asn1Int;
begin
    result.ErrorCode := ERR_UPER_DECODE_FUNCTION_EVENT;
    adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumber(bs, asn1SccFunction_Event_index_tmp, 0, 2, 2, result.Success);
    if result.Success and asn1SccFunction_Event_index_tmp >= 0 and  asn1SccFunction_Event_index_tmp <= 2 then
        case asn1SccFunction_Event_index_range(asn1SccFunction_Event_index_tmp) is
            when 0 =>
              declare
                 clock_tmp:asn1SccClock_Event;
              begin
                asn1SccClock_Event_Decode_aux(clock_tmp, bs, result);
                if result.Success then
                    val := asn1SccFunction_Event'(kind => clock_PRESENT, clock => clock_tmp);
                    pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                end if;
              end;
            when 1 =>
              declare
                 pinger_tmp:asn1SccPinger_Event;
              begin
                asn1SccPinger_Event_Decode_aux(pinger_tmp, bs, result);
                if result.Success then
                    val := asn1SccFunction_Event'(kind => pinger_PRESENT, pinger => pinger_tmp);
                    pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                end if;
              end;
            when 2 =>
              declare
                 ponger_tmp:asn1SccPonger_Event;
              begin
                asn1SccPonger_Event_Decode_aux(ponger_tmp, bs, result);
                if result.Success then
                    val := asn1SccFunction_Event'(kind => ponger_PRESENT, ponger => ponger_tmp);
                    pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                end if;
              end;
        end case;
    end if;
end asn1SccFunction_Event_Decode_aux;
procedure asn1SccFunction_Event_Decode(val:out asn1SccFunction_Event; Stream : IN OUT asn1SccFunction_Event_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    asn1SccFunction_Event_Decode_aux(val, Stream, result);
    if result.success then
        result := asn1SccFunction_Event_IsConstraintValid(val);
    end if;

end asn1SccFunction_Event_Decode;



function asn1SccNamed_Function_Event_id_Equal (val1, val2 :  asn1SccNamed_Function_Event_id) return Boolean
is

begin
	return val1 = val2;

end asn1SccNamed_Function_Event_id_Equal;

function asn1SccNamed_Function_Event_Equal (val1, val2 :  asn1SccNamed_Function_Event) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := asn1SccNamed_Function_Event_id_Equal(val1.id, val2.id);

    if ret then
        ret := asn1SccFunction_Event_Equal(val1.event, val2.event);

    end if;
	return ret;

end asn1SccNamed_Function_Event_Equal;

function asn1SccNamed_Function_Event_id_Init return asn1SccNamed_Function_Event_id
is
    val: asn1SccNamed_Function_Event_id;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 81 loop
        --  commented because it casues this warning    
        --  warning: condition can only be False if invalid values present
        pragma Loop_Invariant (i1 >=1 and i1<=81);      
        val(i1) := adaasn1rtl.NUL;

        i1 := i1 + 1;
    end loop;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccNamed_Function_Event_id_Init;
function asn1SccNamed_Function_Event_Init return asn1SccNamed_Function_Event
is
    val: asn1SccNamed_Function_Event;
begin

    --set id 
    val.id := asn1SccNamed_Function_Event_id_Init;
    --set event 
    val.event := asn1SccFunction_Event_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccNamed_Function_Event_Init;

function asn1SccNamed_Function_Event_IsConstraintValid(val : asn1SccNamed_Function_Event) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := ((1 <= adaasn1rtl.getStringSize(val.id)) AND (adaasn1rtl.getStringSize(val.id) <= 80));
    ret.ErrorCode := (if ret.Success then 0 else ERR_NAMED_FUNCTION_EVENT_ID);
    if ret.Success then
        ret := asn1SccFunction_Event_IsConstraintValid(val.event);
    end if;
    return ret;
end asn1SccNamed_Function_Event_IsConstraintValid;

procedure asn1SccNamed_Function_Event_Encode_aux(val : asn1SccNamed_Function_Event; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is

    i1:Integer;
    charIndex:Integer;
    nStringLength:Integer;
begin
    result := asn1SccNamed_Function_Event_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        --Encode id 
        nStringLength := adaasn1rtl.getStringSize(val.id);
        result.Success := nStringLength >= 1 AND nStringLength <= 80;
        i1 := 1; 
        if result.Success then
            adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, adaasn1rtl.Asn1Int(nStringLength), 1, 7);
                
            while i1<= nStringLength loop
                pragma Loop_Invariant (i1 >=1 and i1<=nStringLength);
                pragma Loop_Invariant (bs.Current_Bit_Pos >= bs.Current_Bit_Pos'Loop_Entry);
                pragma Loop_Invariant (bs.Current_Bit_Pos<=bs.Current_Bit_Pos'Loop_Entry + 7*(i1-1));
                charIndex := adaasn1rtl.CharacterPos(val.id(i1));
                adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, adaasn1rtl.Asn1Int(charIndex), 0, 7);
                i1 := i1 + 1;
            end loop;
        end if;
        if result.Success then
            --Encode event 
            asn1SccFunction_Event_Encode_aux(val.event, bs, result);
        end if;
    end if;

end asn1SccNamed_Function_Event_Encode_aux;

procedure asn1SccNamed_Function_Event_Encode(val : asn1SccNamed_Function_Event; Stream : out asn1SccNamed_Function_Event_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := asn1SccNamed_Function_Event_uPER_Stream'(Size_In_Bytes => asn1SccNamed_Function_Event_REQUIRED_BYTES_FOR_ENCODING, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    asn1SccNamed_Function_Event_Encode_aux(val, Stream, result);
end asn1SccNamed_Function_Event_Encode;

procedure asn1SccNamed_Function_Event_Decode_aux(val: out asn1SccNamed_Function_Event; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
    i1:Integer;
    charIndex:Integer;
    nStringLength:Integer;
begin
    --Decode id 
    --val := asn1SccNamed_Function_Event_id_Init;
    result.ErrorCode := adaasn1rtl.ERR_INSUFFICIENT_DATA; 
    adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumberInt(bs, nStringLength, 1, 80, 7, result.Success);
    i1 := 1; 
        
    while i1<= nStringLength AND result.Success loop
        pragma Loop_Invariant (i1 >=1 and i1<=nStringLength);
        pragma Loop_Invariant (bs.Current_Bit_Pos >= bs.Current_Bit_Pos'Loop_Entry);
        pragma Loop_Invariant (bs.Current_Bit_Pos <= bs.Current_Bit_Pos'Loop_Entry + 7*(i1-1));
        adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumberInt(bs, charIndex, 0, 127, 7, result.Success);
        result.ErrorCode := ERR_UPER_DECODE_NAMED_FUNCTION_EVENT_ID;
        val.id(i1) := Character'Val(charIndex);
        i1 := i1 + 1;
    end loop;

    --add nulls until the end
    while i1<= 80 + 1  loop
        pragma Loop_Invariant (i1 >=1 and i1<=80 + 1);
        val.id(i1) := adaasn1rtl.NUL;
        i1 := i1 + 1;
    end loop;
    if result.Success then
        --Decode event 
        asn1SccFunction_Event_Decode_aux(val.event, bs, result);
    end if;
end asn1SccNamed_Function_Event_Decode_aux;
procedure asn1SccNamed_Function_Event_Decode(val:out asn1SccNamed_Function_Event; Stream : IN OUT asn1SccNamed_Function_Event_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    asn1SccNamed_Function_Event_Decode_aux(val, Stream, result);
    if result.success then
        result := asn1SccNamed_Function_Event_IsConstraintValid(val);
    end if;

end asn1SccNamed_Function_Event_Decode;



function asn1SccInterface_Event_Equal (val1, val2 :  asn1SccInterface_Event) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (val1.source = val2.source);

    if ret then
        ret := (val1.dest = val2.dest);

        if ret then
            ret := asn1SccFunction_Event_Equal(val1.event, val2.event);

        end if;
    end if;
	return ret;

end asn1SccInterface_Event_Equal;

function asn1SccInterface_Event_Init return asn1SccInterface_Event
is
    val: asn1SccInterface_Event;
begin

    --set source 
    val.source := asn1SccPID_Init;
    --set dest 
    val.dest := asn1SccPID_Init;
    --set event 
    val.event := asn1SccFunction_Event_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccInterface_Event_Init;

function asn1SccInterface_Event_IsConstraintValid(val : asn1SccInterface_Event) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := asn1SccPID_IsConstraintValid(val.source);
    if ret.Success then
        ret := asn1SccPID_IsConstraintValid(val.dest);
        if ret.Success then
            ret := asn1SccFunction_Event_IsConstraintValid(val.event);
        end if;
    end if;
    return ret;
end asn1SccInterface_Event_IsConstraintValid;

procedure asn1SccInterface_Event_Encode_aux(val : asn1SccInterface_Event; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is

begin
    result := asn1SccInterface_Event_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        --Encode source 
        asn1SccPID_Encode_aux(val.source, bs, result);
        if result.Success then
            --Encode dest 
            asn1SccPID_Encode_aux(val.dest, bs, result);
            if result.Success then
                --Encode event 
                asn1SccFunction_Event_Encode_aux(val.event, bs, result);
            end if;
        end if;
    end if;

end asn1SccInterface_Event_Encode_aux;

procedure asn1SccInterface_Event_Encode(val : asn1SccInterface_Event; Stream : out asn1SccInterface_Event_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := asn1SccInterface_Event_uPER_Stream'(Size_In_Bytes => asn1SccInterface_Event_REQUIRED_BYTES_FOR_ENCODING, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    asn1SccInterface_Event_Encode_aux(val, Stream, result);
end asn1SccInterface_Event_Encode;

procedure asn1SccInterface_Event_Decode_aux(val: out asn1SccInterface_Event; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    --Decode source 
    asn1SccPID_Decode_aux(val.source, bs, result);
    if result.Success then
        --Decode dest 
        asn1SccPID_Decode_aux(val.dest, bs, result);
        if result.Success then
            --Decode event 
            asn1SccFunction_Event_Decode_aux(val.event, bs, result);
        end if;
    end if;
end asn1SccInterface_Event_Decode_aux;
procedure asn1SccInterface_Event_Decode(val:out asn1SccInterface_Event; Stream : IN OUT asn1SccInterface_Event_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    asn1SccInterface_Event_Decode_aux(val, Stream, result);
    if result.success then
        result := asn1SccInterface_Event_IsConstraintValid(val);
    end if;

end asn1SccInterface_Event_Decode;



function asn1SccObservable_Event_no_event_Equal (val1, val2 :  asn1SccObservable_Event_no_event) return Boolean
is
   pragma Unreferenced (val1);
   pragma Unreferenced (val2);

begin
	return True;

end asn1SccObservable_Event_no_event_Equal;

function asn1SccObservable_Event_system_startup_Equal (val1, val2 :  asn1SccObservable_Event_system_startup) return Boolean
is
   pragma Unreferenced (val1);
   pragma Unreferenced (val2);

begin
	return True;

end asn1SccObservable_Event_system_startup_Equal;

function asn1SccObservable_Event_Equal (val1, val2 :  asn1SccObservable_Event) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when no_event_PRESENT =>
                ret := asn1SccObservable_Event_no_event_Equal(val1.no_event, val2.no_event);
            when system_startup_PRESENT =>
                ret := asn1SccObservable_Event_system_startup_Equal(val1.system_startup, val2.system_startup);
            when input_event_PRESENT =>
                ret := asn1SccInterface_Event_Equal(val1.input_event, val2.input_event);
            when output_event_PRESENT =>
                ret := asn1SccInterface_Event_Equal(val1.output_event, val2.output_event);
            when unhandled_input_PRESENT =>
                ret := asn1SccInterface_Event_Equal(val1.unhandled_input, val2.unhandled_input);
        end case;
    end if;
	return ret;

end asn1SccObservable_Event_Equal;

function asn1SccObservable_Event_no_event_Init return asn1SccObservable_Event_no_event
is
    val: asn1SccObservable_Event_no_event;
begin
    val := (null record);
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccObservable_Event_no_event_Init;
function asn1SccObservable_Event_system_startup_Init return asn1SccObservable_Event_system_startup
is
    val: asn1SccObservable_Event_system_startup;
begin
    val := (null record);
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccObservable_Event_system_startup_Init;
function asn1SccObservable_Event_Init return asn1SccObservable_Event
is
    val: asn1SccObservable_Event;
begin
    --set no_event 
    declare
        no_event_tmp:asn1SccObservable_Event_no_event;
    begin
        no_event_tmp := asn1SccObservable_Event_no_event_Init;
    	pragma Warnings (Off, "object ""no_event_tmp"" is always False at this point");
        val := asn1SccObservable_Event'(kind => no_event_PRESENT, no_event => no_event_tmp);
    	pragma Warnings (On, "object ""no_event_tmp"" is always False at this point");
    end;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccObservable_Event_Init;

function asn1SccObservable_Event_IsConstraintValid(val : asn1SccObservable_Event) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    if val.kind = input_event_PRESENT then
    	ret := asn1SccInterface_Event_IsConstraintValid(val.input_event);
    end if;
    if ret.Success then
        if val.kind = output_event_PRESENT then
        	ret := asn1SccInterface_Event_IsConstraintValid(val.output_event);
        end if;
        if ret.Success then
            if val.kind = unhandled_input_PRESENT then
            	ret := asn1SccInterface_Event_IsConstraintValid(val.unhandled_input);
            end if;
        end if;
    end if;
    return ret;
end asn1SccObservable_Event_IsConstraintValid;

procedure asn1SccObservable_Event_Encode_aux(val : asn1SccObservable_Event; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is

begin
    result := asn1SccObservable_Event_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        case val.kind is
            when no_event_PRESENT =>
                adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, 0, 0, 3);
                --no encoding/decoding is required
            when system_startup_PRESENT =>
                adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, 1, 0, 3);
                --no encoding/decoding is required
            when input_event_PRESENT =>
                adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, 2, 0, 3);
                asn1SccInterface_Event_Encode_aux(val.input_event, bs, result);
            when output_event_PRESENT =>
                adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, 3, 0, 3);
                asn1SccInterface_Event_Encode_aux(val.output_event, bs, result);
            when unhandled_input_PRESENT =>
                adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, 4, 0, 3);
                asn1SccInterface_Event_Encode_aux(val.unhandled_input, bs, result);
        end case;
    end if;

end asn1SccObservable_Event_Encode_aux;

procedure asn1SccObservable_Event_Encode(val : asn1SccObservable_Event; Stream : out asn1SccObservable_Event_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := asn1SccObservable_Event_uPER_Stream'(Size_In_Bytes => asn1SccObservable_Event_REQUIRED_BYTES_FOR_ENCODING, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    asn1SccObservable_Event_Encode_aux(val, Stream, result);
end asn1SccObservable_Event_Encode;

procedure asn1SccObservable_Event_Decode_aux(val: out asn1SccObservable_Event; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
    asn1SccObservable_Event_index_tmp:adaasn1rtl.Asn1Int;
begin
    result.ErrorCode := ERR_UPER_DECODE_OBSERVABLE_EVENT;
    adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumber(bs, asn1SccObservable_Event_index_tmp, 0, 4, 3, result.Success);
    if result.Success and asn1SccObservable_Event_index_tmp >= 0 and  asn1SccObservable_Event_index_tmp <= 4 then
        case asn1SccObservable_Event_index_range(asn1SccObservable_Event_index_tmp) is
            when 0 =>
              declare
                 no_event_tmp:asn1SccObservable_Event_no_event;
              begin
                no_event_tmp := (null record);
                result := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
                if result.Success then
                    val := asn1SccObservable_Event'(kind => no_event_PRESENT, no_event => no_event_tmp);
                    pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                end if;
              end;
            when 1 =>
              declare
                 system_startup_tmp:asn1SccObservable_Event_system_startup;
              begin
                system_startup_tmp := (null record);
                result := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
                if result.Success then
                    val := asn1SccObservable_Event'(kind => system_startup_PRESENT, system_startup => system_startup_tmp);
                    pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                end if;
              end;
            when 2 =>
              declare
                 input_event_tmp:asn1SccInterface_Event;
              begin
                asn1SccInterface_Event_Decode_aux(input_event_tmp, bs, result);
                if result.Success then
                    val := asn1SccObservable_Event'(kind => input_event_PRESENT, input_event => input_event_tmp);
                    pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                end if;
              end;
            when 3 =>
              declare
                 output_event_tmp:asn1SccInterface_Event;
              begin
                asn1SccInterface_Event_Decode_aux(output_event_tmp, bs, result);
                if result.Success then
                    val := asn1SccObservable_Event'(kind => output_event_PRESENT, output_event => output_event_tmp);
                    pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                end if;
              end;
            when 4 =>
              declare
                 unhandled_input_tmp:asn1SccInterface_Event;
              begin
                asn1SccInterface_Event_Decode_aux(unhandled_input_tmp, bs, result);
                if result.Success then
                    val := asn1SccObservable_Event'(kind => unhandled_input_PRESENT, unhandled_input => unhandled_input_tmp);
                    pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                end if;
              end;
        end case;
    end if;
end asn1SccObservable_Event_Decode_aux;
procedure asn1SccObservable_Event_Decode(val:out asn1SccObservable_Event; Stream : IN OUT asn1SccObservable_Event_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    asn1SccObservable_Event_Decode_aux(val, Stream, result);
    if result.success then
        result := asn1SccObservable_Event_IsConstraintValid(val);
    end if;

end asn1SccObservable_Event_Decode;



function asn1SccEvents_Ty_Equal (val1, val2 :  asn1SccEvents_Ty) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := asn1SccObservable_Event_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end asn1SccEvents_Ty_Equal;

function asn1SccEvents_Ty_Init return asn1SccEvents_Ty
is
    val: asn1SccEvents_Ty;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 10 loop
        --  commented because it casues this warning    
        --  warning: condition can only be False if invalid values present
        pragma Loop_Invariant (i1 >=1 and i1<=10);
        val.Data(i1) := asn1SccObservable_Event_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccEvents_Ty_Init;

function asn1SccEvents_Ty_IsConstraintValid(val : asn1SccEvents_Ty) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
begin
    ret.Success := (val.Length <= 10);
    ret.ErrorCode := (if ret.Success then 0 else ERR_EVENTS_TY);
    if ret.Success then
        i1 := val.Data'First;
        while ret.Success and i1 <= val.Length loop
            pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
            ret := asn1SccObservable_Event_IsConstraintValid(val.Data(i1));
            i1 := i1+1;
        end loop;
    end if;
    return ret;
end asn1SccEvents_Ty_IsConstraintValid;

procedure asn1SccEvents_Ty_Encode_aux(val : asn1SccEvents_Ty; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is

    i1:Integer;
begin
    result := asn1SccEvents_Ty_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        result.Success := val.Length >= 0 AND val.Length <= 10;
        result.errorCode := ERR_UPER_ENCODE_EVENTS_TY;
        i1 := 1; 
        if result.Success then
            adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, adaasn1rtl.Asn1Int(val.Length), 0, 4);
                
            while i1<= val.Length loop
                pragma Loop_Invariant (i1 >=1 and i1<=val.Length);
                pragma Loop_Invariant (bs.Current_Bit_Pos >= bs.Current_Bit_Pos'Loop_Entry);
                pragma Loop_Invariant (bs.Current_Bit_Pos<=bs.Current_Bit_Pos'Loop_Entry + 26*(i1-1));
                asn1SccObservable_Event_Encode_aux(val.Data(i1), bs, result);
                i1 := i1 + 1;
            end loop;
        end if;
    end if;

end asn1SccEvents_Ty_Encode_aux;

procedure asn1SccEvents_Ty_Encode(val : asn1SccEvents_Ty; Stream : out asn1SccEvents_Ty_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := asn1SccEvents_Ty_uPER_Stream'(Size_In_Bytes => asn1SccEvents_Ty_REQUIRED_BYTES_FOR_ENCODING, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    asn1SccEvents_Ty_Encode_aux(val, Stream, result);
end asn1SccEvents_Ty_Encode;

procedure asn1SccEvents_Ty_Decode_aux(val: out asn1SccEvents_Ty; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
    i1:Integer;
    nStringLength:Integer;
begin
    adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumberInt(bs, nStringLength, 0, 10, 4, result.Success);
    result.errorCode := ERR_UPER_DECODE_EVENTS_TY;
    i1 := 1; 
    val.Length := nStringLength;
        
    while i1<= val.Length AND result.Success loop
        pragma Loop_Invariant (i1 >=1 and i1<=val.Length);
        pragma Loop_Invariant (bs.Current_Bit_Pos >= bs.Current_Bit_Pos'Loop_Entry);
        pragma Loop_Invariant (bs.Current_Bit_Pos <= bs.Current_Bit_Pos'Loop_Entry + 26*(i1-1));
        asn1SccObservable_Event_Decode_aux(val.Data(i1), bs, result);
        i1 := i1 + 1;
    end loop;
end asn1SccEvents_Ty_Decode_aux;
procedure asn1SccEvents_Ty_Decode(val:out asn1SccEvents_Ty; Stream : IN OUT asn1SccEvents_Ty_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    asn1SccEvents_Ty_Decode_aux(val, Stream, result);
    if result.success then
        result := asn1SccEvents_Ty_IsConstraintValid(val);
    end if;

end asn1SccEvents_Ty_Decode;



    function asn1SccSystem_State_pinger_queue_Equal (val1, val2 : asn1SccSystem_State_pinger_queue) return Boolean 
    is
        pragma Warnings (Off, "initialization of ret has no effect");        
        ret : Boolean := True;
        pragma Warnings (On, "initialization of ret has no effect");        
    begin
        ret := asn1SccEvents_Ty_Equal(val1, val2);
        return ret;
    end asn1SccSystem_State_pinger_queue_Equal;

    function asn1SccSystem_State_ponger_queue_Equal (val1, val2 : asn1SccSystem_State_ponger_queue) return Boolean 
    is
        pragma Warnings (Off, "initialization of ret has no effect");        
        ret : Boolean := True;
        pragma Warnings (On, "initialization of ret has no effect");        
    begin
        ret := asn1SccEvents_Ty_Equal(val1, val2);
        return ret;
    end asn1SccSystem_State_ponger_queue_Equal;

function asn1SccSystem_State_Equal (val1, val2 :  asn1SccSystem_State) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := asn1SccSystem_State_pinger_queue_Equal(val1.pinger_queue, val2.pinger_queue);

    if ret then
        ret := asn1SccSystem_State_ponger_queue_Equal(val1.ponger_queue, val2.ponger_queue);

        if ret then
            ret := Pinger_Datamodel.asn1SccPinger_Context_Equal(val1.pinger, val2.pinger);

            if ret then
                ret := Ponger_Datamodel.asn1SccPonger_Context_Equal(val1.ponger, val2.ponger);

            end if;
        end if;
    end if;
	return ret;

end asn1SccSystem_State_Equal;

function asn1SccSystem_State_pinger_queue_Init return asn1SccSystem_State_pinger_queue
is
    val: asn1SccSystem_State_pinger_queue;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 2 loop
        --  commented because it casues this warning    
        --  warning: condition can only be False if invalid values present
        pragma Loop_Invariant (i1 >=1 and i1<=2);
        val.Data(i1) := asn1SccObservable_Event_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccSystem_State_pinger_queue_Init;
function asn1SccSystem_State_ponger_queue_Init return asn1SccSystem_State_ponger_queue
is
    val: asn1SccSystem_State_ponger_queue;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 2 loop
        --  commented because it casues this warning    
        --  warning: condition can only be False if invalid values present
        pragma Loop_Invariant (i1 >=1 and i1<=2);
        val.Data(i1) := asn1SccObservable_Event_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccSystem_State_ponger_queue_Init;
function asn1SccSystem_State_Init return asn1SccSystem_State
is
    val: asn1SccSystem_State;
begin

    --set pinger_queue 
    val.pinger_queue := asn1SccSystem_State_pinger_queue_Init;
    --set ponger_queue 
    val.ponger_queue := asn1SccSystem_State_ponger_queue_Init;
    --set pinger 
    val.pinger := Pinger_Datamodel.asn1SccPinger_Context_Init;
    --set ponger 
    val.ponger := Ponger_Datamodel.asn1SccPonger_Context_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccSystem_State_Init;

function asn1SccSystem_State_IsConstraintValid(val : asn1SccSystem_State) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
begin
    ret.Success := (val.pinger_queue.Length <= 10);
    if ret.Success then
        ret.Success := (val.pinger_queue.Length <= 2);
    end if;
    ret.ErrorCode := (if ret.Success then 0 else ERR_SYSTEM_STATE_PINGER_QUEUE);
    if ret.Success then
        i1 := val.pinger_queue.Data'First;
        while ret.Success and i1 <= val.pinger_queue.Length loop
            pragma Loop_Invariant (i1 >= val.pinger_queue.Data'First and i1 <= val.pinger_queue.Length);
            ret := asn1SccObservable_Event_IsConstraintValid(val.pinger_queue.Data(i1));
            i1 := i1+1;
        end loop;
    end if;
    if ret.Success then
        ret.Success := (val.ponger_queue.Length <= 10);
        if ret.Success then
            ret.Success := (val.ponger_queue.Length <= 2);
        end if;
        ret.ErrorCode := (if ret.Success then 0 else ERR_SYSTEM_STATE_PONGER_QUEUE);
        if ret.Success then
            i1 := val.ponger_queue.Data'First;
            while ret.Success and i1 <= val.ponger_queue.Length loop
                pragma Loop_Invariant (i1 >= val.ponger_queue.Data'First and i1 <= val.ponger_queue.Length);
                ret := asn1SccObservable_Event_IsConstraintValid(val.ponger_queue.Data(i1));
                i1 := i1+1;
            end loop;
        end if;
        if ret.Success then
            ret := Pinger_Datamodel.asn1SccPinger_Context_IsConstraintValid(val.pinger);
            if ret.Success then
                ret := Ponger_Datamodel.asn1SccPonger_Context_IsConstraintValid(val.ponger);
            end if;
        end if;
    end if;
    return ret;
end asn1SccSystem_State_IsConstraintValid;

procedure asn1SccSystem_State_Encode_aux(val : asn1SccSystem_State; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is

    i1:Integer;
begin
    result := asn1SccSystem_State_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        --Encode pinger_queue 
        result.Success := val.pinger_queue.Length >= 0 AND val.pinger_queue.Length <= 2;
        result.errorCode := ERR_UPER_ENCODE_SYSTEM_STATE_PINGER_QUEUE;
        i1 := 1; 
        if result.Success then
            adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, adaasn1rtl.Asn1Int(val.pinger_queue.Length), 0, 2);
                
            while i1<= val.pinger_queue.Length loop
                pragma Loop_Invariant (i1 >=1 and i1<=val.pinger_queue.Length);
                pragma Loop_Invariant (bs.Current_Bit_Pos >= bs.Current_Bit_Pos'Loop_Entry);
                pragma Loop_Invariant (bs.Current_Bit_Pos<=bs.Current_Bit_Pos'Loop_Entry + 26*(i1-1));
                asn1SccObservable_Event_Encode_aux(val.pinger_queue.Data(i1), bs, result);
                i1 := i1 + 1;
            end loop;
        end if;
        if result.Success then
            --Encode ponger_queue 
            result.Success := val.ponger_queue.Length >= 0 AND val.ponger_queue.Length <= 2;
            result.errorCode := ERR_UPER_ENCODE_SYSTEM_STATE_PONGER_QUEUE;
            i1 := 1; 
            if result.Success then
                adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, adaasn1rtl.Asn1Int(val.ponger_queue.Length), 0, 2);
                    
                while i1<= val.ponger_queue.Length loop
                    pragma Loop_Invariant (i1 >=1 and i1<=val.ponger_queue.Length);
                    pragma Loop_Invariant (bs.Current_Bit_Pos >= bs.Current_Bit_Pos'Loop_Entry);
                    pragma Loop_Invariant (bs.Current_Bit_Pos<=bs.Current_Bit_Pos'Loop_Entry + 26*(i1-1));
                    asn1SccObservable_Event_Encode_aux(val.ponger_queue.Data(i1), bs, result);
                    i1 := i1 + 1;
                end loop;
            end if;
            if result.Success then
                --Encode pinger 
                Pinger_Datamodel.asn1SccPinger_Context_Encode_aux(val.pinger, bs, result);
                if result.Success then
                    --Encode ponger 
                    Ponger_Datamodel.asn1SccPonger_Context_Encode_aux(val.ponger, bs, result);
                end if;
            end if;
        end if;
    end if;

end asn1SccSystem_State_Encode_aux;

procedure asn1SccSystem_State_Encode(val : asn1SccSystem_State; Stream : out asn1SccSystem_State_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := asn1SccSystem_State_uPER_Stream'(Size_In_Bytes => asn1SccSystem_State_REQUIRED_BYTES_FOR_ENCODING, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    asn1SccSystem_State_Encode_aux(val, Stream, result);
end asn1SccSystem_State_Encode;

procedure asn1SccSystem_State_Decode_aux(val: out asn1SccSystem_State; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
    i1:Integer;
    nStringLength:Integer;
begin
    --Decode pinger_queue 
    adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumberInt(bs, nStringLength, 0, 2, 2, result.Success);
    result.errorCode := ERR_UPER_DECODE_SYSTEM_STATE_PINGER_QUEUE;
    i1 := 1; 
    val.pinger_queue.Length := nStringLength;
        
    while i1<= val.pinger_queue.Length AND result.Success loop
        pragma Loop_Invariant (i1 >=1 and i1<=val.pinger_queue.Length);
        pragma Loop_Invariant (bs.Current_Bit_Pos >= bs.Current_Bit_Pos'Loop_Entry);
        pragma Loop_Invariant (bs.Current_Bit_Pos <= bs.Current_Bit_Pos'Loop_Entry + 26*(i1-1));
        asn1SccObservable_Event_Decode_aux(val.pinger_queue.Data(i1), bs, result);
        i1 := i1 + 1;
    end loop;
    if result.Success then
        --Decode ponger_queue 
        adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumberInt(bs, nStringLength, 0, 2, 2, result.Success);
        result.errorCode := ERR_UPER_DECODE_SYSTEM_STATE_PONGER_QUEUE;
        i1 := 1; 
        val.ponger_queue.Length := nStringLength;
            
        while i1<= val.ponger_queue.Length AND result.Success loop
            pragma Loop_Invariant (i1 >=1 and i1<=val.ponger_queue.Length);
            pragma Loop_Invariant (bs.Current_Bit_Pos >= bs.Current_Bit_Pos'Loop_Entry);
            pragma Loop_Invariant (bs.Current_Bit_Pos <= bs.Current_Bit_Pos'Loop_Entry + 26*(i1-1));
            asn1SccObservable_Event_Decode_aux(val.ponger_queue.Data(i1), bs, result);
            i1 := i1 + 1;
        end loop;
        if result.Success then
            --Decode pinger 
            Pinger_Datamodel.asn1SccPinger_Context_Decode_aux(val.pinger, bs, result);
            if result.Success then
                --Decode ponger 
                Ponger_Datamodel.asn1SccPonger_Context_Decode_aux(val.ponger, bs, result);
            end if;
        end if;
    end if;
end asn1SccSystem_State_Decode_aux;
procedure asn1SccSystem_State_Decode(val:out asn1SccSystem_State; Stream : IN OUT asn1SccSystem_State_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    asn1SccSystem_State_Decode_aux(val, Stream, result);
    if result.success then
        result := asn1SccSystem_State_IsConstraintValid(val);
    end if;

end asn1SccSystem_State_Decode;



function asn1SccObserver_State_Kind_Equal (val1, val2 :  asn1SccObserver_State_Kind) return Boolean
is

begin
	return val1 = val2;

end asn1SccObserver_State_Kind_Equal;

function asn1SccObserver_State_Kind_Init return asn1SccObserver_State_Kind
is
    val: asn1SccObserver_State_Kind;
begin
    val := asn1Sccregular_state;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccObserver_State_Kind_Init;

function asn1SccObserver_State_Kind_IsConstraintValid(val : asn1SccObserver_State_Kind) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((((((val = asn1Sccregular_state)) OR ((val = asn1Sccerror_state)))) OR ((val = asn1Sccignore_state)))) OR ((val = asn1Sccsuccess_state)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_OBSERVER_STATE_KIND);
    return ret;
end asn1SccObserver_State_Kind_IsConstraintValid;

procedure asn1SccObserver_State_Kind_Encode_aux(val : asn1SccObserver_State_Kind; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is

begin
    result := asn1SccObserver_State_Kind_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        declare
            intVal:Asn1Int;
        begin
            case val is 
                when asn1Sccregular_state    => intVal := 0;
                when asn1Sccerror_state    => intVal := 1;
                when asn1Sccignore_state    => intVal := 2;
                when asn1Sccsuccess_state    => intVal := 3;
            end case;
            adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, intVal, 0, 2);
        end;
    end if;

end asn1SccObserver_State_Kind_Encode_aux;

procedure asn1SccObserver_State_Kind_Encode(val : asn1SccObserver_State_Kind; Stream : out asn1SccObserver_State_Kind_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := asn1SccObserver_State_Kind_uPER_Stream'(Size_In_Bytes => asn1SccObserver_State_Kind_REQUIRED_BYTES_FOR_ENCODING, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    asn1SccObserver_State_Kind_Encode_aux(val, Stream, result);
end asn1SccObserver_State_Kind_Encode;

procedure asn1SccObserver_State_Kind_Decode_aux(val: out asn1SccObserver_State_Kind; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    declare
        intVal:Asn1Int;
    begin
        adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumber(bs, intVal, 0, 3, 2, result.Success);
        if result.Success then
            case asn1SccObserver_State_Kind_index_range(intVal) is
                when 0 => val := asn1Sccregular_state;
                when 1 => val := asn1Sccerror_state;
                when 2 => val := asn1Sccignore_state;
                when 3 => val := asn1Sccsuccess_state;
            end case;
            result.ErrorCode := 0;
        else
            val := asn1Sccregular_state;					-- COVERAGE_IGNORE
            result.ErrorCode := ERR_UPER_DECODE_OBSERVER_STATE_KIND;				-- COVERAGE_IGNORE
        end if;
    end;
end asn1SccObserver_State_Kind_Decode_aux;
procedure asn1SccObserver_State_Kind_Decode(val:out asn1SccObserver_State_Kind; Stream : IN OUT asn1SccObserver_State_Kind_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    asn1SccObserver_State_Kind_Decode_aux(val, Stream, result);
    if result.success then
        result := asn1SccObserver_State_Kind_IsConstraintValid(val);
    end if;

end asn1SccObserver_State_Kind_Decode;


pragma Warnings (On, "condition can only be False if invalid values present");
pragma Warnings (On, "condition can only be True if invalid values present");

 
end Simulation_DataView;