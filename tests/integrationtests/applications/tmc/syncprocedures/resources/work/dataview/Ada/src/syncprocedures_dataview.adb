pragma Style_Checks (Off);
--  Code automatically generated by asn1scc tool
pragma Warnings (Off, "redundant with clause in body");

pragma Warnings (Off, "no entities of ""adaasn1rtl.encoding.uper"" are referenced");
pragma Warnings (Off, "use clause for package ""adaasn1rtl.encoding.uper"" has no effect");
pragma Warnings (Off, "unit ""adaasn1rtl.encoding.uper"" is not referenced");
with adaasn1rtl.encoding.uper;
pragma Warnings (On, "no entities of ""adaasn1rtl.encoding.uper"" are referenced");
pragma Warnings (On, "use clause for package ""adaasn1rtl.encoding.uper"" has no effect");
pragma Warnings (On, "unit ""adaasn1rtl.encoding.uper"" is not referenced");

pragma Warnings (On, "redundant with clause in body");

package body SYNCPROCEDURES_DATAVIEW with SPARK_Mode is



pragma Warnings (Off, "condition can only be False if invalid values present");
pragma Warnings (Off, "condition can only be True if invalid values present");


function asn1SccMyInteger_Equal (val1, val2 :  asn1SccMyInteger) return Boolean
is

begin
	return val1 = val2;

end asn1SccMyInteger_Equal;

function asn1SccMyInteger_Init return asn1SccMyInteger
is
    val: asn1SccMyInteger;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccMyInteger_Init;

function asn1SccMyInteger_IsConstraintValid(val : asn1SccMyInteger) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val <= 10000);
    ret.ErrorCode := (if ret.Success then 0 else ERR_MYINTEGER);
    return ret;
end asn1SccMyInteger_IsConstraintValid;

procedure asn1SccMyInteger_Encode_aux(val : asn1SccMyInteger; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is

begin
    result := asn1SccMyInteger_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        adaasn1rtl.encoding.uper.UPER_Enc_ConstraintPosWholeNumber(bs, val, 0, 14);
    end if;

end asn1SccMyInteger_Encode_aux;

procedure asn1SccMyInteger_Encode(val : asn1SccMyInteger; Stream : out asn1SccMyInteger_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := asn1SccMyInteger_uPER_Stream'(Size_In_Bytes => asn1SccMyInteger_REQUIRED_BYTES_FOR_ENCODING, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    asn1SccMyInteger_Encode_aux(val, Stream, result);
end asn1SccMyInteger_Encode;

procedure asn1SccMyInteger_Decode_aux(val: out asn1SccMyInteger; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    result.ErrorCode := ERR_UPER_DECODE_MYINTEGER;
    adaasn1rtl.encoding.uper.UPER_Dec_ConstraintPosWholeNumber(bs, val, 0, 10000, 14, result.Success);
end asn1SccMyInteger_Decode_aux;
procedure asn1SccMyInteger_Decode(val:out asn1SccMyInteger; Stream : IN OUT asn1SccMyInteger_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    asn1SccMyInteger_Decode_aux(val, Stream, result);
    if result.success then
        result := asn1SccMyInteger_IsConstraintValid(val);
    end if;

end asn1SccMyInteger_Decode;


pragma Warnings (On, "condition can only be False if invalid values present");
pragma Warnings (On, "condition can only be True if invalid values present");

 
end SYNCPROCEDURES_DATAVIEW;