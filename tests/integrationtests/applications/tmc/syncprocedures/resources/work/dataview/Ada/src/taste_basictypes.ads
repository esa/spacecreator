pragma Style_Checks (Off);
--  Code automatically generated by asn1scc tool
with adaasn1rtl;
pragma Warnings (Off, "unit ""adaasn1rtl.encoding"" is not referenced");
with adaasn1rtl.encoding;
pragma Warnings (On, "unit ""adaasn1rtl.encoding"" is not referenced");


pragma Warnings (Off, "unit ""System"" is not referenced");
with System;
pragma Warnings (On, "unit ""System"" is not referenced");

pragma Warnings (Off, "use clause for package ""adaasn1rtl"" has no effect");
use adaasn1rtl;
pragma Warnings (On, "use clause for package ""adaasn1rtl"" has no effect");

pragma Warnings (Off, "use clause for type");
pragma Warnings (Off, "is already use-visible through package use clause at line");
use type adaasn1rtl.OctetBuffer;
use type adaasn1rtl.BitArray;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;
pragma Warnings (On, "use clause for type");
pragma Warnings (On, "is already use-visible through package use clause at line");



package TASTE_BasicTypes with SPARK_Mode
is


subtype asn1SccT_Int32 is adaasn1rtl.Asn1Int range -2147483648 .. 2147483647;


function asn1SccT_Int32_Equal(val1, val2 : asn1SccT_Int32) return Boolean;

function asn1SccT_Int32_Init return asn1SccT_Int32;

ERR_T_INT32:constant Integer := 76; 
function asn1SccT_Int32_IsConstraintValid(val : asn1SccT_Int32) return adaasn1rtl.ASN1_RESULT;

ERR_UPER_ENCODE_T_INT32:constant Integer := 77; 
asn1SccT_Int32_REQUIRED_BYTES_FOR_ENCODING:constant Integer := 4;
asn1SccT_Int32_REQUIRED_BITS_FOR_ENCODING:constant Integer := 32;

subtype asn1SccT_Int32_uPER_Stream is adaasn1rtl.encoding.Bitstream(asn1SccT_Int32_REQUIRED_BYTES_FOR_ENCODING);

procedure asn1SccT_Int32_Encode (val : asn1SccT_Int32; Stream : out asn1SccT_Int32_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
procedure asn1SccT_Int32_Encode_aux(val : asn1SccT_Int32; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
with
    Pre => bs.Current_Bit_Pos < Natural'Last - asn1SccT_Int32_REQUIRED_BITS_FOR_ENCODING
      and then bs.Size_In_Bytes < Positive'Last / 8
      and then bs.Current_Bit_Pos + asn1SccT_Int32_REQUIRED_BITS_FOR_ENCODING <= bs.Size_In_Bytes * 8,
       Post => 
         (result.Success and bs.Current_Bit_Pos >= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos <= bs'Old.Current_Bit_Pos + asn1SccT_Int32_REQUIRED_BITS_FOR_ENCODING)
       or
         not result.Success
;

ERR_UPER_DECODE_T_INT32:constant Integer := 78; 
procedure asn1SccT_Int32_Decode(val: out asn1SccT_Int32; Stream : in out asn1SccT_Int32_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
procedure asn1SccT_Int32_Decode_aux(val: out asn1SccT_Int32; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
with
    Pre => bs.Current_Bit_Pos < Natural'Last - asn1SccT_Int32_REQUIRED_BITS_FOR_ENCODING
      and then bs.Size_In_Bytes < Positive'Last / 8
      and then bs.Current_Bit_Pos + asn1SccT_Int32_REQUIRED_BITS_FOR_ENCODING <= bs.Size_In_Bytes * 8,
       Post => 
         (result.Success and bs.Current_Bit_Pos >= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos <= bs'Old.Current_Bit_Pos + asn1SccT_Int32_REQUIRED_BITS_FOR_ENCODING)
       or
         not result.Success
;
subtype asn1SccT_UInt32 is adaasn1rtl.Asn1UInt range 0 .. 4294967295;


function asn1SccT_UInt32_Equal(val1, val2 : asn1SccT_UInt32) return Boolean;

function asn1SccT_UInt32_Init return asn1SccT_UInt32;

ERR_T_UINT32:constant Integer := 81; 
function asn1SccT_UInt32_IsConstraintValid(val : asn1SccT_UInt32) return adaasn1rtl.ASN1_RESULT;

ERR_UPER_ENCODE_T_UINT32:constant Integer := 82; 
asn1SccT_UInt32_REQUIRED_BYTES_FOR_ENCODING:constant Integer := 4;
asn1SccT_UInt32_REQUIRED_BITS_FOR_ENCODING:constant Integer := 32;

subtype asn1SccT_UInt32_uPER_Stream is adaasn1rtl.encoding.Bitstream(asn1SccT_UInt32_REQUIRED_BYTES_FOR_ENCODING);

procedure asn1SccT_UInt32_Encode (val : asn1SccT_UInt32; Stream : out asn1SccT_UInt32_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
procedure asn1SccT_UInt32_Encode_aux(val : asn1SccT_UInt32; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
with
    Pre => bs.Current_Bit_Pos < Natural'Last - asn1SccT_UInt32_REQUIRED_BITS_FOR_ENCODING
      and then bs.Size_In_Bytes < Positive'Last / 8
      and then bs.Current_Bit_Pos + asn1SccT_UInt32_REQUIRED_BITS_FOR_ENCODING <= bs.Size_In_Bytes * 8,
       Post => 
         (result.Success and bs.Current_Bit_Pos >= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos <= bs'Old.Current_Bit_Pos + asn1SccT_UInt32_REQUIRED_BITS_FOR_ENCODING)
       or
         not result.Success
;

ERR_UPER_DECODE_T_UINT32:constant Integer := 83; 
procedure asn1SccT_UInt32_Decode(val: out asn1SccT_UInt32; Stream : in out asn1SccT_UInt32_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
procedure asn1SccT_UInt32_Decode_aux(val: out asn1SccT_UInt32; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
with
    Pre => bs.Current_Bit_Pos < Natural'Last - asn1SccT_UInt32_REQUIRED_BITS_FOR_ENCODING
      and then bs.Size_In_Bytes < Positive'Last / 8
      and then bs.Current_Bit_Pos + asn1SccT_UInt32_REQUIRED_BITS_FOR_ENCODING <= bs.Size_In_Bytes * 8,
       Post => 
         (result.Success and bs.Current_Bit_Pos >= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos <= bs'Old.Current_Bit_Pos + asn1SccT_UInt32_REQUIRED_BITS_FOR_ENCODING)
       or
         not result.Success
;
subtype asn1SccT_Int8 is adaasn1rtl.Asn1Int range -128 .. 127;


function asn1SccT_Int8_Equal(val1, val2 : asn1SccT_Int8) return Boolean;

function asn1SccT_Int8_Init return asn1SccT_Int8;

ERR_T_INT8:constant Integer := 86; 
function asn1SccT_Int8_IsConstraintValid(val : asn1SccT_Int8) return adaasn1rtl.ASN1_RESULT;

ERR_UPER_ENCODE_T_INT8:constant Integer := 87; 
asn1SccT_Int8_REQUIRED_BYTES_FOR_ENCODING:constant Integer := 1;
asn1SccT_Int8_REQUIRED_BITS_FOR_ENCODING:constant Integer := 8;

subtype asn1SccT_Int8_uPER_Stream is adaasn1rtl.encoding.Bitstream(asn1SccT_Int8_REQUIRED_BYTES_FOR_ENCODING);

procedure asn1SccT_Int8_Encode (val : asn1SccT_Int8; Stream : out asn1SccT_Int8_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
procedure asn1SccT_Int8_Encode_aux(val : asn1SccT_Int8; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
with
    Pre => bs.Current_Bit_Pos < Natural'Last - asn1SccT_Int8_REQUIRED_BITS_FOR_ENCODING
      and then bs.Size_In_Bytes < Positive'Last / 8
      and then bs.Current_Bit_Pos + asn1SccT_Int8_REQUIRED_BITS_FOR_ENCODING <= bs.Size_In_Bytes * 8,
       Post => 
         (result.Success and bs.Current_Bit_Pos >= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos <= bs'Old.Current_Bit_Pos + asn1SccT_Int8_REQUIRED_BITS_FOR_ENCODING)
       or
         not result.Success
;

ERR_UPER_DECODE_T_INT8:constant Integer := 88; 
procedure asn1SccT_Int8_Decode(val: out asn1SccT_Int8; Stream : in out asn1SccT_Int8_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
procedure asn1SccT_Int8_Decode_aux(val: out asn1SccT_Int8; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
with
    Pre => bs.Current_Bit_Pos < Natural'Last - asn1SccT_Int8_REQUIRED_BITS_FOR_ENCODING
      and then bs.Size_In_Bytes < Positive'Last / 8
      and then bs.Current_Bit_Pos + asn1SccT_Int8_REQUIRED_BITS_FOR_ENCODING <= bs.Size_In_Bytes * 8,
       Post => 
         (result.Success and bs.Current_Bit_Pos >= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos <= bs'Old.Current_Bit_Pos + asn1SccT_Int8_REQUIRED_BITS_FOR_ENCODING)
       or
         not result.Success
;
subtype asn1SccT_UInt8 is adaasn1rtl.Asn1UInt range 0 .. 255;


function asn1SccT_UInt8_Equal(val1, val2 : asn1SccT_UInt8) return Boolean;

function asn1SccT_UInt8_Init return asn1SccT_UInt8;

ERR_T_UINT8:constant Integer := 91; 
function asn1SccT_UInt8_IsConstraintValid(val : asn1SccT_UInt8) return adaasn1rtl.ASN1_RESULT;

ERR_UPER_ENCODE_T_UINT8:constant Integer := 92; 
asn1SccT_UInt8_REQUIRED_BYTES_FOR_ENCODING:constant Integer := 1;
asn1SccT_UInt8_REQUIRED_BITS_FOR_ENCODING:constant Integer := 8;

subtype asn1SccT_UInt8_uPER_Stream is adaasn1rtl.encoding.Bitstream(asn1SccT_UInt8_REQUIRED_BYTES_FOR_ENCODING);

procedure asn1SccT_UInt8_Encode (val : asn1SccT_UInt8; Stream : out asn1SccT_UInt8_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
procedure asn1SccT_UInt8_Encode_aux(val : asn1SccT_UInt8; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
with
    Pre => bs.Current_Bit_Pos < Natural'Last - asn1SccT_UInt8_REQUIRED_BITS_FOR_ENCODING
      and then bs.Size_In_Bytes < Positive'Last / 8
      and then bs.Current_Bit_Pos + asn1SccT_UInt8_REQUIRED_BITS_FOR_ENCODING <= bs.Size_In_Bytes * 8,
       Post => 
         (result.Success and bs.Current_Bit_Pos >= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos <= bs'Old.Current_Bit_Pos + asn1SccT_UInt8_REQUIRED_BITS_FOR_ENCODING)
       or
         not result.Success
;

ERR_UPER_DECODE_T_UINT8:constant Integer := 93; 
procedure asn1SccT_UInt8_Decode(val: out asn1SccT_UInt8; Stream : in out asn1SccT_UInt8_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
procedure asn1SccT_UInt8_Decode_aux(val: out asn1SccT_UInt8; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
with
    Pre => bs.Current_Bit_Pos < Natural'Last - asn1SccT_UInt8_REQUIRED_BITS_FOR_ENCODING
      and then bs.Size_In_Bytes < Positive'Last / 8
      and then bs.Current_Bit_Pos + asn1SccT_UInt8_REQUIRED_BITS_FOR_ENCODING <= bs.Size_In_Bytes * 8,
       Post => 
         (result.Success and bs.Current_Bit_Pos >= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos <= bs'Old.Current_Bit_Pos + asn1SccT_UInt8_REQUIRED_BITS_FOR_ENCODING)
       or
         not result.Success
;
subtype asn1SccT_Boolean is adaasn1rtl.Asn1Boolean;


function asn1SccT_Boolean_Equal(val1, val2 : asn1SccT_Boolean) return Boolean;

function asn1SccT_Boolean_Init return asn1SccT_Boolean;

ERR_T_BOOLEAN:constant Integer := 96; 
function asn1SccT_Boolean_IsConstraintValid(val : asn1SccT_Boolean) return adaasn1rtl.ASN1_RESULT;

ERR_UPER_ENCODE_T_BOOLEAN:constant Integer := 97; 
asn1SccT_Boolean_REQUIRED_BYTES_FOR_ENCODING:constant Integer := 1;
asn1SccT_Boolean_REQUIRED_BITS_FOR_ENCODING:constant Integer := 1;

subtype asn1SccT_Boolean_uPER_Stream is adaasn1rtl.encoding.Bitstream(asn1SccT_Boolean_REQUIRED_BYTES_FOR_ENCODING);

procedure asn1SccT_Boolean_Encode (val : asn1SccT_Boolean; Stream : out asn1SccT_Boolean_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
procedure asn1SccT_Boolean_Encode_aux(val : asn1SccT_Boolean; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
with
    Pre => bs.Current_Bit_Pos < Natural'Last - asn1SccT_Boolean_REQUIRED_BITS_FOR_ENCODING
      and then bs.Size_In_Bytes < Positive'Last / 8
      and then bs.Current_Bit_Pos + asn1SccT_Boolean_REQUIRED_BITS_FOR_ENCODING <= bs.Size_In_Bytes * 8,
       Post => 
         (result.Success and bs.Current_Bit_Pos >= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos <= bs'Old.Current_Bit_Pos + asn1SccT_Boolean_REQUIRED_BITS_FOR_ENCODING)
       or
         not result.Success
;

ERR_UPER_DECODE_T_BOOLEAN:constant Integer := 98; 
procedure asn1SccT_Boolean_Decode(val: out asn1SccT_Boolean; Stream : in out asn1SccT_Boolean_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
procedure asn1SccT_Boolean_Decode_aux(val: out asn1SccT_Boolean; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
with
    Pre => bs.Current_Bit_Pos < Natural'Last - asn1SccT_Boolean_REQUIRED_BITS_FOR_ENCODING
      and then bs.Size_In_Bytes < Positive'Last / 8
      and then bs.Current_Bit_Pos + asn1SccT_Boolean_REQUIRED_BITS_FOR_ENCODING <= bs.Size_In_Bytes * 8,
       Post => 
         (result.Success and bs.Current_Bit_Pos >= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos <= bs'Old.Current_Bit_Pos + asn1SccT_Boolean_REQUIRED_BITS_FOR_ENCODING)
       or
         not result.Success
;
-- asn1SccT_Null_Record --------------------------------------------

type asn1SccT_Null_Record is record 
    null;
end record;


function asn1SccT_Null_Record_Equal(val1, val2 : asn1SccT_Null_Record) return Boolean;

function asn1SccT_Null_Record_Init return asn1SccT_Null_Record;

ERR_T_NULL_RECORD:constant Integer := 101; 
function asn1SccT_Null_Record_IsConstraintValid(val : asn1SccT_Null_Record) return adaasn1rtl.ASN1_RESULT;

asn1SccT_Null_Record_REQUIRED_BYTES_FOR_ENCODING:constant Integer := 0;
asn1SccT_Null_Record_REQUIRED_BITS_FOR_ENCODING:constant Integer := 0;

subtype asn1SccT_Null_Record_uPER_Stream is adaasn1rtl.encoding.Bitstream(1);

procedure asn1SccT_Null_Record_Encode (val : asn1SccT_Null_Record; Stream : out asn1SccT_Null_Record_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
procedure asn1SccT_Null_Record_Encode_aux(val : asn1SccT_Null_Record; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
with
    Pre => bs.Current_Bit_Pos < Natural'Last - asn1SccT_Null_Record_REQUIRED_BITS_FOR_ENCODING
      and then bs.Size_In_Bytes < Positive'Last / 8
      and then bs.Current_Bit_Pos + asn1SccT_Null_Record_REQUIRED_BITS_FOR_ENCODING <= bs.Size_In_Bytes * 8,
       Post => 
         (result.Success and bs.Current_Bit_Pos >= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos <= bs'Old.Current_Bit_Pos + asn1SccT_Null_Record_REQUIRED_BITS_FOR_ENCODING)
       or
         not result.Success
;

procedure asn1SccT_Null_Record_Decode(val: out asn1SccT_Null_Record; Stream : in out asn1SccT_Null_Record_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
procedure asn1SccT_Null_Record_Decode_aux(val: out asn1SccT_Null_Record; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
with
    Pre => bs.Current_Bit_Pos < Natural'Last - asn1SccT_Null_Record_REQUIRED_BITS_FOR_ENCODING
      and then bs.Size_In_Bytes < Positive'Last / 8
      and then bs.Current_Bit_Pos + asn1SccT_Null_Record_REQUIRED_BITS_FOR_ENCODING <= bs.Size_In_Bytes * 8,
       Post => 
         (result.Success and bs.Current_Bit_Pos >= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos <= bs'Old.Current_Bit_Pos + asn1SccT_Null_Record_REQUIRED_BITS_FOR_ENCODING)
       or
         not result.Success
;
pragma Warnings (Off, "there are no others");
 
pragma Warnings (On, "there are no others");
private
   --# hide TASTE_BasicTypes;


end TASTE_BasicTypes;