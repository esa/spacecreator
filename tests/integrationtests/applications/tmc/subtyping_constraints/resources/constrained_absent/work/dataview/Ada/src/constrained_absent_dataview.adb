pragma Style_Checks (Off);
--  Code automatically generated by asn1scc tool
pragma Warnings (Off, "redundant with clause in body");
pragma Warnings (On, "redundant with clause in body");

package body CONSTRAINED_ABSENT_DATAVIEW with SPARK_Mode is



pragma Warnings (Off, "condition can only be False if invalid values present");
pragma Warnings (Off, "condition can only be True if invalid values present");


function asn1SccMyInteger_Equal (val1, val2 :  asn1SccMyInteger) return Boolean
is

begin
	return val1 = val2;

end asn1SccMyInteger_Equal;

function asn1SccMyInteger_IsConstraintValid(val : asn1SccMyInteger) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val <= 10);
    ret.ErrorCode := (if ret.Success then 0 else ERR_MYINTEGER);
    return ret;
end asn1SccMyInteger_IsConstraintValid;

function asn1SccMyInteger_Init return asn1SccMyInteger
is
    val: asn1SccMyInteger;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccMyInteger_Init;



function asn1SccMySeq_validity_Equal (val1, val2 :  asn1SccMySeq_validity) return Boolean
is

begin
	return val1 = val2;

end asn1SccMySeq_validity_Equal;

function asn1SccMySeq_Equal (val1, val2 :  asn1SccMySeq) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (val1.inputdata = val2.inputdata);

    if ret then
        ret := (val1.outputdata = val2.outputdata);

        if ret then
            ret := asn1SccMySeq_validity_Equal(val1.validity, val2.validity);

        end if;
    end if;
	return ret;

end asn1SccMySeq_Equal;

function asn1SccMySeq_validity_IsConstraintValid(val : asn1SccMySeq_validity) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccvalid)) OR ((val = asn1Sccinvalid)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_MYSEQ_VALIDITY);
    return ret;
end asn1SccMySeq_validity_IsConstraintValid;

function asn1SccMySeq_IsConstraintValid(val : asn1SccMySeq) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := asn1SccMyInteger_IsConstraintValid(val.inputdata);
    if ret.Success then
        ret := asn1SccMyInteger_IsConstraintValid(val.outputdata);
        if ret.Success then
            ret := asn1SccMySeq_validity_IsConstraintValid(val.validity);
        end if;
    end if;
    return ret;
end asn1SccMySeq_IsConstraintValid;

function asn1SccMySeq_validity_Init return asn1SccMySeq_validity
is
    val: asn1SccMySeq_validity;
begin
    val := asn1Sccvalid;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccMySeq_validity_Init;
function asn1SccMySeq_Init return asn1SccMySeq
is
    val: asn1SccMySeq;
begin

    --set inputdata 
    val.inputdata := asn1SccMyInteger_Init;
    --set outputdata 
    val.outputdata := asn1SccMyInteger_Init;
    --set validity 
    val.validity := asn1SccMySeq_validity_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccMySeq_Init;



function asn1SccMyChoice_Equal (val1, val2 :  asn1SccMyChoice) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when a_PRESENT =>
                ret := (val1.a = val2.a);
            when b_PRESENT =>
                ret := asn1SccMySeq_Equal(val1.b, val2.b);
        end case;
    end if;
	return ret;

end asn1SccMyChoice_Equal;

function asn1SccMyChoice_IsConstraintValid(val : asn1SccMyChoice) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    if val.kind = b_PRESENT then
    	ret := asn1SccMySeq_IsConstraintValid(val.b);
    end if;
    return ret;
end asn1SccMyChoice_IsConstraintValid;

function asn1SccMyChoice_Init return asn1SccMyChoice
is
    val: asn1SccMyChoice;
begin
    --set a 
    declare
        a_tmp:adaasn1rtl.Asn1Boolean;
    begin
        a_tmp := FALSE;
    	pragma Warnings (Off, "object ""a_tmp"" is always False at this point");
        val := asn1SccMyChoice'(kind => a_PRESENT, a => a_tmp);
    	pragma Warnings (On, "object ""a_tmp"" is always False at this point");
    end;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccMyChoice_Init;



function asn1SccMyEnum_Equal (val1, val2 :  asn1SccMyEnum) return Boolean
is

begin
	return val1 = val2;

end asn1SccMyEnum_Equal;

function asn1SccMyEnum_IsConstraintValid(val : asn1SccMyEnum) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((((val = asn1Scchello)) OR ((val = asn1Sccworld)))) OR ((val = asn1Scchowareyou)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_MYENUM);
    return ret;
end asn1SccMyEnum_IsConstraintValid;

function asn1SccMyEnum_Init return asn1SccMyEnum
is
    val: asn1SccMyEnum;
begin
    val := asn1Scchello;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccMyEnum_Init;



function asn1SccMySeqOf_Equal (val1, val2 :  asn1SccMySeqOf) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end asn1SccMySeqOf_Equal;

function asn1SccMySeqOf_IsConstraintValid(val : asn1SccMySeqOf) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
begin
    ret.Success := (val.Length <= 10);
    ret.ErrorCode := (if ret.Success then 0 else ERR_MYSEQOF);
    if ret.Success then
        i1 := val.Data'First;
        while ret.Success and i1 <= val.Length loop
            pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
            ret := asn1SccMyEnum_IsConstraintValid(val.Data(i1));
            i1 := i1+1;
        end loop;
    end if;
    return ret;
end asn1SccMySeqOf_IsConstraintValid;

function asn1SccMySeqOf_Init return asn1SccMySeqOf
is
    val: asn1SccMySeqOf;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 10 loop
        --  commented because it casues this warning    
        --  warning: condition can only be False if invalid values present
        pragma Loop_Invariant (i1 >=1 and i1<=10);
        val.Data(i1) := asn1SccMyEnum_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccMySeqOf_Init;


pragma Warnings (On, "condition can only be False if invalid values present");
pragma Warnings (On, "condition can only be True if invalid values present");

 
end CONSTRAINED_ABSENT_DATAVIEW;