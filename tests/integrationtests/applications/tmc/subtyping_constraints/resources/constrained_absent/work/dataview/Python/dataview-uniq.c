/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>

#include "asn1crt_encoding.h"
#include "asn1crt_encoding_uper.h"
#include "asn1crt_encoding_acn.h"

#include "dataview-uniq.h"




flag MyInteger_Equal(const MyInteger* pVal1, const MyInteger* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag MyInteger_IsConstraintValid(const MyInteger* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 10UL);
    *pErrCode = ret ? 0 :  ERR_MYINTEGER; 

	return ret;
}

void MyInteger_Initialize(MyInteger* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag MyInteger_Encode(const MyInteger* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? MyInteger_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 10);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag MyInteger_Decode(MyInteger* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 10);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_MYINTEGER;

	return ret  && MyInteger_IsConstraintValid(pVal, pErrCode);
}

flag MyInteger_ACN_Encode(const MyInteger* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? MyInteger_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 10);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag MyInteger_ACN_Decode(MyInteger* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 10);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_MYINTEGER;

    return ret && MyInteger_IsConstraintValid(pVal, pErrCode);
}



flag MySeq_validity_Equal(const MySeq_validity* pVal1, const MySeq_validity* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag MySeq_Equal(const MySeq* pVal1, const MySeq* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->inputdata == pVal2->inputdata);

    if (ret) {
        ret = (pVal1->outputdata == pVal2->outputdata);

        if (ret) {
            ret = MySeq_validity_Equal((&(pVal1->validity)), (&(pVal2->validity)));

        }

    }

	return ret;

}

flag MySeq_validity_IsConstraintValid(const MySeq_validity* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == MySeq_validity_valid)) || (((*(pVal)) == MySeq_validity_invalid)));
    *pErrCode = ret ? 0 :  ERR_MYSEQ_VALIDITY; 

	return ret;
}

flag MySeq_IsConstraintValid(const MySeq* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = MyInteger_IsConstraintValid((&(pVal->inputdata)), pErrCode);
    if (ret) {
        ret = MyInteger_IsConstraintValid((&(pVal->outputdata)), pErrCode);
        if (ret) {
            ret = MySeq_validity_IsConstraintValid((&(pVal->validity)), pErrCode);
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void MySeq_validity_Initialize(MySeq_validity* pVal)
{
	(void)pVal;


	(*(pVal)) = MySeq_validity_valid;
}
void MySeq_Initialize(MySeq* pVal)
{
	(void)pVal;



	/*set inputdata */
	MyInteger_Initialize((&(pVal->inputdata)));
	/*set outputdata */
	MyInteger_Initialize((&(pVal->outputdata)));
	/*set validity */
	MySeq_validity_Initialize((&(pVal->validity)));
}

flag MySeq_Encode(const MySeq* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? MySeq_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode inputdata */
	    ret = MyInteger_Encode((&(pVal->inputdata)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode outputdata */
	        ret = MyInteger_Encode((&(pVal->outputdata)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode validity */
	            switch(pVal->validity) 
	            {
	                case MySeq_validity_valid:   
	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	                	break;
	                case MySeq_validity_invalid:   
	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	                	break;
	                default:                    /*COVERAGE_IGNORE*/
	            	    *pErrCode = ERR_UPER_ENCODE_MYSEQ_VALIDITY; /*COVERAGE_IGNORE*/
	            	    ret = FALSE;            /*COVERAGE_IGNORE*/
	            }
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag MySeq_Decode(MySeq* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode inputdata */
	ret = MyInteger_Decode((&(pVal->inputdata)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode outputdata */
	    ret = MyInteger_Decode((&(pVal->outputdata)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode validity */
	        {
	            asn1SccSint enumIndex;
	            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	            *pErrCode = ret ? 0 : ERR_UPER_DECODE_MYSEQ_VALIDITY;
	            if (ret) {
	                switch(enumIndex) 
	                {
	                    case 0: 
	                        pVal->validity = MySeq_validity_valid;
	                        break;
	                    case 1: 
	                        pVal->validity = MySeq_validity_invalid;
	                        break;
	                    default:                        /*COVERAGE_IGNORE*/
	        	            *pErrCode = ERR_UPER_DECODE_MYSEQ_VALIDITY;     /*COVERAGE_IGNORE*/
	        	            ret = FALSE;                /*COVERAGE_IGNORE*/
	                }
	            } else {
	                pVal->validity = MySeq_validity_valid;             /*COVERAGE_IGNORE*/
	            }
	        }
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

	return ret  && MySeq_IsConstraintValid(pVal, pErrCode);
}

flag MySeq_ACN_Encode(const MySeq* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? MySeq_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode inputdata */
	    ret = MyInteger_ACN_Encode((&(pVal->inputdata)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode outputdata */
	        ret = MyInteger_ACN_Encode((&(pVal->outputdata)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode validity */
	            switch(pVal->validity) { 
	                case MySeq_validity_valid:
	                    uIntVal = 0;
	                    break;
	                case MySeq_validity_invalid:
	                    uIntVal = 1;
	                    break;
	                default:                                    /*COVERAGE_IGNORE*/
	                    ret = FALSE;                            /*COVERAGE_IGNORE*/
	                    *pErrCode = ERR_ACN_ENCODE_MYSEQ_VALIDITY;                 /*COVERAGE_IGNORE*/
	            }
	            if (ret) {
	            	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	            }
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag MySeq_ACN_Decode(MySeq* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	/*Decode inputdata */
	ret = MyInteger_ACN_Decode((&(pVal->inputdata)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode outputdata */
	    ret = MyInteger_ACN_Decode((&(pVal->outputdata)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode validity */
	        ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_MYSEQ_VALIDITY;
	        if (ret) {
	            switch (uIntVal) {
	                case 0:
	                    pVal->validity = MySeq_validity_valid;
	                    break;
	                case 1:
	                    pVal->validity = MySeq_validity_invalid;
	                    break;
	            default:                                    /*COVERAGE_IGNORE*/
	                ret = FALSE;                            /*COVERAGE_IGNORE*/
	                *pErrCode = ERR_ACN_DECODE_MYSEQ_VALIDITY;                 /*COVERAGE_IGNORE*/
	            }
	        } /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

    return ret && MySeq_IsConstraintValid(pVal, pErrCode);
}



flag MyChoice_Equal(const MyChoice* pVal1, const MyChoice* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->kind == pVal2->kind);
    if (ret) {
    	switch(pVal1->kind) 
    	{
    	case MyChoice_a_PRESENT:
    		ret = (pVal1->u.a == pVal2->u.a);
    		break;
    	case MyChoice_b_PRESENT:
    		ret = MySeq_Equal((&(pVal1->u.b)), (&(pVal2->u.b)));
    		break;
    	default: /*COVERAGE_IGNORE*/
    		ret = FALSE;    /*COVERAGE_IGNORE*/
    	}
    } /*COVERAGE_IGNORE*/
	return ret;

}

flag MyChoice_IsConstraintValid(const MyChoice* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->kind == MyChoice_b_PRESENT) {
    	ret = MySeq_IsConstraintValid((&(pVal->u.b)), pErrCode);
    }

	return ret;
}

void MyChoice_Initialize(MyChoice* pVal)
{
	(void)pVal;


	/*set a*/
	pVal->kind = MyChoice_a_PRESENT;
	pVal->u.a = FALSE;
}

flag MyChoice_Encode(const MyChoice* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? MyChoice_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch(pVal->kind) 
	    {
	    case MyChoice_a_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	    	BitStream_AppendBit(pBitStrm,pVal->u.a);
	    	break;
	    case MyChoice_b_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	    	ret = MySeq_Encode((&(pVal->u.b)), pBitStrm, pErrCode, FALSE);
	    	break;
	    default:                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_ENCODE_MYCHOICE;         /*COVERAGE_IGNORE*/
	        ret = FALSE;                    /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag MyChoice_Decode(MyChoice* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint MyChoice_index_tmp;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &MyChoice_index_tmp, 0, 1);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_MYCHOICE;
	if (ret) {
	    switch(MyChoice_index_tmp) 
	    {
	    case 0:
	    	pVal->kind = MyChoice_a_PRESENT;
	    	ret = BitStream_ReadBit(pBitStrm, (&(pVal->u.a)));
	    	*pErrCode = ret ? 0 : ERR_UPER_DECODE_MYCHOICE_A;
	    	break;
	    case 1:
	    	pVal->kind = MyChoice_b_PRESENT;
	    	ret = MySeq_Decode((&(pVal->u.b)), pBitStrm, pErrCode);
	    	break;
	    default:                        /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_DECODE_MYCHOICE;     /*COVERAGE_IGNORE*/
	        ret = FALSE;                /*COVERAGE_IGNORE*/
	    }
	}  /*COVERAGE_IGNORE*/

	return ret  && MyChoice_IsConstraintValid(pVal, pErrCode);
}

flag MyChoice_ACN_Encode(const MyChoice* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? MyChoice_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch(pVal->kind) 
	    {
	    case MyChoice_a_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	    	BitStream_AppendBit(pBitStrm,pVal->u.a);
	    	break;
	    case MyChoice_b_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	    	ret = MySeq_ACN_Encode((&(pVal->u.b)), pBitStrm, pErrCode, FALSE);
	    	break;
	    default: /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_ENCODE_MYCHOICE;         /*COVERAGE_IGNORE*/
	        ret = FALSE;                    /*COVERAGE_IGNORE*/
	    } /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag MyChoice_ACN_Decode(MyChoice* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint CONSTRAINED_ABSENT_DATAVIEW_MyChoice_index_tmp;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &CONSTRAINED_ABSENT_DATAVIEW_MyChoice_index_tmp, 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_MYCHOICE;
	if (ret) {
	    switch(CONSTRAINED_ABSENT_DATAVIEW_MyChoice_index_tmp) 
	    {
	    case 0:
	    	pVal->kind = MyChoice_a_PRESENT;
	    	ret = BitStream_ReadBit(pBitStrm, (&(pVal->u.a)));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_MYCHOICE_A;
	    	break;
	    case 1:
	    	pVal->kind = MyChoice_b_PRESENT;
	    	ret = MySeq_ACN_Decode((&(pVal->u.b)), pBitStrm, pErrCode);
	    	break;
	    default: /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_MYCHOICE;     /*COVERAGE_IGNORE*/
	        ret = FALSE;                /*COVERAGE_IGNORE*/
	    } 
	} /*COVERAGE_IGNORE*/

    return ret && MyChoice_IsConstraintValid(pVal, pErrCode);
}



flag MyEnum_Equal(const MyEnum* pVal1, const MyEnum* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag MyEnum_IsConstraintValid(const MyEnum* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((*(pVal)) == MyEnum_hello)) || (((*(pVal)) == MyEnum_world)))) || (((*(pVal)) == MyEnum_howareyou)));
    *pErrCode = ret ? 0 :  ERR_MYENUM; 

	return ret;
}

void MyEnum_Initialize(MyEnum* pVal)
{
	(void)pVal;


	(*(pVal)) = MyEnum_hello;
}

flag MyEnum_Encode(const MyEnum* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? MyEnum_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case MyEnum_hello:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case MyEnum_world:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case MyEnum_howareyou:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_MYENUM; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag MyEnum_Decode(MyEnum* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_MYENUM;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = MyEnum_hello;
	                break;
	            case 1: 
	                (*(pVal)) = MyEnum_world;
	                break;
	            case 2: 
	                (*(pVal)) = MyEnum_howareyou;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_MYENUM;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = MyEnum_hello;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && MyEnum_IsConstraintValid(pVal, pErrCode);
}

flag MyEnum_ACN_Encode(const MyEnum* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? MyEnum_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case MyEnum_hello:
	            uIntVal = 0;
	            break;
	        case MyEnum_world:
	            uIntVal = 1;
	            break;
	        case MyEnum_howareyou:
	            uIntVal = 2;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_MYENUM;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 2);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag MyEnum_ACN_Decode(MyEnum* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_MYENUM;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = MyEnum_hello;
	            break;
	        case 1:
	            (*(pVal)) = MyEnum_world;
	            break;
	        case 2:
	            (*(pVal)) = MyEnum_howareyou;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_MYENUM;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && MyEnum_IsConstraintValid(pVal, pErrCode);
}



flag MySeqOf_Equal(const MySeqOf* pVal1, const MySeqOf* pVal2)
{
	flag ret=TRUE;
    int i1;

    ret = (pVal1->nCount == pVal2->nCount);
    for(i1 = 0; ret && i1 < pVal1->nCount; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

flag MySeqOf_IsConstraintValid(const MySeqOf* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    ret = (pVal->nCount <= 10);
    *pErrCode = ret ? 0 :  ERR_MYSEQOF; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = MyEnum_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
        }
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void MySeqOf_Initialize(MySeqOf* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 10) {
	    MyEnum_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 0;
}

flag MySeqOf_Encode(const MySeqOf* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	*pErrCode = 0;
	ret = bCheckConstraints ? MySeqOf_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 10);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = MyEnum_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag MySeqOf_Decode(MySeqOf* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 10);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_MYSEQOF;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = MyEnum_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && MySeqOf_IsConstraintValid(pVal, pErrCode);
}

flag MySeqOf_ACN_Encode(const MySeqOf* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
    *pErrCode = 0;
	ret = bCheckConstraints ? MySeqOf_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 10);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = MyEnum_ACN_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag MySeqOf_ACN_Decode(MySeqOf* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 10);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_MYSEQOF;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = MyEnum_ACN_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

    return ret && MySeqOf_IsConstraintValid(pVal, pErrCode);
}



flag T_Int32_Equal(const T_Int32* pVal1, const T_Int32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_Int32_IsConstraintValid(const T_Int32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-2147483648LL <= (*(pVal))) && ((*(pVal)) <= 2147483647LL));
    *pErrCode = ret ? 0 :  ERR_T_INT32; 

	return ret;
}

void T_Int32_Initialize(T_Int32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_Int32_Encode(const T_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int32_Decode(T_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT32;

	return ret  && T_Int32_IsConstraintValid(pVal, pErrCode);
}

flag T_Int32_ACN_Encode(const T_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int32_ACN_Decode(T_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT32;

    return ret && T_Int32_IsConstraintValid(pVal, pErrCode);
}



flag T_UInt32_Equal(const T_UInt32* pVal1, const T_UInt32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_UInt32_IsConstraintValid(const T_UInt32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT32; 

	return ret;
}

void T_UInt32_Initialize(T_UInt32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_UInt32_Encode(const T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt32_Decode(T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT32;

	return ret  && T_UInt32_IsConstraintValid(pVal, pErrCode);
}

flag T_UInt32_ACN_Encode(const T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt32_ACN_Decode(T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT32;

    return ret && T_UInt32_IsConstraintValid(pVal, pErrCode);
}



flag T_Int8_Equal(const T_Int8* pVal1, const T_Int8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_Int8_IsConstraintValid(const T_Int8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-128LL <= (*(pVal))) && ((*(pVal)) <= 127LL));
    *pErrCode = ret ? 0 :  ERR_T_INT8; 

	return ret;
}

void T_Int8_Initialize(T_Int8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_Int8_Encode(const T_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int8_Decode(T_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT8;

	return ret  && T_Int8_IsConstraintValid(pVal, pErrCode);
}

flag T_Int8_ACN_Encode(const T_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int8_ACN_Decode(T_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT8;

    return ret && T_Int8_IsConstraintValid(pVal, pErrCode);
}



flag T_UInt8_Equal(const T_UInt8* pVal1, const T_UInt8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_UInt8_IsConstraintValid(const T_UInt8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT8; 

	return ret;
}

void T_UInt8_Initialize(T_UInt8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_UInt8_Encode(const T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt8_Decode(T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT8;

	return ret  && T_UInt8_IsConstraintValid(pVal, pErrCode);
}

flag T_UInt8_ACN_Encode(const T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt8_ACN_Decode(T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT8;

    return ret && T_UInt8_IsConstraintValid(pVal, pErrCode);
}



flag T_Boolean_Equal(const T_Boolean* pVal1, const T_Boolean* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_Boolean_IsConstraintValid(const T_Boolean* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

void T_Boolean_Initialize(T_Boolean* pVal)
{
	(void)pVal;


	(*(pVal)) = FALSE;
}

flag T_Boolean_Encode(const T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Boolean_Decode(T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_BOOLEAN;

	return ret  && T_Boolean_IsConstraintValid(pVal, pErrCode);
}

flag T_Boolean_ACN_Encode(const T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Boolean_ACN_Decode(T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_BOOLEAN;

    return ret && T_Boolean_IsConstraintValid(pVal, pErrCode);
}



flag T_Null_Record_Equal(const T_Null_Record* pVal1, const T_Null_Record* pVal2)
{
	(void)pVal1;
	(void)pVal2;
	return TRUE;

}

flag T_Null_Record_IsConstraintValid(const T_Null_Record* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

void T_Null_Record_Initialize(T_Null_Record* pVal)
{
	(void)pVal;


}

flag T_Null_Record_Encode(const T_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Null_Record_Decode(T_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;
	(void)pBitStrm;



	return ret  && T_Null_Record_IsConstraintValid(pVal, pErrCode);
}

flag T_Null_Record_ACN_Encode(const T_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Null_Record_ACN_Decode(T_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	(void)pBitStrm;
	*pErrCode = 0;



    return ret && T_Null_Record_IsConstraintValid(pVal, pErrCode);
}



flag PID_Equal(const PID* pVal1, const PID* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag PID_IsConstraintValid(const PID* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((*(pVal)) == PID_function_1)) || (((*(pVal)) == PID_function_2)))) || (((*(pVal)) == PID_env)));
    *pErrCode = ret ? 0 :  ERR_PID; 

	return ret;
}

void PID_Initialize(PID* pVal)
{
	(void)pVal;


	(*(pVal)) = PID_function_1;
}

flag PID_Encode(const PID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? PID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case PID_function_1:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case PID_function_2:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case PID_env:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_PID; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PID_Decode(PID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_PID;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = PID_function_1;
	                break;
	            case 1: 
	                (*(pVal)) = PID_function_2;
	                break;
	            case 2: 
	                (*(pVal)) = PID_env;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_PID;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = PID_function_1;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && PID_IsConstraintValid(pVal, pErrCode);
}

flag PID_ACN_Encode(const PID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? PID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case PID_function_1:
	            uIntVal = 0;
	            break;
	        case PID_function_2:
	            uIntVal = 1;
	            break;
	        case PID_env:
	            uIntVal = 2;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_PID;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 2);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PID_ACN_Decode(PID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PID;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = PID_function_1;
	            break;
	        case 1:
	            (*(pVal)) = PID_function_2;
	            break;
	        case 2:
	            (*(pVal)) = PID_env;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_PID;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && PID_IsConstraintValid(pVal, pErrCode);
}

