pragma Style_Checks (Off);
--  Code automatically generated by asn1scc tool
with adaasn1rtl;


pragma Warnings (Off, "unit ""System"" is not referenced");
with System;
pragma Warnings (On, "unit ""System"" is not referenced");

pragma Warnings (Off, "use clause for package ""adaasn1rtl"" has no effect");
use adaasn1rtl;
pragma Warnings (On, "use clause for package ""adaasn1rtl"" has no effect");

pragma Warnings (Off, "use clause for type");
pragma Warnings (Off, "is already use-visible through package use clause at line");
use type adaasn1rtl.OctetBuffer;
use type adaasn1rtl.BitArray;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;
pragma Warnings (On, "use clause for type");
pragma Warnings (On, "is already use-visible through package use clause at line");



package CONSTRAINED_ABSENT_DATAVIEW with SPARK_Mode
is


subtype asn1SccMyInteger is adaasn1rtl.Asn1UInt range 0 .. 4;


function asn1SccMyInteger_Equal(val1, val2 : asn1SccMyInteger) return Boolean;

ERR_MYINTEGER:constant Integer := 1; -- (0 .. 4)
function asn1SccMyInteger_IsConstraintValid(val : asn1SccMyInteger) return adaasn1rtl.ASN1_RESULT;

function asn1SccMyInteger_Init return asn1SccMyInteger;
-- asn1SccMySeq --------------------------------------------
subtype asn1SccMySeq_validity_index_range is Integer range 0..1;
type asn1SccMySeq_validity is (asn1Sccvalid, asn1Sccinvalid) with Size => adaasn1rtl.Enumerated_Size;
for asn1SccMySeq_validity use
    (asn1Sccvalid => 0, asn1Sccinvalid => 1);

type asn1SccMySeq is record 
    inputdata : asn1SccMyInteger;
    outputdata : asn1SccMyInteger;
    validity : asn1SccMySeq_validity;
end record;


function asn1SccMySeq_validity_Equal(val1, val2 : asn1SccMySeq_validity) return Boolean;

function asn1SccMySeq_Equal(val1, val2 : asn1SccMySeq) return Boolean;

ERR_MYSEQ_VALIDITY:constant Integer := 31; -- valid | invalid
function asn1SccMySeq_validity_IsConstraintValid(val : asn1SccMySeq_validity) return adaasn1rtl.ASN1_RESULT;

ERR_MYSEQ:constant Integer := 36; -- 
ERR_MYSEQ_INPUTDATA_2:constant Integer := 16; -- 
ERR_MYSEQ_OUTPUTDATA_2:constant Integer := 26; -- 
function asn1SccMySeq_IsConstraintValid(val : asn1SccMySeq) return adaasn1rtl.ASN1_RESULT;

function asn1SccMySeq_validity_Init return asn1SccMySeq_validity;
function asn1SccMySeq_Init return asn1SccMySeq;
-- asn1SccMyChoice --------------------------------------------

subtype asn1SccMyChoice_index_range is Integer range 0..1;

type asn1SccMyChoice_selection is (a_PRESENT, b_PRESENT);
for asn1SccMyChoice_selection use
    (a_PRESENT => 1, b_PRESENT => 2);
for asn1SccMyChoice_selection'Size use 32;

type asn1SccMyChoice(kind : asn1SccMyChoice_selection:= a_PRESENT) is 
record
    case kind is
    when a_PRESENT =>
            a: adaasn1rtl.Asn1Boolean;
    when b_PRESENT =>
            b: asn1SccMySeq;
    end case;
end record;

for asn1SccMyChoice use 
record
    kind at 0 range 0..31;
end record;

function asn1SccMyChoice_Equal(val1, val2 : asn1SccMyChoice) return Boolean;

ERR_MYCHOICE:constant Integer := 81; -- 
ERR_MYCHOICE_A:constant Integer := 41; -- 
ERR_MYCHOICE_B_2:constant Integer := 76; -- 
function asn1SccMyChoice_IsConstraintValid(val : asn1SccMyChoice) return adaasn1rtl.ASN1_RESULT;

function asn1SccMyChoice_Init return asn1SccMyChoice;
subtype asn1SccMyEnum_index_range is Integer range 0..2;
type asn1SccMyEnum is (asn1Scchello, asn1Sccworld, asn1Scchowareyou) with Size => adaasn1rtl.Enumerated_Size;
for asn1SccMyEnum use
    (asn1Scchello => 0, asn1Sccworld => 1, asn1Scchowareyou => 2);

function asn1SccMyEnum_Equal(val1, val2 : asn1SccMyEnum) return Boolean;

ERR_MYENUM:constant Integer := 6; -- hello | world | howareyou
function asn1SccMyEnum_IsConstraintValid(val : asn1SccMyEnum) return adaasn1rtl.ASN1_RESULT;

function asn1SccMyEnum_Init return asn1SccMyEnum;
-- asn1SccMySeqOf --------------------------------------------


subtype asn1SccMySeqOf_index is Integer range 1..10;
type asn1SccMySeqOf_array is array (asn1SccMySeqOf_index) of asn1SccMyEnum;
subtype asn1SccMySeqOf_length_index is Integer range 0..10;
type asn1SccMySeqOf is  record
    Length : asn1SccMySeqOf_length_index;
    Data  : asn1SccMySeqOf_array;
end record;

function asn1SccMySeqOf_Equal(val1, val2 : asn1SccMySeqOf) return Boolean;

ERR_MYSEQOF:constant Integer := 96; -- (SIZE (0..10))
ERR_MYSEQOF_ELM_2:constant Integer := 91; -- 
function asn1SccMySeqOf_IsConstraintValid(val : asn1SccMySeqOf) return adaasn1rtl.ASN1_RESULT;

function asn1SccMySeqOf_Init return asn1SccMySeqOf;
pragma Warnings (Off, "there are no others");
 
pragma Warnings (On, "there are no others");
private
   --# hide CONSTRAINED_ABSENT_DATAVIEW;


end CONSTRAINED_ABSENT_DATAVIEW;