/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>

#include "asn1crt_encoding.h"
#include "asn1crt_encoding_uper.h"
#include "asn1crt_encoding_acn.h"

#include "dataview-uniq.h"




flag asn1SccMyInteger_Equal(const asn1SccMyInteger* pVal1, const asn1SccMyInteger* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccMyInteger_IsConstraintValid(const asn1SccMyInteger* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4UL);
    *pErrCode = ret ? 0 :  ERR_MYINTEGER; 

	return ret;
}

void asn1SccMyInteger_Initialize(asn1SccMyInteger* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccMyInteger_Encode(const asn1SccMyInteger* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccMyInteger_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccMyInteger_Decode(asn1SccMyInteger* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_MYINTEGER;

	return ret  && asn1SccMyInteger_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccMyInteger_ACN_Encode(const asn1SccMyInteger* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccMyInteger_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccMyInteger_ACN_Decode(asn1SccMyInteger* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_MYINTEGER;

    return ret && asn1SccMyInteger_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccMySeq_validity_Equal(const asn1SccMySeq_validity* pVal1, const asn1SccMySeq_validity* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccMySeq_Equal(const asn1SccMySeq* pVal1, const asn1SccMySeq* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->inputdata == pVal2->inputdata);

    if (ret) {
        ret = (pVal1->outputdata == pVal2->outputdata);

        if (ret) {
            ret = asn1SccMySeq_validity_Equal((&(pVal1->validity)), (&(pVal2->validity)));

        }

    }

	return ret;

}

flag asn1SccMySeq_validity_IsConstraintValid(const asn1SccMySeq_validity* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == MySeq_validity_valid)) || (((*(pVal)) == MySeq_validity_invalid)));
    *pErrCode = ret ? 0 :  ERR_MYSEQ_VALIDITY; 

	return ret;
}

flag asn1SccMySeq_IsConstraintValid(const asn1SccMySeq* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccMyInteger_IsConstraintValid((&(pVal->inputdata)), pErrCode);
    if (ret) {
        ret = asn1SccMyInteger_IsConstraintValid((&(pVal->outputdata)), pErrCode);
        if (ret) {
            ret = asn1SccMySeq_validity_IsConstraintValid((&(pVal->validity)), pErrCode);
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void asn1SccMySeq_validity_Initialize(asn1SccMySeq_validity* pVal)
{
	(void)pVal;


	(*(pVal)) = MySeq_validity_valid;
}
void asn1SccMySeq_Initialize(asn1SccMySeq* pVal)
{
	(void)pVal;



	/*set inputdata */
	asn1SccMyInteger_Initialize((&(pVal->inputdata)));
	/*set outputdata */
	asn1SccMyInteger_Initialize((&(pVal->outputdata)));
	/*set validity */
	asn1SccMySeq_validity_Initialize((&(pVal->validity)));
}

flag asn1SccMySeq_Encode(const asn1SccMySeq* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccMySeq_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode inputdata */
	    ret = asn1SccMyInteger_Encode((&(pVal->inputdata)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode outputdata */
	        ret = asn1SccMyInteger_Encode((&(pVal->outputdata)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode validity */
	            switch(pVal->validity) 
	            {
	                case MySeq_validity_valid:   
	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	                	break;
	                case MySeq_validity_invalid:   
	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	                	break;
	                default:                    /*COVERAGE_IGNORE*/
	            	    *pErrCode = ERR_UPER_ENCODE_MYSEQ_VALIDITY; /*COVERAGE_IGNORE*/
	            	    ret = FALSE;            /*COVERAGE_IGNORE*/
	            }
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccMySeq_Decode(asn1SccMySeq* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode inputdata */
	ret = asn1SccMyInteger_Decode((&(pVal->inputdata)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode outputdata */
	    ret = asn1SccMyInteger_Decode((&(pVal->outputdata)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode validity */
	        {
	            asn1SccSint enumIndex;
	            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	            *pErrCode = ret ? 0 : ERR_UPER_DECODE_MYSEQ_VALIDITY;
	            if (ret) {
	                switch(enumIndex) 
	                {
	                    case 0: 
	                        pVal->validity = MySeq_validity_valid;
	                        break;
	                    case 1: 
	                        pVal->validity = MySeq_validity_invalid;
	                        break;
	                    default:                        /*COVERAGE_IGNORE*/
	        	            *pErrCode = ERR_UPER_DECODE_MYSEQ_VALIDITY;     /*COVERAGE_IGNORE*/
	        	            ret = FALSE;                /*COVERAGE_IGNORE*/
	                }
	            } else {
	                pVal->validity = MySeq_validity_valid;             /*COVERAGE_IGNORE*/
	            }
	        }
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

	return ret  && asn1SccMySeq_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccMySeq_ACN_Encode(const asn1SccMySeq* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccMySeq_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode inputdata */
	    ret = asn1SccMyInteger_ACN_Encode((&(pVal->inputdata)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode outputdata */
	        ret = asn1SccMyInteger_ACN_Encode((&(pVal->outputdata)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode validity */
	            switch(pVal->validity) { 
	                case MySeq_validity_valid:
	                    uIntVal = 0;
	                    break;
	                case MySeq_validity_invalid:
	                    uIntVal = 1;
	                    break;
	                default:                                    /*COVERAGE_IGNORE*/
	                    ret = FALSE;                            /*COVERAGE_IGNORE*/
	                    *pErrCode = ERR_ACN_ENCODE_MYSEQ_VALIDITY;                 /*COVERAGE_IGNORE*/
	            }
	            if (ret) {
	            	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	            }
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccMySeq_ACN_Decode(asn1SccMySeq* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	/*Decode inputdata */
	ret = asn1SccMyInteger_ACN_Decode((&(pVal->inputdata)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode outputdata */
	    ret = asn1SccMyInteger_ACN_Decode((&(pVal->outputdata)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode validity */
	        ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_MYSEQ_VALIDITY;
	        if (ret) {
	            switch (uIntVal) {
	                case 0:
	                    pVal->validity = MySeq_validity_valid;
	                    break;
	                case 1:
	                    pVal->validity = MySeq_validity_invalid;
	                    break;
	            default:                                    /*COVERAGE_IGNORE*/
	                ret = FALSE;                            /*COVERAGE_IGNORE*/
	                *pErrCode = ERR_ACN_DECODE_MYSEQ_VALIDITY;                 /*COVERAGE_IGNORE*/
	            }
	        } /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

    return ret && asn1SccMySeq_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccMyChoice_Equal(const asn1SccMyChoice* pVal1, const asn1SccMyChoice* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->kind == pVal2->kind);
    if (ret) {
    	switch(pVal1->kind) 
    	{
    	case MyChoice_a_PRESENT:
    		ret = (pVal1->u.a == pVal2->u.a);
    		break;
    	case MyChoice_b_PRESENT:
    		ret = asn1SccMySeq_Equal((&(pVal1->u.b)), (&(pVal2->u.b)));
    		break;
    	default: /*COVERAGE_IGNORE*/
    		ret = FALSE;    /*COVERAGE_IGNORE*/
    	}
    } /*COVERAGE_IGNORE*/
	return ret;

}

flag asn1SccMyChoice_IsConstraintValid(const asn1SccMyChoice* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->kind == MyChoice_b_PRESENT) {
    	ret = asn1SccMySeq_IsConstraintValid((&(pVal->u.b)), pErrCode);
    }

	return ret;
}

void asn1SccMyChoice_Initialize(asn1SccMyChoice* pVal)
{
	(void)pVal;


	/*set a*/
	pVal->kind = MyChoice_a_PRESENT;
	pVal->u.a = FALSE;
}

flag asn1SccMyChoice_Encode(const asn1SccMyChoice* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccMyChoice_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch(pVal->kind) 
	    {
	    case MyChoice_a_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	    	BitStream_AppendBit(pBitStrm,pVal->u.a);
	    	break;
	    case MyChoice_b_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	    	ret = asn1SccMySeq_Encode((&(pVal->u.b)), pBitStrm, pErrCode, FALSE);
	    	break;
	    default:                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_ENCODE_MYCHOICE;         /*COVERAGE_IGNORE*/
	        ret = FALSE;                    /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccMyChoice_Decode(asn1SccMyChoice* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint asn1SccMyChoice_index_tmp;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &asn1SccMyChoice_index_tmp, 0, 1);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_MYCHOICE;
	if (ret) {
	    switch(asn1SccMyChoice_index_tmp) 
	    {
	    case 0:
	    	pVal->kind = MyChoice_a_PRESENT;
	    	ret = BitStream_ReadBit(pBitStrm, (&(pVal->u.a)));
	    	*pErrCode = ret ? 0 : ERR_UPER_DECODE_MYCHOICE_A;
	    	break;
	    case 1:
	    	pVal->kind = MyChoice_b_PRESENT;
	    	ret = asn1SccMySeq_Decode((&(pVal->u.b)), pBitStrm, pErrCode);
	    	break;
	    default:                        /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_DECODE_MYCHOICE;     /*COVERAGE_IGNORE*/
	        ret = FALSE;                /*COVERAGE_IGNORE*/
	    }
	}  /*COVERAGE_IGNORE*/

	return ret  && asn1SccMyChoice_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccMyChoice_ACN_Encode(const asn1SccMyChoice* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccMyChoice_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch(pVal->kind) 
	    {
	    case MyChoice_a_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	    	BitStream_AppendBit(pBitStrm,pVal->u.a);
	    	break;
	    case MyChoice_b_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	    	ret = asn1SccMySeq_ACN_Encode((&(pVal->u.b)), pBitStrm, pErrCode, FALSE);
	    	break;
	    default: /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_ENCODE_MYCHOICE;         /*COVERAGE_IGNORE*/
	        ret = FALSE;                    /*COVERAGE_IGNORE*/
	    } /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccMyChoice_ACN_Decode(asn1SccMyChoice* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint CONSTRAINED_ABSENT_DATAVIEW_MyChoice_index_tmp;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &CONSTRAINED_ABSENT_DATAVIEW_MyChoice_index_tmp, 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_MYCHOICE;
	if (ret) {
	    switch(CONSTRAINED_ABSENT_DATAVIEW_MyChoice_index_tmp) 
	    {
	    case 0:
	    	pVal->kind = MyChoice_a_PRESENT;
	    	ret = BitStream_ReadBit(pBitStrm, (&(pVal->u.a)));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_MYCHOICE_A;
	    	break;
	    case 1:
	    	pVal->kind = MyChoice_b_PRESENT;
	    	ret = asn1SccMySeq_ACN_Decode((&(pVal->u.b)), pBitStrm, pErrCode);
	    	break;
	    default: /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_MYCHOICE;     /*COVERAGE_IGNORE*/
	        ret = FALSE;                /*COVERAGE_IGNORE*/
	    } 
	} /*COVERAGE_IGNORE*/

    return ret && asn1SccMyChoice_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccMyEnum_Equal(const asn1SccMyEnum* pVal1, const asn1SccMyEnum* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccMyEnum_IsConstraintValid(const asn1SccMyEnum* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((*(pVal)) == MyEnum_hello)) || (((*(pVal)) == MyEnum_world)))) || (((*(pVal)) == MyEnum_howareyou)));
    *pErrCode = ret ? 0 :  ERR_MYENUM; 

	return ret;
}

void asn1SccMyEnum_Initialize(asn1SccMyEnum* pVal)
{
	(void)pVal;


	(*(pVal)) = MyEnum_hello;
}

flag asn1SccMyEnum_Encode(const asn1SccMyEnum* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccMyEnum_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case MyEnum_hello:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case MyEnum_world:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case MyEnum_howareyou:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_MYENUM; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccMyEnum_Decode(asn1SccMyEnum* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_MYENUM;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = MyEnum_hello;
	                break;
	            case 1: 
	                (*(pVal)) = MyEnum_world;
	                break;
	            case 2: 
	                (*(pVal)) = MyEnum_howareyou;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_MYENUM;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = MyEnum_hello;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccMyEnum_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccMyEnum_ACN_Encode(const asn1SccMyEnum* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccMyEnum_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case MyEnum_hello:
	            uIntVal = 0;
	            break;
	        case MyEnum_world:
	            uIntVal = 1;
	            break;
	        case MyEnum_howareyou:
	            uIntVal = 2;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_MYENUM;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 2);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccMyEnum_ACN_Decode(asn1SccMyEnum* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_MYENUM;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = MyEnum_hello;
	            break;
	        case 1:
	            (*(pVal)) = MyEnum_world;
	            break;
	        case 2:
	            (*(pVal)) = MyEnum_howareyou;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_MYENUM;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && asn1SccMyEnum_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccMySeqOf_Equal(const asn1SccMySeqOf* pVal1, const asn1SccMySeqOf* pVal2)
{
	flag ret=TRUE;
    int i1;

    ret = (pVal1->nCount == pVal2->nCount);
    for(i1 = 0; ret && i1 < pVal1->nCount; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

flag asn1SccMySeqOf_IsConstraintValid(const asn1SccMySeqOf* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    ret = (pVal->nCount <= 10);
    *pErrCode = ret ? 0 :  ERR_MYSEQOF; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = asn1SccMyEnum_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
        }
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void asn1SccMySeqOf_Initialize(asn1SccMySeqOf* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 10) {
	    asn1SccMyEnum_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 0;
}

flag asn1SccMySeqOf_Encode(const asn1SccMySeqOf* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccMySeqOf_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 10);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccMyEnum_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccMySeqOf_Decode(asn1SccMySeqOf* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 10);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_MYSEQOF;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccMyEnum_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccMySeqOf_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccMySeqOf_ACN_Encode(const asn1SccMySeqOf* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccMySeqOf_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 10);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccMyEnum_ACN_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccMySeqOf_ACN_Decode(asn1SccMySeqOf* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 10);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_MYSEQOF;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccMyEnum_ACN_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

    return ret && asn1SccMySeqOf_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Int32_Equal(const asn1SccT_Int32* pVal1, const asn1SccT_Int32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccT_Int32_IsConstraintValid(const asn1SccT_Int32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-2147483648LL <= (*(pVal))) && ((*(pVal)) <= 2147483647LL));
    *pErrCode = ret ? 0 :  ERR_T_INT32; 

	return ret;
}

void asn1SccT_Int32_Initialize(asn1SccT_Int32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_Int32_Encode(const asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int32_Decode(asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT32;

	return ret  && asn1SccT_Int32_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Int32_ACN_Encode(const asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int32_ACN_Decode(asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT32;

    return ret && asn1SccT_Int32_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_UInt32_Equal(const asn1SccT_UInt32* pVal1, const asn1SccT_UInt32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccT_UInt32_IsConstraintValid(const asn1SccT_UInt32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT32; 

	return ret;
}

void asn1SccT_UInt32_Initialize(asn1SccT_UInt32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_UInt32_Encode(const asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt32_Decode(asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT32;

	return ret  && asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_UInt32_ACN_Encode(const asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt32_ACN_Decode(asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT32;

    return ret && asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Int8_Equal(const asn1SccT_Int8* pVal1, const asn1SccT_Int8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccT_Int8_IsConstraintValid(const asn1SccT_Int8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-128LL <= (*(pVal))) && ((*(pVal)) <= 127LL));
    *pErrCode = ret ? 0 :  ERR_T_INT8; 

	return ret;
}

void asn1SccT_Int8_Initialize(asn1SccT_Int8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_Int8_Encode(const asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int8_Decode(asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT8;

	return ret  && asn1SccT_Int8_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Int8_ACN_Encode(const asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int8_ACN_Decode(asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT8;

    return ret && asn1SccT_Int8_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_UInt8_Equal(const asn1SccT_UInt8* pVal1, const asn1SccT_UInt8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccT_UInt8_IsConstraintValid(const asn1SccT_UInt8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT8; 

	return ret;
}

void asn1SccT_UInt8_Initialize(asn1SccT_UInt8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_UInt8_Encode(const asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt8_Decode(asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT8;

	return ret  && asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_UInt8_ACN_Encode(const asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt8_ACN_Decode(asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT8;

    return ret && asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Boolean_Equal(const asn1SccT_Boolean* pVal1, const asn1SccT_Boolean* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccT_Boolean_IsConstraintValid(const asn1SccT_Boolean* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

void asn1SccT_Boolean_Initialize(asn1SccT_Boolean* pVal)
{
	(void)pVal;


	(*(pVal)) = FALSE;
}

flag asn1SccT_Boolean_Encode(const asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Boolean_Decode(asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_BOOLEAN;

	return ret  && asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Boolean_ACN_Encode(const asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Boolean_ACN_Decode(asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_BOOLEAN;

    return ret && asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Null_Record_Equal(const asn1SccT_Null_Record* pVal1, const asn1SccT_Null_Record* pVal2)
{
	(void)pVal1;
	(void)pVal2;
	return TRUE;

}

flag asn1SccT_Null_Record_IsConstraintValid(const asn1SccT_Null_Record* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

void asn1SccT_Null_Record_Initialize(asn1SccT_Null_Record* pVal)
{
	(void)pVal;


}

flag asn1SccT_Null_Record_Encode(const asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Null_Record_Decode(asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;
	(void)pBitStrm;



	return ret  && asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Null_Record_ACN_Encode(const asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Null_Record_ACN_Decode(asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	(void)pBitStrm;
	*pErrCode = 0;



    return ret && asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccPID_Equal(const asn1SccPID* pVal1, const asn1SccPID* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPID_IsConstraintValid(const asn1SccPID* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((*(pVal)) == PID_function_1)) || (((*(pVal)) == PID_function_2)))) || (((*(pVal)) == PID_env)));
    *pErrCode = ret ? 0 :  ERR_PID; 

	return ret;
}

void asn1SccPID_Initialize(asn1SccPID* pVal)
{
	(void)pVal;


	(*(pVal)) = PID_function_1;
}

flag asn1SccPID_Encode(const asn1SccPID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccPID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case PID_function_1:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case PID_function_2:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case PID_env:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_PID; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPID_Decode(asn1SccPID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_PID;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = PID_function_1;
	                break;
	            case 1: 
	                (*(pVal)) = PID_function_2;
	                break;
	            case 2: 
	                (*(pVal)) = PID_env;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_PID;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = PID_function_1;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccPID_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccPID_ACN_Encode(const asn1SccPID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccPID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case PID_function_1:
	            uIntVal = 0;
	            break;
	        case PID_function_2:
	            uIntVal = 1;
	            break;
	        case PID_env:
	            uIntVal = 2;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_PID;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 2);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPID_ACN_Decode(asn1SccPID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PID;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = PID_function_1;
	            break;
	        case 1:
	            (*(pVal)) = PID_function_2;
	            break;
	        case 2:
	            (*(pVal)) = PID_env;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_PID;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && asn1SccPID_IsConstraintValid(pVal, pErrCode);
}

