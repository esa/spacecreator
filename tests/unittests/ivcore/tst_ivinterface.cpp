/*
   Copyright (C) 2021 European Space Agency - <maxime.perrotin@esa.int>

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public License
   along with this program. If not, see <https://www.gnu.org/licenses/lgpl-2.1.html>.
*/

#include "ivcommonprops.h"
#include "ivconnection.h"
#include "ivfunction.h"
#include "ivinterface.h"
#include "ivlibrary.h"
#include "ivmodel.h"
#include "ivnamevalidator.h"
#include "ivpropertytemplateconfig.h"
#include "ivtestutils.h"
#include "standardpaths.h"

#include <QTest>
#include <memory>

class tst_IVInterface : public QObject
{
    Q_OBJECT

private Q_SLOTS:
    void initTestCase();
    void init();
    void cleanup();
    void tst_setAttr_Autoname();
    void tst_reqIfaceAutorename();
    void tst_InheritNamesFromFunctionTypes();
    void tst_renameConnectedRIs();
    void tst_InheritNamesFromFunctionTypesPrefixedFunction();

private:
    ivm::IVFunction *addFunction(const QString &name)
    {
        auto func = new ivm::IVFunction;
        func->setTitle(name);
        m_model->addObject(func);
        return func;
    }
    ivm::IVInterfaceProvided *addProvidedInterface(ivm::IVFunctionType *fn, const QString &name)
    {
        ivm::IVInterfaceProvided *piInterface = ivm::testutils::createProvidedIface(fn, name);
        if (fn) {
            fn->addChild(piInterface);
        }
        m_model->addObject(piInterface);
        return piInterface;
    }
    ivm::IVInterfaceRequired *addRequiredInterface(ivm::IVFunctionType *fn, const QString &name)
    {
        ivm::IVInterfaceRequired *riInterface = ivm::testutils::createRequiredIface(fn, name);
        if (fn) {
            fn->addChild(riInterface);
        }
        m_model->addObject(riInterface);
        return riInterface;
    }

    ivm::IVPropertyTemplateConfig *cfg { nullptr };
    std::unique_ptr<ivm::IVModel> m_model;
};

void tst_IVInterface::initTestCase()
{
    shared::StandardPaths::setTestModeEnabled(true);
    ivm::initIVLibrary();
    cfg = ivm::IVPropertyTemplateConfig::instance();
    cfg->init(QLatin1String("default_attributes.xml"));
}

void tst_IVInterface::init()
{
    m_model = std::make_unique<ivm::IVModel>(cfg);
}

void tst_IVInterface::cleanup()
{
    m_model->clear();
}
void tst_IVInterface::tst_setAttr_Autoname()
{
    static const QString autonamedPropName = ivm::meta::Props::token(ivm::meta::Props::Token::Autonamed);

    ivm::IVFunction *func = addFunction("func");

    ivm::IVInterface::CreationInfo ci;
    ivm::IVInterfaceRequired *reqIface = addRequiredInterface(func, "");

    QVERIFY(reqIface->isAutoNamed());
    QVERIFY(reqIface->isInheritPI());
    QVERIFY(reqIface->hasEntityAttribute(autonamedPropName, true));

    reqIface->setTitle(QLatin1String("SomeNameForReqIface"));
    QCOMPARE(reqIface->hasEntityAttribute(autonamedPropName, false), true);
    QVERIFY(!reqIface->isAutoNamed());

    reqIface->setEntityAttribute(ivm::meta::Props::token(ivm::meta::Props::Token::name), QString());
    QVERIFY(ivm::IVNameValidator::isAutogeneratedName(reqIface, reqIface->title()));
    QVERIFY(reqIface->hasEntityAttribute(autonamedPropName));
    QVERIFY(reqIface->entityAttributeValue<bool>(autonamedPropName));
    QVERIFY(reqIface->isAutoNamed());

    ivm::IVInterfaceProvided *provIface = addProvidedInterface(func, "");
    reqIface->setPrototype(provIface);
    QVERIFY(reqIface->hasEntityAttribute(autonamedPropName));
    QVERIFY(reqIface->entityAttributeValue<bool>(autonamedPropName));

    provIface->setTitle(QLatin1String("ProvIfaceName"));
    QCOMPARE(provIface->title(), reqIface->title());

    reqIface->setTitle(QLatin1String("NewNameForReqIface"));
    QVERIFY(provIface->title() != reqIface->title());
    QVERIFY(!reqIface->entityAttributeValue<bool>(autonamedPropName));

    reqIface->unsetPrototype(provIface);
    QVERIFY(provIface->title() != reqIface->title());
    QVERIFY(reqIface->hasEntityAttribute(autonamedPropName, false));
    QVERIFY(!reqIface->isAutoNamed());
}

void tst_IVInterface::tst_reqIfaceAutorename()
{
    auto func1 = new ivm::IVFunction;
    func1->setTitle("F1");
    m_model->addObject(func1);
    ivm::IVInterfaceProvided *provIface1 { ivm::testutils::createProvidedIface(func1, "P1") };
    func1->addChild(provIface1);
    m_model->addObject(provIface1);

    auto func2 = new ivm::IVFunction;
    func2->setTitle("F2");
    m_model->addObject(func2);
    ivm::IVInterfaceProvided *provIface2 { ivm::testutils::createProvidedIface(func2, "P1") };
    func2->addChild(provIface2);
    m_model->addObject(provIface2);

    auto func3 = new ivm::IVFunction();
    m_model->addObject(func3);
    func3->setTitle("F3");
    ivm::IVInterfaceRequired *reqIface1 { ivm::testutils::createRequiredIface(func3) };
    func3->addChild(reqIface1);
    m_model->addObject(reqIface1);
    reqIface1->setPrototype(provIface1);
    QCOMPARE(reqIface1->title(), provIface1->title());

    ivm::IVInterfaceRequired *reqIface2 { ivm::testutils::createRequiredIface(func3) };
    QCOMPARE(reqIface2->isAutoNamed(), true);
    func3->addChild(reqIface2);
    m_model->addObject(reqIface2);
    QCOMPARE(reqIface2->isAutoNamed(), true);
    reqIface2->setPrototype(provIface2);
    QCOMPARE(reqIface2->isAutoNamed(), true);
    const QString reqIface2Name = func2->title() + QLatin1Char('_') + provIface2->title();
    QCOMPARE(reqIface2Name, reqIface2->title());
    QCOMPARE(reqIface2->isAutoNamed(), true);

    provIface2->setTitle("P2");
    QCOMPARE(provIface2->title(), reqIface2->title());

    QString title = QLatin1String("P1");
    ivm::IVInterfaceProvided *provIface3 { ivm::testutils::createProvidedIface(func3, title) };
    func3->addChild(provIface3);
    m_model->addObject(provIface3);
    QCOMPARE(provIface3->title(), title);

    ivm::IVInterfaceRequired *reqIface3 { ivm::testutils::createRequiredIface(func2, title) };
    func2->addChild(reqIface3);
    m_model->addObject(reqIface3);
    reqIface3->setPrototype(provIface3);
    QCOMPARE(provIface3->title(), reqIface3->title());

    title = QLatin1String("P5");
    ivm::IVInterfaceProvided *provIface5 { ivm::testutils::createProvidedIface(func3, title) };
    func3->addChild(provIface5);
    m_model->addObject(provIface5);
    QCOMPARE(provIface5->title(), title);

    title = QLatin1String("P1");
    provIface5->setTitle(title);
    QVERIFY(provIface5->title() != title);
}

/*!
 * See IVInterface documentation:
 * * PI/RI inherited from a function type can't be edited by the user
 */
void tst_IVInterface::tst_InheritNamesFromFunctionTypes()
{
    auto funcType = new ivm::IVFunctionType;
    funcType->setTitle(QLatin1String("FT1"));
    m_model->addObject(funcType);
    ivm::IVInterfaceProvided *typePI = addProvidedInterface(funcType, "parse");
    ivm::IVInterfaceRequired *typeRI = addRequiredInterface(funcType, "parse");

    auto func1 = addFunction("F1");
    QCOMPARE(func1->interfaces().size(), 0);

    // Now inherit from the type
    auto clonePI = ivm::IVInterface::CreationInfo::cloneIface(typePI, func1);
    ivm::IVInterface *clonedPI = ivm::IVInterface::createIface(clonePI);
    func1->addChild(clonedPI);
    m_model->addObject(clonedPI);
    auto cloneRI = ivm::IVInterface::CreationInfo::cloneIface(typeRI, func1);
    ivm::IVInterface *clonedRI = ivm::IVInterface::createIface(cloneRI);
    func1->addChild(clonedRI);
    m_model->addObject(clonedRI);
    func1->setInstanceOf(funcType);
    QCOMPARE(func1->interfaces().size(), 2);

    QCOMPARE(clonedPI->title(), typePI->title());
    QCOMPARE(clonedRI->title(), typeRI->title());

    // Check that cloned names (from type), can't be overwritten
    clonedPI->setTitle("NewPIname");
    clonedRI->setTitle("NewPIname");
    QCOMPARE(clonedPI->title(), typePI->title());
    QCOMPARE(clonedRI->title(), typeRI->title());
}

/*!
 * See IVInterface documentation:
 * * When connected, RI take over the name of the PI (if the property `InheritPI`is set to false, it keeps it's name)
 */
void tst_IVInterface::tst_renameConnectedRIs()
{
    using namespace ivm::meta;
    auto func1 = addFunction("F1");
    ivm::IVInterfaceProvided *piInterface = addProvidedInterface(func1, "PI_name");

    auto func2 = addFunction("F2");
    ivm::IVInterfaceRequired *riInterface = addRequiredInterface(func2, "");
    QCOMPARE(riInterface->isInheritPI(), true);
    QCOMPARE(riInterface->title(), "RI_0");

    // create connection
    auto connection = new ivm::IVConnection(piInterface, riInterface);
    m_model->addObject(connection);
    connection->setInheritPI();
    QCOMPARE(riInterface->title(), "PI_name");
    QCOMPARE(riInterface->isInheritPI(), true);

    // Update name from PI
    piInterface->setTitle("PI_name_new");
    QCOMPARE(riInterface->title(), "PI_name_new");

    riInterface->setTitle("new_RI_name");
    QCOMPARE(riInterface->title(), "new_RI_name");

    // No update name from PI, because inheritPI is false
    riInterface->setEntityAttribute(Props::token(Props::Token::InheritPI), false);
    QCOMPARE(riInterface->isInheritPI(), false);
    piInterface->setTitle("another_PI_name");
    QCOMPARE(riInterface->title(), "new_RI_name");
}

/*!
 * See IVInterface documentation:
 * * If the auto renaming from the tool fails because there is already a RI with the same name on the function, then the
 * RI is prefixed with the remote function name.
 */
void tst_IVInterface::tst_InheritNamesFromFunctionTypesPrefixedFunction()
{
    auto funcType = new ivm::IVFunctionType;
    funcType->setTitle(QLatin1String("FT1"));
    m_model->addObject(funcType);
    ivm::IVInterfaceProvided *typePI = addProvidedInterface(funcType, "parse");
    ivm::IVInterfaceRequired *typeRI = addRequiredInterface(funcType, "parse");

    auto func1 = addFunction("F1");
    QCOMPARE(func1->interfaces().size(), 0);

    // Now inherit from the type
    ivm::IVInterfaceRequired *typeRINamedAlready = addRequiredInterface(func1, "parse");
    QCOMPARE(typeRINamedAlready->title(), "parse");
    auto clonePI = ivm::IVInterface::CreationInfo::cloneIface(typePI, func1);
    ivm::IVInterface *clonedPI = ivm::IVInterface::createIface(clonePI);
    func1->addChild(clonedPI);
    m_model->addObject(clonedPI);
    auto cloneRI = ivm::IVInterface::CreationInfo::cloneIface(typeRI, func1);
    ivm::IVInterface *clonedRI = ivm::IVInterface::createIface(cloneRI);
    func1->addChild(clonedRI);
    m_model->addObject(clonedRI);
    func1->setInstanceOf(funcType);
    QCOMPARE(func1->interfaces().size(), 3);

    QCOMPARE(clonedRI->title(), funcType->title() + "_" + typeRI->title());
}

QTEST_APPLESS_MAIN(tst_IVInterface)

#include "tst_ivinterface.moc"
